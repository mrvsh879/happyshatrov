<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — MVP</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 20% 20%, #1f79c7 0%, #0b1a2c 60%, #060c14 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select: none;
    }

    #wrap {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Canvas */
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Background image layer (optional) */
    #bg {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      filter: saturate(1.05) contrast(1.03);
      opacity: 1;
      z-index: 0;
    }

    #hud-left, #hud-right {
      position: absolute;
      top: 12px;
      z-index: 5;
      display: flex;
      gap: 10px;
      align-items: flex-start;
      pointer-events: none;
    }

    #hud-left { left: 12px; }
    #hud-right { right: 12px; }

    .panel {
      pointer-events: auto;
      background: rgba(10, 20, 35, 0.62);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      border-radius: 10px;
      color: #eaf2ff;
      padding: 10px 12px;
      min-width: 250px;
      backdrop-filter: blur(8px);
    }

    .panel h3 {
      margin: 0 0 6px 0;
      font-size: 14px;
      font-weight: 800;
      letter-spacing: 0.2px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 800;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.14);
    }

    .panel p {
      margin: 6px 0 0 0;
      font-size: 12px;
      line-height: 1.35;
      opacity: 0.95;
    }

    .btn {
      pointer-events: auto;
      appearance: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(30, 120, 255, 0.18);
      color: #eaf2ff;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 800;
      cursor: pointer;
      transition: transform .08s ease, background .15s ease;
      box-shadow: 0 10px 24px rgba(0,0,0,0.22);
    }
    .btn:hover { background: rgba(30, 120, 255, 0.28); }
    .btn:active { transform: translateY(1px) scale(0.99); }

    /* Score */
    .kv {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      margin-top: 8px;
      font-size: 12px;
    }
    .kv b { font-weight: 900; }

    /* Footer hint */
    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 12px;
      z-index: 5;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(10, 20, 35, 0.45);
      border: 1px solid rgba(255,255,255,0.10);
      color: rgba(234,242,255,0.92);
      font-size: 12px;
      backdrop-filter: blur(6px);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="bg"></div>
    <canvas id="c"></canvas>

    <div id="hud-left">
      <div class="panel">
        <h3><span class="badge">LEVEL 1</span> Office Birds</h3>
        <p>
          Зажми человечка → потяни назад → отпусти.<br>
          Чем сильнее натяжка, тем дальше полёт.
        </p>

        <div class="kv">
          <span>Счёт:</span> <b id="score">0</b>
          <span>Сломано элементов:</span> <b id="broken">0</b>
          <span>Попытка:</span> <b id="shots">0</b>
        </div>
      </div>

      <button class="btn" id="resetBtn">Reset (всё заново)</button>
    </div>

    <div id="hud-right">
      <div class="panel">
        <h3>Цель</h3>
        <p>
          Развали офисный домик (2 этажа).<br>
          Внутри сидят менеджеры в наушниках.<br>
          После выстрела: 2–3 сек разрушения → авто-респавн.<br>
          Домик НЕ восстанавливается (остаётся поломанным).
        </p>
        <div class="kv">
          <span>Статус:</span> <b id="status">Готов</b>
        </div>
      </div>
    </div>

    <div id="hint">Если фон не грузится — проверь путь к bg_office.png (код сам подхватит запасной вариант).</div>
  </div>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
    /********************
     *  ASSET PATHS
     ********************/
    const ASSETS = {
      bgPrimary: "assets/bg_office.png",
      bgFallback: "assets/office/bg_office.png",

      beam: "assets/office/beam.png",
      pillar: "assets/office/pillar.png",
      manager: "assets/office/manager.png",

      humanIdle: "assets/player/human_idle.png",
      humanFly: "assets/player/human_fly.png"
    };

    /********************
     *  UTIL: load image
     ********************/
    function loadImage(src) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ ok: true, img, src });
        img.onerror = () => resolve({ ok: false, img: null, src });
        img.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    function setStatus(txt) {
      document.getElementById("status").textContent = txt;
    }

    /********************
     *  MAIN
     ********************/
    (async function main() {
      // Background (optional): try primary -> fallback -> none (gradient stays)
      const bgEl = document.getElementById("bg");
      const bg1 = await loadImage(ASSETS.bgPrimary);
      if (bg1.ok) {
        bgEl.style.backgroundImage = `url('${ASSETS.bgPrimary}')`;
      } else {
        const bg2 = await loadImage(ASSETS.bgFallback);
        if (bg2.ok) {
          bgEl.style.backgroundImage = `url('${ASSETS.bgFallback}')`;
        } else {
          // leave gradient only
          console.warn("BG not loaded from:", ASSETS.bgPrimary, "or", ASSETS.bgFallback);
        }
      }

      // Preload gameplay sprites (not fatal if missing)
      const [beamImg, pillarImg, managerImg, idleImg, flyImg] = await Promise.all([
        loadImage(ASSETS.beam),
        loadImage(ASSETS.pillar),
        loadImage(ASSETS.manager),
        loadImage(ASSETS.humanIdle),
        loadImage(ASSETS.humanFly)
      ]);

      const SPR = {
        beam: beamImg.ok ? beamImg.img : null,
        pillar: pillarImg.ok ? pillarImg.img : null,
        manager: managerImg.ok ? managerImg.img : null,
        humanIdle: idleImg.ok ? idleImg.img : null,
        humanFly: flyImg.ok ? flyImg.img : null
      };

      /********************
       *  Matter setup
       ********************/
      const {
        Engine, Render, Runner, Bodies, Body, Composite, Composites,
        Constraint, Mouse, MouseConstraint, Events, Vector
      } = Matter;

      const canvas = document.getElementById("c");

      const engine = Engine.create({
        gravity: { x: 0, y: 1.0 }
      });

      const world = engine.world;

      const render = Render.create({
        canvas,
        engine,
        options: {
          width: window.innerWidth,
          height: window.innerHeight,
          wireframes: false,
          background: "transparent",
          pixelRatio: Math.min(window.devicePixelRatio || 1, 2)
        }
      });

      Render.run(render);

      const runner = Runner.create();
      Runner.run(runner, engine);

      // Resize
      function onResize() {
        render.options.width = window.innerWidth;
        render.options.height = window.innerHeight;
        render.canvas.width = window.innerWidth * render.options.pixelRatio;
        render.canvas.height = window.innerHeight * render.options.pixelRatio;
        Render.setPixelRatio(render, render.options.pixelRatio);

        // move ground to bottom
        Body.setPosition(ground, { x: window.innerWidth / 2, y: window.innerHeight - groundThickness/2 });
        Body.setVertices(ground, Bodies.rectangle(window.innerWidth/2, window.innerHeight - groundThickness/2, window.innerWidth + 200, groundThickness, { isStatic: true }).vertices);
      }
      window.addEventListener("resize", onResize);

      /********************
       *  Ground (visible)
       ********************/
      const groundThickness = 80;
      const ground = Bodies.rectangle(
        window.innerWidth / 2,
        window.innerHeight - groundThickness/2,
        window.innerWidth + 200,
        groundThickness,
        {
          isStatic: true,
          friction: 1.0,
          restitution: 0.0,
          render: {
            fillStyle: "rgba(0,0,0,0.25)",
            strokeStyle: "rgba(255,255,255,0.10)",
            lineWidth: 2
          }
        }
      );

      // A visible floor line / glossy strip
      const floorLine = Bodies.rectangle(
        window.innerWidth / 2,
        window.innerHeight - groundThickness,
        window.innerWidth + 200,
        6,
        {
          isStatic: true,
          isSensor: true,
          render: {
            fillStyle: "rgba(255,255,255,0.18)"
          }
        }
      );

      Composite.add(world, [ground, floorLine]);

      /********************
       *  Helpers: sprite bodies
       ********************/
      function makeSpriteRect(x, y, w, h, options, spriteImg) {
        const body = Bodies.rectangle(x, y, w, h, options);
        if (spriteImg) {
          body.render.sprite = {
            texture: spriteImg.src,
            xScale: w / spriteImg.naturalWidth,
            yScale: h / spriteImg.naturalHeight
          };
          body.render.fillStyle = "transparent";
        }
        return body;
      }

      // “damage/break” system
      let score = 0;
      let brokenCount = 0;

      function addScore(delta) {
        score += delta;
        document.getElementById("score").textContent = String(score);
      }
      function addBroken(n=1) {
        brokenCount += n;
        document.getElementById("broken").textContent = String(brokenCount);
      }

      function tagBreakable(body, hp, points) {
        body.plugin = body.plugin || {};
        body.plugin.breakable = { hp, points, broken: false };
        return body;
      }

      function breakBody(body) {
        if (!body || !body.plugin || !body.plugin.breakable) return;
        const b = body.plugin.breakable;
        if (b.broken) return;
        b.broken = true;

        // remove body
        Composite.remove(world, body);
        addBroken(1);
        addScore(b.points || 10);
      }

      /********************
       *  Build House (2 floors)
       *  Layout: 2 pillars on sides, beams top/mid/bottom, managers inside
       ********************/
      let structure = [];
      let managers = [];
      let structureFrozen = true; // to avoid initial collapse

      function clearWorldDynamic() {
        // remove all bodies except ground/floorLine
        const all = Composite.allBodies(world);
        for (const b of all) {
          if (b === ground || b === floorLine) continue;
          Composite.remove(world, b);
        }
        // remove constraints except mouse + sling
        const constraints = Composite.allConstraints(world);
        for (const c of constraints) {
          if (c === mouseConstraint.constraint) continue;
          Composite.remove(world, c);
        }
        structure = [];
        managers = [];
      }

      function buildHouse() {
        const W = window.innerWidth;
        const H = window.innerHeight;

        // house position and size
        const houseCenterX = Math.min(W * 0.72, W - 260);
        const baseY = H - groundThickness - 10;

        // size tuned: not too big, but wide enough for manager row
        const houseWidth = Math.min(420, W * 0.36);
        const floorGap = 150;        // height between floors
        const beamThickness = 26;
        const pillarWidth = 26;
        const pillarHeight = floorGap * 2 + beamThickness * 2 + 30;

        const leftX = houseCenterX - houseWidth/2;
        const rightX = houseCenterX + houseWidth/2;

        // bottom beam y
        const bottomBeamY = baseY - 40;
        const midBeamY = bottomBeamY - floorGap;
        const topBeamY = midBeamY - floorGap;

        // Pillars
        const pillarY = (bottomBeamY + topBeamY)/2;

        const commonPhys = {
          friction: 0.9,
          restitution: 0.02,
          density: 0.0022,
          render: { fillStyle: "rgba(255,255,255,0.05)" }
        };

        // Pillar sprites: keep proportions visually
        const pillarH = pillarHeight;
        const pillarW = pillarWidth;

        const leftPillar = tagBreakable(
          makeSpriteRect(leftX, pillarY, pillarW, pillarH,
            { ...commonPhys }, SPR.pillar),
          120, 40
        );
        const rightPillar = tagBreakable(
          makeSpriteRect(rightX, pillarY, pillarW, pillarH,
            { ...commonPhys }, SPR.pillar),
          120, 40
        );

        // Beams (top/mid/bottom) - use beam sprite
        const beamW = houseWidth + 24;
        const beamH = beamThickness;

        const bottomBeam = tagBreakable(
          makeSpriteRect(houseCenterX, bottomBeamY, beamW, beamH,
            { ...commonPhys }, SPR.beam),
          90, 25
        );
        const midBeam = tagBreakable(
          makeSpriteRect(houseCenterX, midBeamY, beamW, beamH,
            { ...commonPhys }, SPR.beam),
          90, 25
        );
        const topBeam = tagBreakable(
          makeSpriteRect(houseCenterX, topBeamY, beamW, beamH,
            { ...commonPhys }, SPR.beam),
          90, 25
        );

        // Make sure they start aligned and stable
        structure = [leftPillar, rightPillar, bottomBeam, midBeam, topBeam];
        Composite.add(world, structure);

        // Managers (small dynamic-ish but can be “protected”)
        // Put 3 managers on mid level inside (you asked “больше менеджеров”)
        // And keep them as breakable bodies too.
        const managerCount = 3;
        const mgrY = midBeamY - 34; // sit on midBeam
        const mgrSpacing = 60;
        const startX = houseCenterX - (mgrSpacing*(managerCount-1))/2;

        managers = [];
        for (let i=0; i<managerCount; i++) {
          const mx = startX + i*mgrSpacing;
          const mgr = tagBreakable(
            makeSpriteRect(mx, mgrY, 56, 56, {
              friction: 0.8,
              restitution: 0.05,
              density: 0.0016,
              render: { fillStyle: "transparent" }
            }, SPR.manager),
            45, 60
          );
          managers.push(mgr);
        }
        Composite.add(world, managers);

        // “Freeze” structure at start to avoid initial micro-collapses
        structureFrozen = true;
        freezeStructure(true);

        // After a short settling, keep frozen until first shot
        setTimeout(() => {
          // still frozen; we only unfreeze on first launch
        }, 300);
      }

      function freezeStructure(freeze) {
        const bodies = [...structure, ...managers];
        for (const b of bodies) {
          if (!b) continue;
          if (freeze) {
            Body.setVelocity(b, { x: 0, y: 0 });
            Body.setAngularVelocity(b, 0);
            b.isStatic = true; // important: truly frozen
          } else {
            b.isStatic = false;
          }
        }
      }

      /********************
       *  Bird + Slingshot
       ********************/
      const startPos = () => {
        const W = window.innerWidth;
        const H = window.innerHeight;
        return {
          x: Math.max(140, W * 0.13),
          y: H - groundThickness - 70
        };
      };

      let bird = null;
      let sling = null;
      let slingAnchor = null;
      let hasShot = false;
      let shots = 0;

      function updateShots() {
        document.getElementById("shots").textContent = String(shots);
      }

      function spawnBird() {
        const pos = startPos();

        // Bigger bird (human) as you wanted
        bird = makeSpriteRect(pos.x, pos.y, 96, 72, {
          friction: 0.8,
          restitution: 0.05,
          density: 0.0024,
          render: { fillStyle: "transparent" }
        }, SPR.humanIdle);

        bird.label = "BIRD";
        Composite.add(world, bird);

        slingAnchor = { x: pos.x + 10, y: pos.y - 10 };

        sling = Constraint.create({
          pointA: slingAnchor,
          bodyB: bird,
          pointB: { x: 0, y: 0 },
          stiffness: 0.016,
          damping: 0.05,
          length: 0
        });
        Composite.add(world, sling);

        hasShot = false;
        setStatus("Готов");
      }

      function setBirdFlying(isFlying) {
        if (!bird) return;
        const img = isFlying ? SPR.humanFly : SPR.humanIdle;
        if (!img) return;
        bird.render.sprite.texture = img.src;
        bird.render.sprite.xScale = bird.bounds.max.x - bird.bounds.min.x;
      }

      /********************
       * Mouse control
       ********************/
      const mouse = Mouse.create(render.canvas);
      const mouseConstraint = MouseConstraint.create(engine, {
        mouse,
        constraint: {
          stiffness: 0.12,
          render: { visible: false }
        }
      });
      Composite.add(world, mouseConstraint);
      render.mouse = mouse;

      // Limit pull distance
      const MAX_PULL = 120;

      function clampPull(point, anchor) {
        const v = Vector.sub(point, anchor);
        const d = Vector.magnitude(v);
        if (d <= MAX_PULL) return point;
        const dir = Vector.mult(Vector.normalise(v), MAX_PULL);
        return Vector.add(anchor, dir);
      }

      // When dragging bird, clamp mouse position effect
      Events.on(mouseConstraint, "mousemove", (e) => {
        // not needed
      });

      // On drag start: only if bird
      Events.on(mouseConstraint, "startdrag", (e) => {
        if (!bird) return;
        if (e.body === bird && !hasShot) {
          setStatus("Натяжка...");
        }
      });

      // On drag: clamp bird position around anchor
      Events.on(engine, "beforeUpdate", () => {
        if (!bird || hasShot) return;

        const m = mouseConstraint.mouse.position;
        if (!mouseConstraint.body) return;

        if (mouseConstraint.body === bird) {
          const clamped = clampPull(m, slingAnchor);
          Body.setPosition(bird, clamped);
          Body.setVelocity(bird, { x: 0, y: 0 });
          Body.setAngularVelocity(bird, 0);
        }
      });

      // On release: launch
      Events.on(mouseConstraint, "enddrag", (e) => {
        if (!bird || !sling) return;
        if (e.body !== bird) return;
        if (hasShot) return;

        // unfreeze structure on first shot so it doesn't fall earlier
        if (structureFrozen) {
          freezeStructure(false);
          structureFrozen = false;
        }

        // Launch impulse based on pull vector
        const pull = Vector.sub(slingAnchor, bird.position); // anchor - bird
        const power = 0.055; // tuned to not fly out of screen
        const impulse = Vector.mult(pull, power);

        // Remove sling to launch
        Composite.remove(world, sling);
        sling = null;

        // Push
        Body.setVelocity(bird, { x: impulse.x * 12, y: impulse.y * 12 });
        Body.setAngularVelocity(bird, 0);

        hasShot = true;
        shots += 1;
        updateShots();
        setStatus("Полет!");

        // switch to fly sprite after release
        if (SPR.humanFly) {
          bird.render.sprite.texture = SPR.humanFly.src;
          // Keep same scale: we already set based on size earlier
          bird.render.sprite.xScale = (bird.bounds.max.x - bird.bounds.min.x) / SPR.humanFly.naturalWidth;
          bird.render.sprite.yScale = (bird.bounds.max.y - bird.bounds.min.y) / SPR.humanFly.naturalHeight;
        }

        // Let destruction run 2.7s, then respawn new bird (structure stays)
        setTimeout(() => {
          respawnBirdKeepDamage();
        }, 2700);
      });

      function respawnBirdKeepDamage() {
        // remove bird if far away or stuck
        if (bird) {
          Composite.remove(world, bird);
          bird = null;
        }
        spawnBird();
        setStatus("Готов (домик остался поломанным)");
      }

      /********************
       *  Breaking logic
       ********************/
      // Damage from collisions: use "collisionStart" + pair impulse approximation
      Events.on(engine, "collisionStart", (event) => {
        const pairs = event.pairs;
        for (const p of pairs) {
          const a = p.bodyA;
          const b = p.bodyB;

          // compute impact “strength” from relative velocity
          const rel = Vector.sub(a.velocity, b.velocity);
          const impact = Vector.magnitude(rel);

          // Apply damage to breakables
          applyImpactDamage(a, impact);
          applyImpactDamage(b, impact);
        }
      });

      function applyImpactDamage(body, impact) {
        if (!body || !body.plugin || !body.plugin.breakable) return;

        // ignore micro taps
        if (impact < 2.2) return;

        const bb = body.plugin.breakable;
        if (bb.broken) return;

        // Damage scaling
        const dmg = impact * 10.5;

        bb.hp -= dmg;

        // Visual feedback: tint slightly as damaged
        const hpRatio = Math.max(0, Math.min(1, bb.hp / 120));
        const alpha = 0.12 + (1 - hpRatio) * 0.25;
        body.render.strokeStyle = `rgba(255, 180, 80, ${alpha})`;
        body.render.lineWidth = 2;

        if (bb.hp <= 0) {
          breakBody(body);
        }
      }

      /********************
       *  Custom drawing (sling line)
       ********************/
      Events.on(render, "afterRender", () => {
        const ctx = render.context;
        ctx.save();

        // Draw sling line if attached
        if (bird && sling && !hasShot) {
          ctx.beginPath();
          ctx.moveTo(slingAnchor.x, slingAnchor.y);
          ctx.lineTo(bird.position.x, bird.position.y);
          ctx.strokeStyle = "rgba(255,80,80,0.65)";
          ctx.lineWidth = 4;
          ctx.stroke();

          // anchor dot
          ctx.beginPath();
          ctx.arc(slingAnchor.x, slingAnchor.y, 5, 0, Math.PI*2);
          ctx.fillStyle = "rgba(255,255,255,0.65)";
          ctx.fill();
        }

        ctx.restore();
      });

      /********************
       *  Reset Button
       ********************/
      document.getElementById("resetBtn").addEventListener("click", () => {
        setStatus("Сброс...");
        score = 0;
        brokenCount = 0;
        shots = 0;
        document.getElementById("score").textContent = "0";
        document.getElementById("broken").textContent = "0";
        updateShots();

        clearWorldDynamic();
        buildHouse();
        spawnBird();
        setStatus("Готов");
      });

      /********************
       *  Boot
       ********************/
      buildHouse();
      spawnBird();
      updateShots();
      setStatus("Готов");

      // One more safety: if assets missing, still run
      if (!SPR.beam || !SPR.pillar || !SPR.manager || !SPR.humanIdle) {
        console.warn("Some sprites not loaded. Game will still run with invisible/placeholder bodies.");
      }

      // Improve stability a bit
      engine.positionIterations = 8;
      engine.velocityIterations = 6;
      engine.constraintIterations = 3;

      // Slight air friction for all bodies
      Events.on(engine, "beforeUpdate", () => {
        const bodies = Matter.Composite.allBodies(world);
        for (const b of bodies) {
          if (b.isStatic) continue;
          // Keep it subtle
          b.frictionAir = 0.015;
        }
      });

    })();
  </script>
</body>
</html>
