<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — Level 1</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0b1320;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    canvas{display:block}
    .ui{
      position:fixed;left:14px;top:14px;z-index:5;
      color:#eaf2ff;font-size:12px;line-height:1.35;
      background:rgba(10,18,32,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;padding:10px 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      max-width: 360px;
    }
    .row{display:flex;gap:10px;align-items:center;margin-bottom:6px}
    .pill{
      font-weight:700;font-size:11px;letter-spacing:.08em;
      padding:4px 8px;border-radius:999px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.08);
    }
    .title{font-weight:800;font-size:14px;margin-right:6px}
    button{
      appearance:none;border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.08);color:#eaf2ff;
      padding:6px 10px;border-radius:10px;cursor:pointer;
      font-weight:700;font-size:12px;
    }
    button:hover{background:rgba(255,255,255,.12)}
    .goal{
      position:fixed;right:14px;top:14px;z-index:5;
      color:#eaf2ff;font-size:12px;line-height:1.35;
      background:rgba(10,18,32,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;padding:10px 12px;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 30px rgba(0,0,0,.25);
      max-width: 360px;
      text-align:left;
    }
    .hint{opacity:.9}
    .small{opacity:.75;font-size:11px}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="ui">
    <div class="row">
      <span class="pill">LEVEL 1</span>
      <span class="title">Office Birds</span>
      <button id="resetBtn">Reset (всё заново)</button>
    </div>
    <div class="hint">
      Зажми на человечке → потяни назад → отпусти.<br>
      Чем сильнее натяжка, тем дальше полёт.
    </div>
    <div class="small" id="status"></div>
  </div>

  <div class="goal">
    <div style="font-weight:800;margin-bottom:6px">Цель</div>
    Развали домик из балок/стоек (2 этажа).<br>
    Внутри сидят менеджеры в наушниках.
    <div class="small" style="margin-top:6px">
      После выстрела: 2–3 сек разрушения → авто-респавн.<br>
      Домик не восстанавливается (остаётся поломанным).
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
  (() => {
    const {
      Engine, World, Bodies, Body, Composite, Events, Vector, Sleeping
    } = Matter;

    // ----------------- assets -----------------
    const ASSETS = {
      bg:      "assets/office/bg_office.png",
      beam:    "assets/office/beam.png",
      pillar:  "assets/office/pillar.png",
      manager: "assets/office/manager.png",
      idle:    "assets/player/human_idle.png",
      fly:     "assets/player/human_fly.png"
    };

    // ----------------- canvas -----------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");

    function resize() {
      canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
      canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      canvas.style.width = window.innerWidth + "px";
      canvas.style.height = window.innerHeight + "px";
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", resize);
    resize();

    // ----------------- loader -----------------
    function loadImage(src){
      return new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => res(img);
        img.onerror = () => rej(new Error("Не грузится: " + src));
        img.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    let IMG = {};
    Promise.all(Object.entries(ASSETS).map(async ([k,src]) => [k, await loadImage(src)]))
      .then(pairs => {
        IMG = Object.fromEntries(pairs);
        init();
      })
      .catch(err => {
        statusEl.textContent = err.message;
        console.error(err);
      });

    // ----------------- game state -----------------
    let engine, world;
    let ground, leftWall, rightWall, ceiling;
    let player, slingOrigin;
    let houseBodies = [];
    let managers = [];
    let aiming = false;
    let canShoot = true;
    let launched = false;
    let aimNow = {x:0,y:0};
    let pullVec = {x:0,y:0};

    // tuning
    const RESPAWN_AFTER_MS = 2700;
    const MAX_PULL = 140;      // px
    const POWER = 0.028;       // сила броска (уменьшено)
    const PLAYER_R = 26;       // физ. радиус игрока
    const MANAGER_R = 18;

    function init(){
      setupWorld(true);
      requestAnimationFrame(loop);
    }

    function setupWorld(fullReset){
      engine = Engine.create();
      engine.gravity.y = 1.05; // обычная гравитация
      world = engine.world;

      const W = window.innerWidth;
      const H = window.innerHeight;

      // границы
      ground   = Bodies.rectangle(W/2, H-18, W+200, 36, { isStatic:true, label:"ground" });
      leftWall = Bodies.rectangle(-40, H/2, 80, H+200, { isStatic:true, label:"wall" });
      rightWall= Bodies.rectangle(W+40, H/2, 80, H+200, { isStatic:true, label:"wall" });
      ceiling  = Bodies.rectangle(W/2, -40, W+200, 80, { isStatic:true, label:"ceiling" });

      World.add(world, [ground, leftWall, rightWall, ceiling]);

      // точка рогатки (поднял выше, чтобы не улетал за низ/края)
      slingOrigin = { x: Math.max(140, W*0.12), y: H*0.72 };

      // игрок
      spawnPlayer();

      // дом
      buildHouse();

      // чтобы домик НЕ разваливался на старте — усыпляем всё
      for (const b of houseBodies) Sleeping.set(b, true);
      for (const m of managers) Sleeping.set(m, true);

      aiming = false;
      canShoot = true;
      launched = false;
      pullVec = {x:0,y:0};

      statusEl.textContent = "Готово.";
      bindInput();
    }

    function spawnPlayer(){
      // игрок сначала статичный (как будто “держится”)
      player = Bodies.circle(slingOrigin.x, slingOrigin.y, PLAYER_R, {
        isStatic: true,
        restitution: 0.1,
        friction: 0.9,
        frictionAir: 0.02,
        label: "player"
      });
      World.add(world, player);
    }

    function buildHouse(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      // СКЕЙЛ домика (сделал компактнее, но крупнее чем было “крошкой”)
      const s = Math.min(W/1600, H/900) * 1.05;

      // позиция домика ближе к игроку
      const baseX = W*0.62;
      const baseY = H*0.78;

      // размеры (в пикселях “мира”)
      const pillarH = 220*s;
      const beamLen = 360*s;
      const beamT   = 26*s;   // “толщина” балки (для физики)

      const floorGap = 110*s; // расстояние между этажами

      // координаты стоек
      const leftX  = baseX - beamLen/2;
      const rightX = baseX + beamLen/2;

      const bottomY = baseY;
      const midY    = baseY - floorGap;
      const topY    = baseY - floorGap*2;

      // 2 pillar
      const pL = Bodies.rectangle(leftX,  baseY - pillarH/2 + 10*s, 28*s, pillarH, {
        label:"pillar", density:0.0035, friction:0.9, restitution:0.05
      });
      const pR = Bodies.rectangle(rightX, baseY - pillarH/2 + 10*s, 28*s, pillarH, {
        label:"pillar", density:0.0035, friction:0.9, restitution:0.05
      });

      // 4 beam (нижняя, межэтажная, верхняя, и “потолок” второго этажа)
      const bBottom = Bodies.rectangle(baseX, bottomY, beamLen, beamT, {
        label:"beam", density:0.0028, friction:0.9, restitution:0.05
      });
      const bMid    = Bodies.rectangle(baseX, midY, beamLen, beamT, {
        label:"beam", density:0.0028, friction:0.9, restitution:0.05
      });
      const bTop    = Bodies.rectangle(baseX, topY, beamLen, beamT, {
        label:"beam", density:0.0028, friction:0.9, restitution:0.05
      });
      // дополнительная внутренняя балка (чтобы выглядело как “общая конструкция” и было 2 этажа)
      const bCeil2  = Bodies.rectangle(baseX, topY - floorGap, beamLen, beamT, {
        label:"beam", density:0.0028, friction:0.9, restitution:0.05
      });

      houseBodies = [pL,pR,bBottom,bMid,bTop,bCeil2];
      World.add(world, houseBodies);

      // менеджеры (3 штуки) — стоят на средней балке, оставляем место по ширине
      const mgrCount = 3;
      managers = [];
      for(let i=0;i<mgrCount;i++){
        const t = (i+1)/(mgrCount+1); // 0..1
        const x = (leftX + 55*s) + (beamLen - 110*s)*t; // отступы, чтобы “влез”
        const y = midY - (beamT/2 + MANAGER_R + 4*s);
        const m = Bodies.circle(x, y, MANAGER_R, {
          label:"manager",
          density:0.0022,
          friction:0.8,
          restitution:0.1,
          frictionAir: 0.02
        });
        managers.push(m);
      }
      World.add(world, managers);

      // не даём им появиться в “пересечениях” — чуть фиксируем позиции
      for (const b of houseBodies) {
        Body.setVelocity(b, {x:0,y:0});
        Body.setAngularVelocity(b, 0);
      }
      for (const m of managers) {
        Body.setVelocity(m, {x:0,y:0});
        Body.setAngularVelocity(m, 0);
      }
    }

    // ----------------- input -----------------
    let inputBound = false;
    function bindInput(){
      if(inputBound) return;
      inputBound = true;

      function toCanvas(e){
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      window.addEventListener("mousedown", (e) => {
        if(!canShoot) return;

        const p = toCanvas(e);
        const dx = p.x - player.position.x;
        const dy = p.y - player.position.y;
        if(Math.hypot(dx,dy) <= PLAYER_R*1.8){
          aiming = true;
          aimNow = p;
        }
      });

      window.addEventListener("mousemove", (e) => {
        if(!aiming) return;
        aimNow = toCanvas(e);

        // pull = origin - cursor
        const pull = { x: slingOrigin.x - aimNow.x, y: slingOrigin.y - aimNow.y };
        const len = Math.hypot(pull.x, pull.y) || 1;
        const k = Math.min(1, MAX_PULL/len);
        pullVec = { x: pull.x*k, y: pull.y*k };

        // двигаем игрока “на резинке”
        Body.setPosition(player, { x: slingOrigin.x - pullVec.x, y: slingOrigin.y - pullVec.y });
      });

      window.addEventListener("mouseup", () => {
        if(!aiming) return;
        aiming = false;

        if(!canShoot) return;

        // запускаем
        launchPlayer();
      });

      // touch
      window.addEventListener("touchstart", (e) => {
        if(!canShoot) return;
        const t = e.touches[0];
        if(!t) return;

        const rect = canvas.getBoundingClientRect();
        const p = { x: t.clientX-rect.left, y: t.clientY-rect.top };

        const dx = p.x - player.position.x;
        const dy = p.y - player.position.y;
        if(Math.hypot(dx,dy) <= PLAYER_R*2){
          aiming = true;
          aimNow = p;
          e.preventDefault();
        }
      }, {passive:false});

      window.addEventListener("touchmove", (e) => {
        if(!aiming) return;
        const t = e.touches[0];
        if(!t) return;

        const rect = canvas.getBoundingClientRect();
        aimNow = { x: t.clientX-rect.left, y: t.clientY-rect.top };

        const pull = { x: slingOrigin.x - aimNow.x, y: slingOrigin.y - aimNow.y };
        const len = Math.hypot(pull.x, pull.y) || 1;
        const k = Math.min(1, MAX_PULL/len);
        pullVec = { x: pull.x*k, y: pull.y*k };

        Body.setPosition(player, { x: slingOrigin.x - pullVec.x, y: slingOrigin.y - pullVec.y });
        e.preventDefault();
      }, {passive:false});

      window.addEventListener("touchend", () => {
        if(!aiming) return;
        aiming = false;
        if(!canShoot) return;
        launchPlayer();
      });

      document.getElementById("resetBtn").addEventListener("click", () => {
        // полный сброс: дом восстанавливается
        Composite.clear(world, false);
        setupWorld(true);
      });
    }

    function wakeHouse(){
      for (const b of houseBodies) Sleeping.set(b, false);
      for (const m of managers) Sleeping.set(m, false);
    }

    function launchPlayer(){
      if(launched) return;

      canShoot = false;
      launched = true;

      wakeHouse(); // дом просыпается только перед полётом

      // делаем игрока динамическим
      Body.setStatic(player, false);

      // сила = pullVec * POWER, ограничение по максимуму
      const vx = pullVec.x * (POWER * 60);
      const vy = pullVec.y * (POWER * 60);

      // небольшой “анти-улёт”: ограничим максимальную скорость
      const v = { x: Math.max(-22, Math.min(22, vx)), y: Math.max(-18, Math.min(18, vy)) };

      Body.setVelocity(player, v);
      Body.setAngularVelocity(player, v.x * 0.015);

      statusEl.textContent = "Удар! Разрушение 2–3 сек… потом респавн.";

      // респавн игрока, дом остаётся поломанным
      setTimeout(() => {
        // удаляем старого игрока
        try { World.remove(world, player); } catch(e){}
        spawnPlayer();

        // снова можно целиться
        canShoot = true;
        launched = false;
        pullVec = {x:0,y:0};

        statusEl.textContent = "Игрок респавнился. Домик остался поломанным.";
      }, RESPAWN_AFTER_MS);
    }

    // ----------------- rendering -----------------
    function drawSprite(img, x, y, w, h, angle=0){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.drawImage(img, -w/2, -h/2, w, h);
      ctx.restore();
    }

    function loop(){
      Engine.update(engine, 1000/60);

      // мягкий “кламп” игрока, чтобы не улетал совсем за край (но мог падать/врезаться)
      if(player && !player.isStatic){
        const W = window.innerWidth, H = window.innerHeight;
        const p = player.position;

        // если улетел слишком далеко — чуть тормозим и возвращаем в пределы
        const margin = 40;
        const clamped = {
          x: Math.max(-margin, Math.min(W+margin, p.x)),
          y: Math.max(-margin, Math.min(H+margin, p.y))
        };
        if(clamped.x !== p.x || clamped.y !== p.y){
          Body.setPosition(player, clamped);
          Body.setVelocity(player, {x: player.velocity.x*0.75, y: player.velocity.y*0.75});
        }
      }

      render();
      requestAnimationFrame(loop);
    }

    function render(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      // фон
      ctx.clearRect(0,0,W,H);
      if(IMG.bg){
        ctx.drawImage(IMG.bg, 0, 0, W, H);
      } else {
        ctx.fillStyle="#0b1320";
        ctx.fillRect(0,0,W,H);
      }

      // домик (балки/стойки) — рисуем по телам
      for(const b of houseBodies){
        const pos = b.position;
        const ang = b.angle;

        if(b.label === "beam"){
          // ширина/высота берём из bounds
          const w = b.bounds.max.x - b.bounds.min.x;
          const h = b.bounds.max.y - b.bounds.min.y;
          drawSprite(IMG.beam, pos.x, pos.y, w, h, ang);
        }
        if(b.label === "pillar"){
          const w = (b.bounds.max.x - b.bounds.min.x) * 1.25; // чуть шире, чтобы картинка смотрелась
          const h = (b.bounds.max.y - b.bounds.min.y) * 1.02;
          drawSprite(IMG.pillar, pos.x, pos.y, w, h, ang);
        }
      }

      // менеджеры
      for(const m of managers){
        const pos = m.position;
        const size = (MANAGER_R*2) * 2.0; // визуально побольше
        drawSprite(IMG.manager, pos.x, pos.y, size, size, m.angle);
      }

      // игрок (idle/fly)
      if(player){
        const pos = player.position;
        const angle = player.angle;

        const speed = Math.hypot(player.velocity.x, player.velocity.y);
        const flying = (!player.isStatic && speed > 1.2);
        const img = flying ? IMG.fly : IMG.idle;

        // визуальный размер
        const size = PLAYER_R*2 * 2.3;
        drawSprite(img, pos.x, pos.y, size, size, angle);
      }

      // линия натяжки
      if(aiming && player){
        ctx.save();
        ctx.lineWidth = 5;
        ctx.strokeStyle = "rgba(255,90,90,0.9)";
        ctx.shadowColor = "rgba(255,90,90,0.35)";
        ctx.shadowBlur = 14;
        ctx.beginPath();
        ctx.moveTo(slingOrigin.x, slingOrigin.y);
        ctx.lineTo(player.position.x, player.position.y);
        ctx.stroke();

        // точка
        ctx.fillStyle="rgba(255,255,255,0.95)";
        ctx.beginPath();
        ctx.arc(slingOrigin.x, slingOrigin.y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
  })();
  </script>
</body>
</html>
