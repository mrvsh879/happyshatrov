<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — Level 1</title>
  <style>
    :root {
      --bg1:#0b1220;
      --panel: rgba(255,255,255,.08);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: #7cf7ff;
      --danger: #ff6b8b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background: radial-gradient(1200px 800px at 20% 10%, #13304a 0%, var(--bg1) 45%, #070b12 100%);
      overflow: hidden;
    }
    #wrap { position: relative; width: 100vw; height: 100vh; }
    canvas { display:block; width:100%; height:100%; }

    .hud {
      position: absolute;
      left: 16px;
      top: 16px;
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--panel), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      user-select: none;
    }
    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(124,247,255,.12);
      border: 1px solid rgba(124,247,255,.25);
      color: var(--accent);
      font-weight: 700;
      font-size: 12px;
    }
    .title { display:flex; flex-direction:column; gap:2px; min-width: 220px; }
    .title b { font-size: 13px; }
    .title span { font-size: 12px; color: var(--muted); }

    .btns { display:flex; gap:8px; }
    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      transition: transform .08s ease, border-color .2s ease;
    }
    button:hover { border-color: rgba(124,247,255,.35); }
    button:active { transform: translateY(1px) scale(.99); }
    .danger { border-color: rgba(255,107,139,.35); }
    .danger:hover { border-color: rgba(255,107,139,.55); }

    .tip {
      position: absolute;
      right: 16px;
      top: 16px;
      max-width: 360px;
      padding: 12px 14px;
      border-radius: 14px;
      background: linear-gradient(180deg, var(--panel), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
    .tip b { color: var(--text); }
  </style>
</head>
<body>
<div id="wrap">
  <div class="hud">
    <div class="badge">LEVEL 1</div>
    <div class="title">
      <b>Office Birds</b>
      <span>Зажми на “человеке на стуле” → потяни → отпусти</span>
    </div>
    <div class="btns">
      <button id="resetBtn" class="danger">Reset</button>
      <button id="nextBtn">Next ▶</button>
    </div>
  </div>

  <div class="tip">
    <b>Цель:</b> развали офисный домик и сбей “наушников”.<br/>
    <b>Фишка:</b> когда ты не трогаешь персонажа — он <b>качает стул</b>.
  </div>

  <canvas id="c"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
(() => {
  const {
    Engine, Render, Runner, Bodies, Body, Composite, Constraint,
    Mouse, MouseConstraint, Events, Vector
  } = Matter;

  const canvas = document.getElementById('c');

  const engine = Engine.create();
  engine.gravity.y = 1.05;

  const render = Render.create({
    canvas,
    engine,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: 'transparent',
      pixelRatio: Math.min(window.devicePixelRatio || 1, 2)
    }
  });

  const runner = Runner.create();
  Runner.run(runner, engine);
  Render.run(render);

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function resize() {
    render.options.width = window.innerWidth;
    render.options.height = window.innerHeight;
    render.canvas.width = Math.floor(window.innerWidth * render.options.pixelRatio);
    render.canvas.height = Math.floor(window.innerHeight * render.options.pixelRatio);
    render.canvas.style.width = window.innerWidth + 'px';
    render.canvas.style.height = window.innerHeight + 'px';
  }

  window.addEventListener('resize', () => {
    resize();
    buildLevel();
  });

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.lineTo(x+w-rr, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
    ctx.lineTo(x+w, y+h-rr);
    ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
    ctx.lineTo(x+rr, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
    ctx.lineTo(x, y+rr);
    ctx.quadraticCurveTo(x, y, x+rr, y);
    ctx.closePath();
  }

  function drawBackground(ctx) {
    const w = render.options.width, h = render.options.height;

    ctx.save();
    const g = ctx.createLinearGradient(0, h*0.55, 0, h);
    g.addColorStop(0, 'rgba(255,255,255,0)');
    g.addColorStop(1, 'rgba(255,255,255,0.06)');
    ctx.fillStyle = g;
    ctx.fillRect(0, h*0.55, w, h*0.45);

    for (let i=0;i<3;i++){
      const x = w*(0.15 + i*0.23);
      const lg = ctx.createRadialGradient(x, h*0.1, 10, x, h*0.1, h*0.9);
      lg.addColorStop(0, 'rgba(124,247,255,0.10)');
      lg.addColorStop(1, 'rgba(124,247,255,0)');
      ctx.fillStyle = lg;
      ctx.beginPath();
      ctx.ellipse(x, h*0.25, w*0.18, h*0.55, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawOfficePerson(ctx, body) {
    const p = body.position;
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(body.angle);

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(0, 18, 26, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.arc(0, 0, 16, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle = 'rgba(124,247,255,0.9)';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(0, -2, 18, Math.PI*0.15, Math.PI*0.85);
    ctx.stroke();

    ctx.fillStyle = 'rgba(124,247,255,0.9)';
    ctx.beginPath(); ctx.arc(-15, 2, 5.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 15, 2, 5.5, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle = 'rgba(255,107,139,0.9)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(12, 8);
    ctx.lineTo(24, 14);
    ctx.stroke();

    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-5, 8);
    ctx.lineTo(5, 8);
    ctx.stroke();

    ctx.restore();
  }

  function drawProjectile(ctx, body, mouseConstraint) {
    const p = body.position;
    const isDragging = mouseConstraint && mouseConstraint.body === body;

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(body.angle);

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(8, 34, 34, 14, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    roundRect(ctx, -24, 26, 68, 10, 6); ctx.fill();

    ctx.fillStyle = 'rgba(124,247,255,0.55)';
    for (let i=0;i<4;i++){
      ctx.beginPath();
      ctx.arc(-16 + i*18, 36, 4, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.fillStyle = 'rgba(255,255,255,0.16)';
    roundRect(ctx, -10, 8, 44, 18, 8); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    roundRect(ctx, 18, -16, 14, 28, 7); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.70)';
    roundRect(ctx, -8, -8, 18, 18, 7); ctx.fill();

    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.arc(0, -18, 10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = 'rgba(255,107,139,0.9)';
    ctx.beginPath();
    ctx.moveTo(2, 2);
    ctx.lineTo(10, 10);
    ctx.lineTo(2, 14);
    ctx.closePath();
    ctx.fill();

    if (isDragging) {
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = 'rgba(124,247,255,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 46, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();
  }

  // Scene vars
  let ground, leftWall, rightWall;
  let slingAnchor, slingConstraint, projectile;
  let mouseConstraint;
  let officeBlocks = [];
  let officePeople = [];

  function clearWorld() {
    Composite.clear(engine.world, false);
    officeBlocks = [];
    officePeople = [];
    ground = leftWall = rightWall = null;
    slingAnchor = slingConstraint = projectile = null;
    mouseConstraint = null;
  }

  function buildLevel() {
    clearWorld();

    const W = window.innerWidth;
    const H = window.innerHeight;

    ground = Bodies.rectangle(W/2, H+40, W+200, 120, {
      isStatic: true,
      render: { fillStyle: 'rgba(255,255,255,0.08)' }
    });
    leftWall = Bodies.rectangle(-60, H/2, 120, H+200, { isStatic: true, render: { visible:false }});
    rightWall = Bodies.rectangle(W+60, H/2, 120, H+200, { isStatic: true, render: { visible:false }});

    Composite.add(engine.world, [ground, leftWall, rightWall]);

    const slingX = W * 0.18;
    const slingY = H * 0.62;

    slingAnchor = { x: slingX, y: slingY };

    projectile = Bodies.circle(slingX + 40, slingY - 10, 26, {
      density: 0.005,
      restitution: 0.35,
      friction: 0.6,
      frictionAir: 0.012,
      render: { visible: false }
    });

    slingConstraint = Constraint.create({
      pointA: slingAnchor,
      bodyB: projectile,
      stiffness: 0.028,
      damping: 0.06,
      length: 10,
      render: { strokeStyle: 'rgba(124,247,255,0.65)', lineWidth: 4 }
    });

    Composite.add(engine.world, [projectile, slingConstraint]);

    const slingPlatform = Bodies.rectangle(slingX+40, slingY+60, 260, 24, {
      isStatic: true,
      render: { fillStyle: 'rgba(255,255,255,0.10)' }
    });
    Composite.add(engine.world, slingPlatform);

    // office tower
    const baseX = W * 0.72;
    const baseY = H * 0.70;

    const officeBase = Bodies.rectangle(baseX, baseY+90, 440, 26, {
      isStatic: true,
      render: { fillStyle: 'rgba(255,255,255,0.10)' }
    });
    Composite.add(engine.world, officeBase);

    const blockOpts = (fill) => ({
      density: 0.0022,
      restitution: 0.15,
      friction: 0.8,
      render: { fillStyle: fill, strokeStyle: 'rgba(255,255,255,0.10)', lineWidth: 1 }
    });

    const glass = 'rgba(124,247,255,0.10)';
    const wood  = 'rgba(255,255,255,0.12)';
    const metal = 'rgba(255,255,255,0.16)';

    officeBlocks.push(
      Bodies.rectangle(baseX-120, baseY+40, 26, 140, blockOpts(wood)),
      Bodies.rectangle(baseX+120, baseY+40, 26, 140, blockOpts(wood)),
      Bodies.rectangle(baseX,      baseY-30, 340, 26, blockOpts(metal)),
      Bodies.rectangle(baseX-90, baseY-80, 22, 120, blockOpts(glass)),
      Bodies.rectangle(baseX+90, baseY-80, 22, 120, blockOpts(glass)),
      Bodies.rectangle(baseX,    baseY-150, 260, 22, blockOpts(metal)),
      Bodies.rectangle(baseX-60, baseY-210, 20, 90, blockOpts(wood)),
      Bodies.rectangle(baseX+60, baseY-210, 20, 90, blockOpts(wood)),
      Bodies.rectangle(baseX,    baseY-255, 180, 18, blockOpts(metal))
    );
    Composite.add(engine.world, officeBlocks);

    function addOfficePerson(x, y) {
      const b = Bodies.circle(x, y, 18, {
        density: 0.0014,
        restitution: 0.25,
        friction: 0.9,
        frictionAir: 0.02,
        render: { visible: false }
      });
      officePeople.push(b);
      Composite.add(engine.world, b);
    }
    addOfficePerson(baseX - 60, baseY + 10);
    addOfficePerson(baseX + 10, baseY - 110);
    addOfficePerson(baseX + 40, baseY - 210);

    // mouse
    const mouse = Mouse.create(render.canvas);
    mouse.pixelRatio = render.options.pixelRatio;

    mouseConstraint = MouseConstraint.create(engine, {
      mouse,
      constraint: {
        stiffness: 0.12,
        damping: 0.12,
        render: { visible: false }
      }
    });
    Composite.add(engine.world, mouseConstraint);

    render.canvas.addEventListener('touchstart', e => e.preventDefault(), { passive:false });
    render.canvas.addEventListener('touchmove', e => e.preventDefault(), { passive:false });

    // ---------- FIX: launch direction ----------
    let hasLaunched = false;

    Events.off(mouseConstraint, 'enddrag');
    Events.on(mouseConstraint, 'enddrag', (evt) => {
      if (evt.body !== projectile) return;
      if (!slingConstraint.bodyB) return;

      const stretchVec = Vector.sub(projectile.position, slingAnchor); // <-- ВАЖНО: projectile - anchor
      const d = Vector.magnitude(stretchVec);

      // запускаем только если реально натянули
      if (d > 35) {
        slingConstraint.bodyB = null;
        hasLaunched = true;

        // сила зависит от натяжения
        const dir = Vector.normalise(stretchVec); // <-- летим туда, куда тянули
        const power = clamp(d / 220, 0, 1);       // 0..1
        const forceMag = 0.018 + power * 0.030;   // подстройка "ощущения"
        Body.applyForce(projectile, projectile.position, Vector.mult(dir, forceMag));
      }
    });

    // clamp drag distance + idle rocking
    Events.off(engine, 'afterUpdate');
    Events.on(engine, 'afterUpdate', () => {
      if (!projectile) return;

      const dragging = mouseConstraint.body === projectile;

      if (slingConstraint.bodyB && !dragging) {
        const t = engine.timing.timestamp * 0.002;
        Body.setAngularVelocity(projectile, Math.sin(t) * 0.02);

        const toHome = Vector.sub({x: slingAnchor.x + 40, y: slingAnchor.y - 10}, projectile.position);
        Body.applyForce(projectile, projectile.position, Vector.mult(toHome, 0.00003));
      }

      if (dragging && slingConstraint.bodyB) {
        const v = Vector.sub(projectile.position, slingAnchor);
        const mag = Vector.magnitude(v);
        if (mag > 220) {
          const nv = Vector.mult(Vector.normalise(v), 220);
          Body.setPosition(projectile, Vector.add(slingAnchor, nv));
        }
      }
    });

    // win check (optional)
    let won = false;
    Events.on(engine, 'afterUpdate', () => {
      if (won || !hasLaunched) return;
      const downCount = officePeople.filter(p => p.position.y > (H * 0.82)).length;
      if (downCount >= officePeople.length) won = true;
    });

    // custom render
    Events.off(render, 'beforeRender');
    Events.off(render, 'afterRender');

    Events.on(render, 'beforeRender', () => {
      const ctx = render.context;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,render.canvas.width, render.canvas.height);

      const pr = render.options.pixelRatio;
      ctx.scale(pr, pr);
      drawBackground(ctx);
    });

    Events.on(render, 'afterRender', () => {
      const ctx = render.context;
      const pr = render.options.pixelRatio;
      ctx.save();
      ctx.setTransform(pr,0,0,pr,0,0);

      // sling post
      ctx.save();
      ctx.translate(slingAnchor.x, slingAnchor.y);
      ctx.fillStyle = 'rgba(255,255,255,0.10)';
      roundRect(ctx, -14, -40, 28, 120, 12); ctx.fill();
      ctx.fillStyle = 'rgba(124,247,255,0.20)';
      roundRect(ctx, -10, -36, 20, 36, 10); ctx.fill();
      ctx.restore();

      // band line
      if (projectile && slingConstraint && slingConstraint.bodyB) {
        const a = slingAnchor;
        const b = projectile.position;
        ctx.strokeStyle = 'rgba(255,107,139,0.75)';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }

      for (const p of officePeople) drawOfficePerson(ctx, p);
      if (projectile) drawProjectile(ctx, projectile, mouseConstraint);

      ctx.restore();
    });

    resize();
  }

  document.getElementById('resetBtn').addEventListener('click', () => buildLevel());
  document.getElementById('nextBtn').addEventListener('click', () => { /* заглушка */ });

  buildLevel();
})();
</script>
</body>
</html>
