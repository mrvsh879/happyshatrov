<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — Level 1</title>
  <style>
    html,body{height:100%;margin:0;background:#050914;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #ui {
      position:fixed; left:14px; top:12px; z-index:10; color:#d7f6ff;
      display:flex; gap:10px; align-items:flex-start;
    }
    .panel{
      background:rgba(20,28,40,.62);
      border:1px solid rgba(140,220,255,.18);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      border-radius:12px; padding:10px 12px; backdrop-filter: blur(8px);
      max-width:520px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      font-size:12px; font-weight:700; letter-spacing:.3px;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(140,220,255,.25);
      background:rgba(0,0,0,.18)
    }
    .title{font-weight:800;margin:2px 0 6px 0;font-size:14px}
    .hint{opacity:.92;font-size:12px;line-height:1.25}
    button{
      cursor:pointer; border-radius:10px; border:1px solid rgba(140,220,255,.25);
      background:rgba(255,255,255,.06); color:#d7f6ff;
      padding:8px 12px; font-weight:700;
    }
    button:hover{background:rgba(255,255,255,.10)}
    #goal{
      position:fixed; right:14px; top:12px; z-index:10; color:#d7f6ff;
      width:300px;
    }
    #loading {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(1200px 700px at 20% 20%, rgba(0,140,255,.25), rgba(0,0,0,.65));
      z-index:20; color:#d7f6ff;
    }
    .loadbox{
      width:min(560px,92vw);
      background:rgba(10,16,26,.72);
      border:1px solid rgba(140,220,255,.18);
      border-radius:14px;
      padding:14px 16px;
      box-shadow:0 18px 45px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .bar{height:10px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:10px}
    .bar > div{height:100%;width:0%;background:linear-gradient(90deg,#7efcff,#5aa8ff)}
    .small{font-size:12px;opacity:.9;margin-top:8px;line-height:1.25}
    canvas{display:block;width:100vw;height:100vh}
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div class="badge">LEVEL 1</div>
      <div class="title">Office Birds</div>
      <div class="hint">
        Зажми на <b>человечке</b> → потяни <b>назад</b> → отпусти.<br>
        Чем сильнее натяжка, тем дальше полёт.
      </div>
    </div>
    <button id="resetBtn">Reset</button>
  </div>

  <div id="goal" class="panel">
    <div class="title">Цель</div>
    <div class="hint">
      Развали офисный домик из столов/стоек/стекла и мониторов.<br>
      <b>Готово под менеджера:</b> в коде есть слот <code>manager</code> (пока выключен).
    </div>
  </div>

  <div id="loading">
    <div class="loadbox">
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:center">
        <div style="font-weight:800">Грузим офисный цирк…</div>
        <div id="pct" style="opacity:.9">0%</div>
      </div>
      <div class="bar"><div id="bar"></div></div>
      <div class="small" id="files"></div>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
  (() => {
    // ---------------------------
    // Asset paths (GitHub Pages safe)
    // ---------------------------
    const ASSETS = {
      chair: "./assets/player/chair.png",
      humanIdle: "./assets/player/human_idle.png",
      humanFly: "./assets/player/human_fly.png",
      beam: "./assets/office/beam.png",
      pillar: "./assets/office/pillar.png",
      desk: "./assets/office/desk.png",
      monitor: "./assets/office/monitor.png",
      glass: "./assets/office/glass.png",
    };

    // ---------------------------
    // Canvas setup
    // ---------------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    function resize(){
      canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
      canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", resize);
    resize();

    // ---------------------------
    // Loader
    // ---------------------------
    const loadingEl = document.getElementById("loading");
    const pctEl = document.getElementById("pct");
    const barEl = document.getElementById("bar");
    const filesEl = document.getElementById("files");

    const img = {};
    const keys = Object.keys(ASSETS);

    function loadImage(key, url){
      return new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Failed: " + url));
        // cache-bust in case GH Pages is sticky
        im.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    async function preload(){
      let done = 0;
      filesEl.textContent = keys.map(k => ASSETS[k]).join("   •   ");
      for (const k of keys){
        img[k] = await loadImage(k, ASSETS[k]);
        done++;
        const p = Math.round((done/keys.length)*100);
        pctEl.textContent = p + "%";
        barEl.style.width = p + "%";
      }
      loadingEl.style.display = "none";
    }

    // ---------------------------
    // Simple physics + objects
    // ---------------------------
    const G = 1600;        // gravity px/s^2
    const AIR = 0.995;     // air drag per frame factor (applied with dt)
    const RESTITUTION = 0.15;

    const world = {
      groundY: () => window.innerHeight - 18,
      // launch anchor = point where human sits (not chair base)
      anchor: { x: 170, y: window.innerHeight - 120 },
      // seated pose offsets relative to anchor
      chairPos: { x: 120, y: window.innerHeight - 170 },
      // state
      aiming: false,
      launched: false,
      pointer: { x: 0, y: 0 },
      pull: { x: 0, y: 0 },
      // projectile
      proj: null,
      // breakables
      parts: [],
      // manager slot (готово под будущую модельку)
      manager: null,
    };

    function resetWorld(){
      world.aiming = false;
      world.launched = false;
      world.proj = null;

      // rebuild layout (responsive)
      const W = window.innerWidth;
      const H = window.innerHeight;
      world.anchor.x = 190;
      world.anchor.y = H - 160;
      world.chairPos.x = 135;
      world.chairPos.y = H - 230;

      world.parts = buildOfficeLayout();
      // manager placeholder (пока выключен)
      world.manager = null;
    }

    // Hit test point inside rect
    function ptInRect(px,py,r){
      return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;
    }

    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // Build 2-level office "домик" из твоих деталей
    function buildOfficeLayout(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      // Make building bigger if wide screen
      const scale = Math.max(0.95, Math.min(1.25, W / 1400));
      const baseX = W - 520*scale;
      const baseY = H - 330*scale;

      // Helpers
      const parts = [];
      const add = (type, x,y,w,h, hp, z=0) => {
        parts.push({
          type, x,y,w,h, hp, maxHp:hp,
          vx:0, vy:0, ang:0, vang:0,
          broken:false,
          z
        });
      };

      // Floor platforms (using beam image as platforms)
      // bottom beam
      add("beam", baseX+20*scale, baseY+260*scale, 470*scale, 64*scale, 220, 1);
      // mid beam (floor 2)
      add("beam", baseX+40*scale, baseY+135*scale, 430*scale, 64*scale, 220, 1);
      // top beam (roof)
      add("beam", baseX+55*scale, baseY+20*scale, 400*scale, 64*scale, 1, 1);

      // Pillars (4)
      add("pillar", baseX+35*scale, baseY+160*scale, 80*scale, 170*scale, 320, 0);
      add("pillar", baseX+420*scale, baseY+160*scale, 80*scale, 170*scale, 320, 0);
      add("pillar", baseX+60*scale, baseY+35*scale, 80*scale, 170*scale, 320, 0);
      add("pillar", baseX+395*scale, baseY+35*scale, 80*scale, 170*scale, 320, 0);

      // Glass panel (upper)
      add("glass", baseX+140*scale, baseY+55*scale, 260*scale, 110*scale, 140, 2);

      // Desks + monitors (lower level)
      add("desk", baseX+110*scale, baseY+190*scale, 170*scale, 100*scale, 170, 2);
      add("monitor", baseX+140*scale, baseY+165*scale, 120*scale, 70*scale, 90, 3);

      add("desk", baseX+270*scale, baseY+190*scale, 170*scale, 100*scale, 170, 2);
      add("monitor", baseX+300*scale, baseY+165*scale, 120*scale, 70*scale, 90, 3);

      // Upper desks + monitors
      add("desk", baseX+145*scale, baseY+85*scale, 150*scale, 90*scale, 160, 2);
      add("monitor", baseX+165*scale, baseY+63*scale, 105*scale, 60*scale, 90, 3);

      add("desk", baseX+285*scale, baseY+85*scale, 150*scale, 90*scale, 160, 2);
      add("monitor", baseX+305*scale, baseY+63*scale, 105*scale, 60*scale, 90, 3);

      // (готово под менеджера) — место под будущий спрайт
      // world.manager = { x: baseX+95*scale, y: baseY+65*scale, w: 90*scale, h: 120*scale, hp: 250 };

      return parts;
    }

    // Damage + simple break physics
    function applyHit(part, impulse){
      if (part.broken) return;
      const dmg = Math.max(8, impulse * 0.12);
      part.hp -= dmg;
      if (part.hp <= 0){
        part.broken = true;
        // give it a little kick
        part.vx += (Math.random()*2-1) * 160;
        part.vy -= 140 + Math.random()*120;
        part.vang += (Math.random()*2-1) * 2.2;
      }
    }

    // ---------------------------
    // Launch system
    // ---------------------------
    function seatedHumanRect(){
      // Where we click (around human_idle)
      // We draw human_idle centered near anchor but offset to look seated.
      const w = 110, h = 110;
      return { x: world.anchor.x - 40, y: world.anchor.y - 80, w, h };
    }

    function startAiming(px,py){
      if (world.launched) return;
      const r = seatedHumanRect();
      if (!ptInRect(px,py,r)) return;
      world.aiming = true;
      world.pointer.x = px;
      world.pointer.y = py;
      updatePull();
    }

    function updatePull(){
      // pull vector = anchor - pointer  (ВАЖНО: именно так, чтобы тянем назад => летим вперёд)
      const maxLen = 190;
      const dx = world.anchor.x - world.pointer.x;
      const dy = world.anchor.y - world.pointer.y;
      const len = Math.hypot(dx,dy) || 1;
      const k = Math.min(1, maxLen/len);
      world.pull.x = dx * k;
      world.pull.y = dy * k;
    }

    function release(){
      if (!world.aiming) return;
      world.aiming = false;

      // Launch projectile
      const power = 8.2; // tweak
      const vx = world.pull.x * power;
      const vy = world.pull.y * power;

      // Spawn projectile at anchor (slightly forward so it doesn't instantly collide with chair)
      world.proj = {
        x: world.anchor.x + 8,
        y: world.anchor.y - 10,
        r: 28,
        vx, vy,
        alive: true
      };
      world.launched = true;
    }

    // pointer events
    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      return {x,y};
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      const p = getPos(e);
      startAiming(p.x,p.y);
    });
    canvas.addEventListener("pointermove", (e) => {
      const p = getPos(e);
      world.pointer.x = p.x;
      world.pointer.y = p.y;
      if (world.aiming) updatePull();
    });
    canvas.addEventListener("pointerup", () => release());
    canvas.addEventListener("pointercancel", () => release());

    document.getElementById("resetBtn").addEventListener("click", resetWorld);

    // ---------------------------
    // Rendering helpers
    // ---------------------------
    function drawBackground(){
      const W = window.innerWidth, H = window.innerHeight;
      const g = ctx.createRadialGradient(W*0.2,H*0.2,50, W*0.2,H*0.2, Math.max(W,H));
      g.addColorStop(0, "rgba(30,120,200,0.22)");
      g.addColorStop(0.35, "rgba(7,18,38,0.80)");
      g.addColorStop(1, "rgba(0,0,0,0.92)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // ground line
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(0, world.groundY(), W, 2);
    }

    function drawImageFit(im, x,y,w,h){
      ctx.drawImage(im, x,y,w,h);
    }

    function drawChairEmpty(){
      // chair.png only once
      const im = img.chair;
      const w = 120, h = 120;
      // we place chair base and let human_idle sit above it
      drawImageFit(im, world.chairPos.x, world.chairPos.y, w, h);
    }

    // seated human rocking forward/back like you asked (вперёд/назад)
    function drawSeatedHuman(t){
      if (world.launched) return; // when launched, seated human disappears
      const im = img.humanIdle;
      const baseX = world.chairPos.x + 22;
      const baseY = world.chairPos.y - 12;

      // rocking animation
      const rock = Math.sin(t*2.4) * 0.12; // radians
      const bob = Math.sin(t*3.2) * 2.2;

      ctx.save();
      // pivot around hips
      ctx.translate(baseX + 40, baseY + 60);
      ctx.rotate(rock);
      ctx.translate(-(baseX + 40), -(baseY + 60));
      ctx.globalAlpha = 1;
      drawImageFit(im, baseX, baseY + bob, 95, 95);
      ctx.restore();

      // update anchor roughly where we click/launch from
      world.anchor.x = baseX + 55;
      world.anchor.y = baseY + 55;
    }

    function drawAimBand(){
      if (!world.aiming) return;

      const ax = world.anchor.x;
      const ay = world.anchor.y;
      const px = ax - world.pull.x;
      const py = ay - world.pull.y;

      ctx.lineCap = "round";
      // outer glow
      ctx.strokeStyle = "rgba(120,240,255,0.20)";
      ctx.lineWidth = 10;
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(px,py); ctx.stroke();

      // core
      ctx.strokeStyle = "rgba(255,80,120,0.85)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(px,py); ctx.stroke();

      // pull circle
      ctx.fillStyle = "rgba(120,240,255,0.12)";
      ctx.strokeStyle = "rgba(120,240,255,0.8)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(px,py,18,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }

    function drawProjectile(){
      if (!world.proj) return;
      const p = world.proj;

      // flying sprite
      const im = img.humanFly;
      ctx.save();
      // rotate by velocity for fun
      const ang = Math.atan2(p.vy, p.vx);
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.translate(-p.x, -p.y);
      drawImageFit(im, p.x-42, p.y-42, 95, 95);
      ctx.restore();
    }

    function drawOffice(){
      // sort by z to layer
      const parts = [...world.parts].sort((a,b)=>a.z-b.z);
      for (const it of parts){
        const im = img[it.type];
        if (!im) continue;

        ctx.save();
        // broken pieces rotate a bit
        if (it.broken){
          ctx.translate(it.x + it.w/2, it.y + it.h/2);
          ctx.rotate(it.ang);
          ctx.translate(-(it.x + it.w/2), -(it.y + it.h/2));
          ctx.globalAlpha = 0.98;
        }
        drawImageFit(im, it.x, it.y, it.w, it.h);

        // subtle HP tint when damaged
        const hpRatio = Math.max(0, it.hp / it.maxHp);
        if (!it.broken && hpRatio < 0.55){
          ctx.fillStyle = `rgba(255,80,120,${(0.55-hpRatio)*0.18})`;
          ctx.fillRect(it.x, it.y, it.w, it.h);
        }
        ctx.restore();
      }

      // manager placeholder (готово под добавление)
      if (world.manager){
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        ctx.fillRect(world.manager.x, world.manager.y, world.manager.w, world.manager.h);
        ctx.strokeStyle = "rgba(140,220,255,0.25)";
        ctx.strokeRect(world.manager.x, world.manager.y, world.manager.w, world.manager.h);
        ctx.fillStyle = "rgba(215,246,255,0.7)";
        ctx.font = "12px system-ui";
        ctx.fillText("MANAGER SLOT", world.manager.x+8, world.manager.y+18);
      }
    }

    // ---------------------------
    // Simulation step
    // ---------------------------
    function step(dt){
      const ground = world.groundY();

      // projectile physics
      if (world.proj){
        const p = world.proj;

        p.vy += G * dt;
        // air
        const drag = Math.pow(AIR, dt*60);
        p.vx *= drag;
        p.vy *= drag;

        p.x += p.vx * dt;
        p.y += p.vy * dt;

        // ground bounce
        if (p.y + p.r > ground){
          p.y = ground - p.r;
          p.vy = -p.vy * (0.25 + RESTITUTION);
          p.vx *= 0.7;
          // stop if slow
          if (Math.abs(p.vy) < 120) p.vy = 0;
          if (Math.abs(p.vx) < 40) p.vx = 0;
        }

        // collide with office parts
        const projRect = { x: p.x - p.r, y: p.y - p.r, w: p.r*2, h: p.r*2 };
        for (const it of world.parts){
          const r = { x: it.x, y: it.y, w: it.w, h: it.h };
          if (rectsOverlap(projRect, r)){
            const impulse = Math.hypot(p.vx, p.vy);
            applyHit(it, impulse);

            // simple bounce response (push projectile out)
            // determine smallest overlap axis
            const ox = Math.min(projRect.x+projRect.w - r.x, r.x+r.w - projRect.x);
            const oy = Math.min(projRect.y+projRect.h - r.y, r.y+r.h - projRect.y);
            if (ox < oy){
              // horizontal resolve
              if (p.x < it.x + it.w/2) p.x -= ox; else p.x += ox;
              p.vx = -p.vx * (0.30 + RESTITUTION);
              p.vy *= 0.92;
            } else {
              if (p.y < it.y + it.h/2) p.y -= oy; else p.y += oy;
              p.vy = -p.vy * (0.30 + RESTITUTION);
              p.vx *= 0.92;
            }

            // give part some motion if broken
            if (it.broken){
              it.vx += p.vx * 0.02;
              it.vy += p.vy * 0.02;
            }
          }
        }
      }

      // broken parts fall
      for (const it of world.parts){
        if (!it.broken) continue;

        it.vy += G * 0.6 * dt;
        it.x += it.vx * dt;
        it.y += it.vy * dt;
        it.ang += it.vang * dt;

        // floor collision
        if (it.y + it.h > ground){
          it.y = ground - it.h;
          it.vy = -it.vy * 0.18;
          it.vx *= 0.75;
          it.vang *= 0.7;
          if (Math.abs(it.vy) < 60) it.vy = 0;
          if (Math.abs(it.vx) < 25) it.vx = 0;
        }
      }
    }

    // ---------------------------
    // Main loop
    // ---------------------------
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      step(dt);

      // draw
      drawBackground();
      drawOffice();
      drawChairEmpty();     // chair stays (empty)
      drawSeatedHuman(now/1000); // idle human (only before launch)
      drawAimBand();
      drawProjectile();

      requestAnimationFrame(loop);
    }

    // Boot
    preload()
      .then(() => {
        resetWorld();
        requestAnimationFrame(loop);
      })
      .catch(err => {
        console.error(err);
        alert("Ошибка загрузки PNG. Проверь пути в репозитории и имена файлов.\n\n" + err.message);
      });

  })();
  </script>
</body>
</html>
