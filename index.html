<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <!-- ✅ mobile + disable page zoom (we do camera zoom instead) -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Slingshot Office MVP</title>

  <style>
    :root{
      --bg:#0b0f16;
      --panel: rgba(15, 22, 35, .62);
      --stroke: rgba(255,255,255,.16);
      --text: rgba(255,255,255,.88);
      --muted: rgba(255,255,255,.65);
      --accent: #6ee7ff;
      --accent2:#a78bfa;
      --danger:#ff5577;
      --ok:#69ffb0;
      --shadow: rgba(0,0,0,.35);
      --glow: rgba(110,231,255,.22);
      --radius: 14px;
      --radius2: 18px;
      --pad: 14px;
      --pad2: 18px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, "Noto Sans", sans-serif;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 600px at 25% 20%, rgba(167,139,250,.12), transparent 45%),
                  radial-gradient(900px 500px at 75% 10%, rgba(110,231,255,.10), transparent 40%),
                  radial-gradient(900px 900px at 60% 85%, rgba(105,255,176,.08), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: var(--font);
      overflow:hidden;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Canvas full-screen */
    #wrap{
      position:fixed;
      inset:0;
      display:flex;
      align-items:stretch;
      justify-content:center;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      background: transparent;
      touch-action:none; /* we manage */
    }

    /* HUD / UI */
    .hud{
      position:fixed;
      inset:0;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:12px;
      padding: 16px;
      box-sizing:border-box;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      pointer-events:none;
    }

    .brand{
      pointer-events:none;
      display:flex;
      flex-direction:column;
      gap:6px;
      padding: 12px 14px;
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      box-shadow: 0 12px 40px var(--shadow);
      backdrop-filter: blur(10px);
      max-width: 520px;
    }

    .brand .row{
      display:flex;
      gap:10px;
      align-items:center;
    }

    .logo{
      width:36px;height:36px;border-radius:12px;
      background: radial-gradient(12px 12px at 30% 30%, rgba(255,255,255,.6), transparent 65%),
                  linear-gradient(135deg, rgba(110,231,255,.85), rgba(167,139,250,.85));
      box-shadow: 0 0 0 1px rgba(255,255,255,.10) inset, 0 14px 35px rgba(110,231,255,.12);
      flex:0 0 auto;
    }

    .brand h1{
      margin:0;
      font-size:14px;
      letter-spacing:.5px;
      font-weight:700;
      line-height:1.1;
    }

    .brand p{
      margin:0;
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }

    .btns{
      pointer-events:auto;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }

    .btn{
      cursor:pointer;
      border:none;
      border-radius: 14px;
      padding: 11px 13px;
      color:var(--text);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border:1px solid var(--stroke);
      box-shadow: 0 12px 30px rgba(0,0,0,.28);
      backdrop-filter: blur(10px);
      font-size:12px;
      font-weight:700;
      letter-spacing:.2px;
      display:flex;
      gap:8px;
      align-items:center;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .btn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.25); }
    .btn:active{ transform: translateY(0px) scale(.99); }

    .btn .dot{
      width:8px;height:8px;border-radius:50%;
      background: rgba(255,255,255,.35);
      box-shadow:0 0 0 4px rgba(255,255,255,.06);
    }

    .btn.primary{
      background: linear-gradient(135deg, rgba(110,231,255,.18), rgba(167,139,250,.16));
      border-color: rgba(110,231,255,.28);
      box-shadow: 0 18px 45px rgba(110,231,255,.10);
    }

    .btn.danger{
      background: linear-gradient(135deg, rgba(255,85,119,.16), rgba(167,139,250,.10));
      border-color: rgba(255,85,119,.28);
      box-shadow: 0 18px 45px rgba(255,85,119,.08);
    }

    .btn.small{ padding: 9px 11px; border-radius: 12px; }

    /* bottom panels */
    .bottom{
      pointer-events:none;
      margin-top:auto;
      display:flex;
      gap:12px;
      align-items:flex-end;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    .panel{
      pointer-events:auto;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.035));
      border:1px solid var(--stroke);
      border-radius: var(--radius2);
      box-shadow: 0 14px 45px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      padding: 12px 14px;
      min-width: 240px;
      max-width: 680px;
    }

    .panel h2{
      margin:0 0 8px 0;
      font-size:12px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.88);
    }

    .panel .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px 14px;
      align-items:center;
    }

    .kv{
      display:flex;
      flex-direction:column;
      gap:3px;
      min-width: 0;
    }
    .kv .k{
      font-size:11px;
      color: rgba(255,255,255,.62);
      letter-spacing:.2px;
      line-height:1.1;
    }
    .kv .v{
      font-size:12px;
      font-weight:800;
      letter-spacing:.15px;
      line-height:1.2;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .meter{
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.11);
      overflow:hidden;
      box-shadow: 0 0 0 1px rgba(0,0,0,.12) inset;
    }
    .meter > i{
      display:block;
      height:100%;
      width:40%;
      background: linear-gradient(90deg, rgba(110,231,255,.95), rgba(167,139,250,.85));
      box-shadow: 0 0 18px rgba(110,231,255,.18);
      border-radius:999px;
    }

    .hint{
      font-size:11px;
      color: rgba(255,255,255,.68);
      line-height:1.35;
      margin-top:10px;
    }
    .hint b{ color: rgba(255,255,255,.9); }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      top:16px;
      transform: translateX(-50%);
      pointer-events:none;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(15,22,35,.72);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 18px 60px rgba(0,0,0,.4);
      backdrop-filter: blur(10px);
      font-size:12px;
      font-weight:700;
      color: rgba(255,255,255,.9);
      opacity:0;
      transition: opacity .25s ease, transform .25s ease;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(2px);
    }

    /* Overlay menu */
    .menu{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      padding: 24px;
      box-sizing:border-box;
    }
    .card{
      pointer-events:auto;
      width:min(720px, 92vw);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.035));
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: 0 26px 90px rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      padding: 18px;
      position:relative;
      overflow:hidden;
    }
    .card:before{
      content:"";
      position:absolute;
      inset:-60px -60px auto auto;
      width:220px;height:220px;
      background: radial-gradient(circle at 35% 35%, rgba(110,231,255,.20), transparent 60%),
                  radial-gradient(circle at 70% 70%, rgba(167,139,250,.22), transparent 65%);
      filter: blur(2px);
      transform: rotate(18deg);
      pointer-events:none;
    }
    .card h3{
      margin:0 0 6px 0;
      font-size:14px;
      letter-spacing:.25px;
    }
    .card p{
      margin:0 0 14px 0;
      font-size:12px;
      color: rgba(255,255,255,.70);
      line-height:1.45;
    }
    .card .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }

    .kbd{
      display:inline-flex;
      gap:6px;
      align-items:center;
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.86);
      font-weight:800;
      letter-spacing:.1px;
      font-size:11px;
      font-family: var(--mono);
      box-shadow: 0 0 0 1px rgba(0,0,0,.08) inset;
    }

    .menu.hidden{ display:none; }

    /* Mobile tweaks */
    @media (max-width: 720px){
      .hud{ padding: 12px; }
      .brand{ max-width: 100%; }
      .panel{ min-width: min(320px, 92vw); }
      .panel .grid{ grid-template-columns: 1fr 1fr; }
      .btns{ justify-content:flex-start; }
    }
  </style>

  <!-- Matter.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"
          integrity="sha512-B4BfEJ2R5r2lY4dVseK5a4mAeh1a8W3jPGgTbH+/I+8DTrgOeY8f1o5UM4Wpm9gB7c2H6cEoYxGZlLZ4Qq9c8A=="
          crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
  <div id="wrap">
    <canvas id="game"></canvas>
  </div>

  <!-- HUD -->
  <div class="hud">
    <div class="topbar">
      <div class="brand">
        <div class="row">
          <div class="logo"></div>
          <div>
            <h1>Office Slingshot MVP</h1>
            <p>Перетяни рогатку, отпусти — и смотри, как офис летит по физике. Колесо мыши — зум. ПК: <span class="kbd">R</span> reset.</p>
          </div>
        </div>
      </div>

      <div class="btns">
        <button class="btn primary" id="startBtn"><span class="dot"></span> START</button>
        <button class="btn" id="resetBtn"><span class="dot"></span> RESET</button>
        <button class="btn small" id="debugBtn"><span class="dot"></span> DEBUG</button>
      </div>
    </div>

    <div class="bottom">
      <div class="panel">
        <h2>Статус</h2>
        <div class="grid">
          <div class="kv">
            <div class="k">Сила выстрела</div>
            <div class="v" id="powerTxt">—</div>
          </div>
          <div class="kv">
            <div class="k">Скорость</div>
            <div class="v" id="speedTxt">—</div>
          </div>
          <div class="kv">
            <div class="k">Разрушено</div>
            <div class="v" id="brokenTxt">0</div>
          </div>
          <div class="kv">
            <div class="k">FPS (≈)</div>
            <div class="v" id="fpsTxt">—</div>
          </div>
        </div>
        <div class="hint">
          <b>Управление:</b> перетяни и отпусти. На тач-устройствах — свайп. Колесо мыши — зум.
        </div>
      </div>

      <div class="panel" style="min-width: 280px;">
        <h2>Здоровье офиса</h2>
        <div class="meter"><i id="hpBar"></i></div>
        <div class="hint" id="hpTxt">Цель: постройку можно развалить, если попасть достаточно сильно.</div>
      </div>
    </div>
  </div>

  <!-- Menu overlay (paused) -->
  <div class="menu" id="menu">
    <div class="card">
      <h3>Готов?</h3>
      <p>
        Это шуточный MVP: рогатка + офисная конструкция на физике. Ты можешь зумить/панить “камеру”
        и сбивать блоки. Всё в одном <span class="kbd">index.html</span>.
      </p>
      <div class="row">
        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
          <span class="kbd">ЛКМ</span> тянуть
          <span class="kbd">Wheel</span> zoom
          <span class="kbd">R</span> reset
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="btn primary" id="goBtn"><span class="dot"></span> Поехали</button>
          <button class="btn danger" id="nukeBtn"><span class="dot"></span> СУПЕР-УДАР</button>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const {
    Engine, Render, Runner, World, Bodies, Body, Composite, Events,
    Mouse, MouseConstraint, Vector, Constraint, Query
  } = Matter;

  const canvas = document.getElementById("game");
  const wrap = document.getElementById("wrap");
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  const $ = (id)=>document.getElementById(id);

  const UI = {
    powerTxt: $("powerTxt"),
    speedTxt: $("speedTxt"),
    brokenTxt: $("brokenTxt"),
    fpsTxt: $("fpsTxt"),
    hpBar: $("hpBar"),
    hpTxt: $("hpTxt"),
    toast: $("toast"),
    menu: $("menu"),
    startBtn: $("startBtn"),
    resetBtn: $("resetBtn"),
    debugBtn: $("debugBtn"),
    goBtn: $("goBtn"),
    nukeBtn: $("nukeBtn"),
  };

  // --- Assets (paths must exist in your repo) ---
  // Background (full screen) + ground tile + optional chair decal etc.
  const ASSETS = {
    bg: "assets/bg.jpg",
    ground: "assets/ground.png",
    chair: "assets/chair.png",
    wood: "assets/wood.png",
    glass: "assets/glass.png",
    metal: "assets/metal.png",
    ball: "assets/ball.png",
  };

  // --- Gameplay tuning ---
  const LEVEL = {
    worldW: 2400,
    worldH: 1400,
    floorHeight: 180,       // physical ground thickness
    leftWallX: -120,
    rightWallX: 2520,
    sling: { x: 320, y: 850 },
    launchMax: 190,
  };

  const GROUND_VIS = {
    // visual thickness in "world units" (matches floorHeight feel)
    hWorld: 170,
    overlap: 30
  };

  // Camera / view
  const CAM = {
    target: { x: 0, y: 0 },
    pos: { x: 0, y: 0 },
    zoom: 1,
    zoomTarget: 1,
    minZoom: 0.55,
    maxZoom: 1.6,
    pan: { x: 0, y: 0 },
    panning: false,
    panStart: null,
    panOrigin: null,
  };

  // HUD runtime
  let DEBUG = false;
  let GAME_STARTED = false;

  // Aim helper
  const AIM = {
    enabled: true,
    samples: 22,
    step: 0.7,
  };

  // Super hit
  let SUPER = {
    ready: true,
    cd: 9000,
    last: -1,
    impulse: 0.038,
  };

  // --- Engine ---
  const engine = Engine.create();
  engine.gravity.y = 1.0;

  // --- Render ---
  const render = Render.create({
    canvas,
    engine,
    options: {
      width: 1,
      height: 1,
      wireframes: false,
      background: "transparent",
      pixelRatio: DPR,
      hasBounds: true,
    }
  });

  const runner = Runner.create();
  runner.isFixed = true;

  // Global references
  let ground, leftWall, rightWall;
  let slingAnchor, slingConstraint;
  let projectile;
  let structure = [];
  let breakable = new Set();
  let brokenCount = 0;
  let maxHp = 100;
  let hp = 100;
  let chairDecal = null;

  // Images
  const IMGS = {};
  const loadImage = (src) => new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = reject;
    img.src = src;
  });

  // Utility
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  // Fit canvas / set render size
  function resize(){
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    render.options.width = w;
    render.options.height = h;
    Render.setPixelRatio(render, DPR);

    // update bounds around camera
    updateBounds();
  }

  // Convert world->screen (with bounds)
  function worldToScreen(wx, wy){
    const b = render.bounds;
    const w = render.options.width;
    const h = render.options.height;
    return {
      x: (wx - b.min.x) / (b.max.x - b.min.x) * w,
      y: (wy - b.min.y) / (b.max.y - b.min.y) * h
    };
  }

  function worldSizeToScreen(ww, wh){
    const b = render.bounds;
    const w = render.options.width;
    const h = render.options.height;
    return {
      w: ww / (b.max.x - b.min.x) * w,
      h: wh / (b.max.y - b.min.y) * h
    };
  }

  // Update camera bounds
  function updateBounds(){
    const w = render.options.width;
    const h = render.options.height;
    const halfW = w/(CAM.zoom*2);
    const halfH = h/(CAM.zoom*2);

    const cx = CAM.pos.x + CAM.pan.x;
    const cy = CAM.pos.y + CAM.pan.y;

    render.bounds.min.x = cx - halfW;
    render.bounds.max.x = cx + halfW;
    render.bounds.min.y = cy - halfH;
    render.bounds.max.y = cy + halfH;
  }

  function setCameraTarget(x,y){
    CAM.target.x = x;
    CAM.target.y = y;
  }

  function tickCamera(){
    CAM.pos.x = lerp(CAM.pos.x, CAM.target.x, 0.08);
    CAM.pos.y = lerp(CAM.pos.y, CAM.target.y, 0.08);
    CAM.zoom = lerp(CAM.zoom, CAM.zoomTarget, 0.12);
    updateBounds();
  }

  // Setup world bodies
  function buildWorld(){
    // Clear world
    World.clear(engine.world, false);
    Engine.clear(engine);

    structure = [];
    breakable = new Set();
    brokenCount = 0;
    hp = maxHp = 100;

    // Ground physical
    ground = Bodies.rectangle(LEVEL.worldW/2, LEVEL.worldH - LEVEL.floorHeight/2,
                              LEVEL.worldW + 3000, LEVEL.floorHeight, {
      isStatic: true,
      label: "ground",
      render: { visible: false }
    });

    leftWall = Bodies.rectangle(LEVEL.leftWallX, LEVEL.worldH/2, 200, LEVEL.worldH+2000, {
      isStatic: true,
      label: "wall",
      render:{ visible:false }
    });
    rightWall = Bodies.rectangle(LEVEL.rightWallX, LEVEL.worldH/2, 200, LEVEL.worldH+2000, {
      isStatic: true,
      label: "wall",
      render:{ visible:false }
    });

    World.add(engine.world, [ground, leftWall, rightWall]);

    // Slingshot anchor
    slingAnchor = { x: LEVEL.sling.x, y: LEVEL.sling.y };
    projectile = createProjectile(slingAnchor.x, slingAnchor.y);
    slingConstraint = Constraint.create({
      pointA: slingAnchor,
      bodyB: projectile,
      stiffness: 0.04,
      damping: 0.02,
      length: 12,
      render: { visible: false }
    });

    World.add(engine.world, [projectile, slingConstraint]);

    // Build office structure
    buildOffice();

    // Camera default
    CAM.pan.x = 0; CAM.pan.y = 0;
    setCameraTarget(LEVEL.worldW/2, LEVEL.worldH/2);
    CAM.pos.x = CAM.target.x; CAM.pos.y = CAM.target.y;
    CAM.zoom = CAM.zoomTarget = 0.9;
    updateBounds();
  }

  function createProjectile(x,y){
    const r = 28;
    const body = Bodies.circle(x, y, r, {
      density: 0.006,
      restitution: 0.65,
      friction: 0.05,
      frictionAir: 0.008,
      label: "ball",
      render:{
        sprite: IMGS.imgBall ? { texture: IMGS.imgBall.src, xScale: (r*2)/IMGS.imgBall.width, yScale:(r*2)/IMGS.imgBall.height } : undefined,
        fillStyle: "#ffffff",
      }
    });
    return body;
  }

  function addBlock(x,y,w,h,mat="wood",opts={}){
    const textures = {
      wood: IMGS.imgWood,
      glass: IMGS.imgGlass,
      metal: IMGS.imgMetal
    };
    const img = textures[mat];
    const body = Bodies.rectangle(x,y,w,h,{
      density: mat==="metal"?0.008:mat==="glass"?0.005:0.006,
      restitution: mat==="glass"?0.15:0.2,
      friction: 0.6,
      frictionAir: 0.012,
      label: "block",
      render: img ? { sprite:{ texture: img.src, xScale: w/img.width, yScale: h/img.height } } : { fillStyle:"#ffffff" },
      ...opts
    });
    structure.push(body);
    if (!opts.isStatic){
      breakable.add(body);
    }
    World.add(engine.world, body);
    return body;
  }

  function buildOffice(){
    // A compact “office” stack
    const baseY = LEVEL.worldH - LEVEL.floorHeight - 10;
    const startX = 1650;

    // Base platform
    addBlock(startX, baseY - 18, 520, 26, "metal", { isStatic:false });
    addBlock(startX - 200, baseY - 18, 120, 26, "metal", { isStatic:false });
    addBlock(startX + 200, baseY - 18, 120, 26, "metal", { isStatic:false });

    // Columns
    addBlock(startX - 160, baseY - 110, 36, 170, "wood");
    addBlock(startX + 160, baseY - 110, 36, 170, "wood");
    addBlock(startX,       baseY - 110, 36, 170, "wood");

    // Mid shelf
    addBlock(startX, baseY - 210, 460, 22, "metal");
    addBlock(startX - 200, baseY - 255, 120, 18, "glass");
    addBlock(startX + 200, baseY - 255, 120, 18, "glass");

    // Top
    addBlock(startX, baseY - 320, 360, 22, "metal");
    addBlock(startX - 120, baseY - 370, 90, 18, "glass");
    addBlock(startX + 120, baseY - 370, 90, 18, "glass");

    // Extra blocks
    addBlock(startX - 260, baseY - 80, 60, 60, "wood");
    addBlock(startX + 260, baseY - 80, 60, 60, "wood");
    addBlock(startX - 260, baseY - 140, 60, 60, "glass");
    addBlock(startX + 260, baseY - 140, 60, 60, "glass");

    // Optional chair decal (just for fun)
    chairDecal = { x: startX - 280, y: baseY - 40, s: 0.34 };
  }

  // Reset
  function resetAll(IMGS){
    buildWorld();
    runner.enabled = GAME_STARTED; // respect menu
    toast("RESET", 650);
  }

  // Menu
  function showMenu(){
    UI.menu.classList.remove("hidden");
    GAME_STARTED = false;
    runner.enabled = false;
  }
  function hideMenu(){
    UI.menu.classList.add("hidden");
    GAME_STARTED = true;
    runner.enabled = true;
  }

  // Toast
  let toastT = null;
  function toast(msg, ms=900){
    UI.toast.textContent = msg;
    UI.toast.classList.add("show");
    clearTimeout(toastT);
    toastT = setTimeout(()=>UI.toast.classList.remove("show"), ms);
  }

  // --- Interactions ---
  const mouse = Mouse.create(canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse,
    constraint: {
      stiffness: 0.18,
      damping: 0.08,
      render: { visible: false }
    }
  });
  World.add(engine.world, mouseConstraint);

  // Dragging slingshot logic
  let draggingBall = false;
  let dragStart = null;

  function pointerWorld(){
    // Convert mouse position to world position using bounds
    const b = render.bounds;
    const w = render.options.width;
    const h = render.options.height;
    const mx = mouse.position.x;
    const my = mouse.position.y;
    const wx = b.min.x + (mx / w) * (b.max.x - b.min.x);
    const wy = b.min.y + (my / h) * (b.max.y - b.min.y);
    return { x: wx, y: wy };
  }

  // Camera panning with right click / two-finger or space?
  let isRightDown = false;

  window.addEventListener("contextmenu", (e)=>e.preventDefault());
  canvas.addEventListener("pointerdown", (e)=>{
    canvas.setPointerCapture(e.pointerId);
    if (e.button === 2){ // right
      isRightDown = true;
      CAM.panning = true;
      CAM.panStart = { x: e.clientX, y: e.clientY };
      CAM.panOrigin = { x: CAM.pan.x, y: CAM.pan.y };
      return;
    }

    // detect click near projectile
    const pw = pointerWorld();
    const d = Vector.magnitude(Vector.sub(pw, projectile.position));
    if (d < 64){
      draggingBall = true;
      dragStart = { ...pw };
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if (CAM.panning){
      const dx = e.clientX - CAM.panStart.x;
      const dy = e.clientY - CAM.panStart.y;
      // convert screen delta to world delta
      const b = render.bounds;
      const w = render.options.width;
      const h = render.options.height;
      const worldW = (b.max.x - b.min.x);
      const worldH = (b.max.y - b.min.y);
      CAM.pan.x = CAM.panOrigin.x - dx / w * worldW;
      CAM.pan.y = CAM.panOrigin.y - dy / h * worldH;
      updateBounds();
      return;
    }

    if (!draggingBall) return;
    const pw = pointerWorld();
    const delta = Vector.sub(pw, slingAnchor);
    const dist = Vector.magnitude(delta);
    const max = LEVEL.launchMax;
    const clamped = dist > max ? Vector.mult(Vector.normalise(delta), max) : delta;
    Body.setPosition(projectile, Vector.add(slingAnchor, clamped));
    Body.setVelocity(projectile, { x: 0, y: 0 });
  });

  canvas.addEventListener("pointerup", (e)=>{
    if (e.button === 2){
      isRightDown = false;
      CAM.panning = false;
      return;
    }

    if (!draggingBall) return;
    draggingBall = false;

    // release: remove constraint and shoot
    const delta = Vector.sub(slingAnchor, projectile.position);
    const power = Vector.magnitude(delta);
    const dir = Vector.normalise(delta);
    const force = Vector.mult(dir, power * 0.0009);
    Body.applyForce(projectile, projectile.position, force);

    UI.powerTxt.textContent = power.toFixed(0);
    toast("FIRE!", 550);
  });

  // Keyboard
  window.addEventListener("keydown", (e)=>{
    if (e.key.toLowerCase() === "r"){
      resetAll(IMGS);
    }
  });

  // Zoom (wheel)
  canvas.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.08;
    CAM.zoomTarget = clamp(CAM.zoomTarget + delta, CAM.minZoom, CAM.maxZoom);
  }, { passive:false });

  // Touch: two-finger pan/zoom
  let touches = new Map();
  let pinchStart = null;

  canvas.addEventListener("touchstart", (e)=>{
    for (const t of e.changedTouches){
      touches.set(t.identifier, { x: t.clientX, y: t.clientY });
    }
    if (touches.size === 2){
      const arr = [...touches.values()];
      const dx = arr[0].x - arr[1].x;
      const dy = arr[0].y - arr[1].y;
      pinchStart = {
        dist: Math.hypot(dx,dy),
        zoom: CAM.zoomTarget,
        pan: { x: CAM.pan.x, y: CAM.pan.y },
        mid: { x: (arr[0].x+arr[1].x)/2, y:(arr[0].y+arr[1].y)/2 }
      };
    }
  }, { passive:true });

  canvas.addEventListener("touchmove", (e)=>{
    for (const t of e.changedTouches){
      touches.set(t.identifier, { x: t.clientX, y: t.clientY });
    }
    if (touches.size === 2 && pinchStart){
      const arr = [...touches.values()];
      const dx = arr[0].x - arr[1].x;
      const dy = arr[0].y - arr[1].y;
      const dist = Math.hypot(dx,dy);
      const ratio = dist / pinchStart.dist;
      CAM.zoomTarget = clamp(pinchStart.zoom * ratio, CAM.minZoom, CAM.maxZoom);

      // pan by midpoint delta
      const mid = { x: (arr[0].x+arr[1].x)/2, y:(arr[0].y+arr[1].y)/2 };
      const mdx = mid.x - pinchStart.mid.x;
      const mdy = mid.y - pinchStart.mid.y;
      const b = render.bounds;
      const w = render.options.width;
      const h = render.options.height;
      const worldW = (b.max.x - b.min.x);
      const worldH = (b.max.y - b.min.y);
      CAM.pan.x = pinchStart.pan.x - mdx / w * worldW;
      CAM.pan.y = pinchStart.pan.y - mdy / h * worldH;
      updateBounds();
    }
  }, { passive:true });

  canvas.addEventListener("touchend", (e)=>{
    for (const t of e.changedTouches){
      touches.delete(t.identifier);
    }
    if (touches.size < 2) pinchStart = null;
  }, { passive:true });

  // --- Draw helpers ---
  function drawAimTrajectory(){
    // simple ballistic preview from current ball position opposite to sling direction
    const ctx = render.context;
    const start = projectile.position;
    const delta = Vector.sub(slingAnchor, projectile.position);
    const power = Vector.magnitude(delta);
    if (power < 10) return;

    const dir = Vector.normalise(delta);
    const v0 = Vector.mult(dir, power * 0.45);

    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(110,231,255,.35)";
    ctx.fillStyle = "rgba(255,255,255,.55)";

    ctx.beginPath();
    for (let i=0;i<AIM.samples;i++){
      const t = i * AIM.step;
      const p = {
        x: start.x + v0.x * t,
        y: start.y + v0.y * t + 0.5 * engine.gravity.y * 38 * t * t
      };
      const s = worldToScreen(p.x, p.y);
      if (i===0) ctx.moveTo(s.x, s.y);
      else ctx.lineTo(s.x, s.y);
    }
    ctx.stroke();

    // dots
    for (let i=0;i<AIM.samples;i+=3){
      const t = i * AIM.step;
      const p = {
        x: start.x + v0.x * t,
        y: start.y + v0.y * t + 0.5 * engine.gravity.y * 38 * t * t
      };
      const s = worldToScreen(p.x, p.y);
      ctx.beginPath();
      ctx.arc(s.x, s.y, 2.4, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  function drawChairDecal(IMGS){
    if (!chairDecal || !IMGS.imgChair) return;
    const ctx = render.context;
    const s = worldToScreen(chairDecal.x, chairDecal.y);
    const size = 220 * chairDecal.s;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.drawImage(IMGS.imgChair, s.x - size/2, s.y - size/2, size, size);
    ctx.restore();
  }

  function drawSuperOverlay(){
    // small cue for super ability
    const ctx = render.context;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    const x = 18;
    const y = window.innerHeight - 64;
    const w = 220;
    const h = 44;

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(15,22,35,.62)";
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, w, h, 14);
    ctx.fill();
    ctx.stroke();

    const now = performance.now();
    const elapsed = now - SUPER.last;
    const t = SUPER.ready ? 1 : clamp(elapsed / SUPER.cd, 0, 1);

    ctx.fillStyle = "rgba(255,255,255,.82)";
    ctx.font = "700 12px " + getComputedStyle(document.documentElement).getPropertyValue("--font");
    ctx.fillText("СУПЕР-УДАР", x+14, y+18);
    ctx.font = "700 11px " + getComputedStyle(document.documentElement).getPropertyValue("--font");
    ctx.fillStyle = "rgba(255,255,255,.62)";
    ctx.fillText(SUPER.ready ? "готов" : ("кд " + Math.ceil((SUPER.cd-elapsed)/1000) + "с"), x+14, y+34);

    // bar
    const bx = x+110, by = y+18, bw = 92, bh = 10;
    ctx.fillStyle = "rgba(255,255,255,.08)";
    roundRect(ctx, bx, by, bw, bh, 999);
    ctx.fill();
    ctx.fillStyle = "rgba(110,231,255,.90)";
    roundRect(ctx, bx, by, bw*t, bh, 999);
    ctx.fill();

    ctx.restore();
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawGround(IMGS){
      if (!IMGS || !IMGS.imgGround) return;

      const img = IMGS.imgGround;
      const b = render.bounds;

      // ✅ верх физического пола (ground) — чтобы визуал совпадал с физикой
      const baseY = (typeof ground !== "undefined" && ground)
        ? (ground.position.y - LEVEL.floorHeight/2)
        : (window.innerHeight - LEVEL.floorHeight);
      const topY = baseY - GROUND_VIS.overlap;
      const hWorld = GROUND_VIS.hWorld + GROUND_VIS.overlap;

      const srcY = (typeof img.__cropY === "number") ? img.__cropY : 0;
      const srcH = (typeof img.__cropH === "number") ? img.__cropH : img.height;

      // высоту задаём в world, чтобы при зуме выглядело естественно
      const scale = hWorld / srcH;
      const tileWWorld = img.width * scale;

      const xStart = Math.floor((b.min.x - tileWWorld) / tileWWorld) * tileWWorld;
      const xEnd = b.max.x + tileWWorld;

      const tileSizePx = worldSizeToScreen(tileWWorld, hWorld);
      const tileWpx = tileSizePx.w;
      const tileHpx = tileSizePx.h;

      const sY = worldToScreen(0, topY).y;

      const ctx = render.context;
      ctx.save();

      for (let x = xStart; x <= xEnd; x += tileWWorld){
        const sx = worldToScreen(x, topY).x;
        ctx.drawImage(img, 0, srcY, img.width, srcH, sx, sY, tileWpx, tileHpx);
      }

      ctx.restore();
    }

  // Damage tracking (simple)
  function updateHp(){
    let total = 0;
    for (const b of breakable){
      const v = Vector.magnitude(b.velocity);
      const av = Math.abs(b.angularVelocity);
      total += v*0.9 + av*14;
    }
    // convert to “damage”
    const dmg = clamp(total*0.05, 0, 2.0);
    hp = clamp(hp - dmg, 0, maxHp);
    UI.hpBar.style.width = (hp/maxHp*100).toFixed(1) + "%";
    UI.hpTxt.textContent = hp <= 0 ? "Офис в хлам. RESET, чтобы начать заново." : "Разрушай конструкцию попаданиями.";
  }

  // Collision => broken count
  Events.on(engine, "collisionStart", (ev)=>{
    for (const pair of ev.pairs){
      const a = pair.bodyA, b = pair.bodyB;
      // count “broken” if big impact and body is breakable
      const impact = pair.collision.depth * 120 + Vector.magnitude(pair.collision.penetration)*90;
      if (impact > 30){
        if (breakable.has(a) && !a.__broken){
          a.__broken = true; brokenCount++;
        }
        if (breakable.has(b) && !b.__broken){
          b.__broken = true; brokenCount++;
        }
      }
    }
  });

  // --- SUPER HIT ---
  function superHit(){
    const now = performance.now();
    if (!SUPER.ready) return toast("Супер ещё на кд", 850);

    SUPER.ready = false;
    SUPER.last = now;

    // impulse to all blocks
    for (const body of structure){
      if (body.isStatic) continue;
      const dir = Vector.normalise(Vector.sub(body.position, slingAnchor));
      const f = Vector.mult(dir, SUPER.impulse * body.mass);
      Body.applyForce(body, body.position, f);
    }
    toast("SUPER!", 700);

    setTimeout(()=>{ SUPER.ready = true; }, SUPER.cd);
  }

  // --- Main loop ---
  let lastT = performance.now();
  let fpsEMA = 60;

  Events.on(engine, "beforeUpdate", ()=>{
    tickCamera();
  });

  Events.on(render, "afterRender", ()=>{
        const ctx = render.context;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // ✅ Рисуем ФОН + ПОЛ “СНИЗУ”, чтобы не ломать остальной рендер
        // destination-over = рисует позади уже нарисованных тел
        ctx.globalCompositeOperation = "destination-over";
        drawGround(IMGS);
        ctx.drawImage(IMGS.imgBg, 0, 0, render.canvas.width, render.canvas.height);
        ctx.globalCompositeOperation = "source-over";

        // ---- дальше всё как было (НИЧЕГО НЕ ВЫКИНУТО) ----
        if (AIM.enabled) drawAimTrajectory();
        if (chairDecal) drawChairDecal(IMGS);
        drawSuperOverlay();

        ctx.restore();
      });

  Render.run(render);
  Runner.run(runner, engine);

  // ✅ Start paused (menu shown)
  runner.enabled = false;

  $("resetBtn").addEventListener("click", ()=>{ resetAll(IMGS); showMenu(); });
  $("debugBtn").addEventListener("click", ()=>{
    DEBUG = !DEBUG;
    toast(DEBUG ? "DEBUG: ON" : "DEBUG: OFF", 900);
    resetAll(IMGS);
    if (!GAME_STARTED) showMenu();
  });

  // Menu buttons
  UI.startBtn.addEventListener("click", ()=>hideMenu());
  UI.goBtn.addEventListener("click", ()=>hideMenu());
  UI.nukeBtn.addEventListener("click", ()=>{ hideMenu(); superHit(); });

  // Update HUD loop
  Events.on(engine, "afterUpdate", ()=>{
    const v = Vector.magnitude(projectile.velocity);
    UI.speedTxt.textContent = v.toFixed(1);
    UI.brokenTxt.textContent = brokenCount.toString();

    const now = performance.now();
    const dt = now - lastT;
    lastT = now;
    const fps = 1000 / Math.max(1, dt);
    fpsEMA = lerp(fpsEMA, fps, 0.08);
    UI.fpsTxt.textContent = fpsEMA.toFixed(0);

    updateHp();

    // keep projectile attached unless launched far enough
    if (!draggingBall && slingConstraint.bodyB){
      const dist = Vector.magnitude(Vector.sub(projectile.position, slingAnchor));
      if (dist > LEVEL.launchMax + 30){
        // detach
        slingConstraint.bodyB = null;
        setTimeout(()=>{
          // respawn after some time
          projectile = createProjectile(slingAnchor.x, slingAnchor.y);
          World.add(engine.world, projectile);
          slingConstraint.bodyB = projectile;
        }, 1400);
      }
    }

    // Auto camera follow a bit while launched
    if (!draggingBall){
      const vx = Math.abs(projectile.velocity.x);
      if (vx > 2){
        setCameraTarget(projectile.position.x + 250, projectile.position.y - 80);
      } else {
        setCameraTarget(LEVEL.worldW/2, LEVEL.worldH/2);
      }
    }
  });

  // Toggle debug draw
  Events.on(render, "beforeRender", ()=>{
    render.options.wireframes = false;
    if (DEBUG){
      // show body bounds via engine debug-ish
      render.options.showAngleIndicator = true;
      render.options.showVelocity = true;
      render.options.showDebug = true;
    } else {
      render.options.showAngleIndicator = false;
      render.options.showVelocity = false;
      render.options.showDebug = false;
    }
  });

  // Start
  async function boot(){
    resize();
    window.addEventListener("resize", resize);

    // Load images
    const [imgBg, imgGround, imgChair, imgWood, imgGlass, imgMetal, imgBall] = await Promise.all([
      loadImage(ASSETS.bg),
      loadImage(ASSETS.ground),
      loadImage(ASSETS.chair),
      loadImage(ASSETS.wood),
      loadImage(ASSETS.glass),
      loadImage(ASSETS.metal),
      loadImage(ASSETS.ball),
    ]);

    IMGS.imgBg = imgBg;
    IMGS.imgGround = imgGround;
    IMGS.imgChair = imgChair;
    IMGS.imgWood = imgWood;
    IMGS.imgGlass = imgGlass;
    IMGS.imgMetal = imgMetal;
    IMGS.imgBall = imgBall;

    // Optional: auto crop ground if it has transparency header
    IMGS.imgGround.__cropY = 0;
    IMGS.imgGround.__cropH = IMGS.imgGround.height;

    buildWorld();
    showMenu();
    toast("Assets loaded", 900);
  }

  boot().catch((e)=>{
    console.error(e);
    toast("Ошибка загрузки ассетов. Проверь пути.", 2200);
  });

})();
</script>
</body>
</html>
