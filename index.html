<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds ‚Äî Level 1</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      overflow:hidden;
      background:
        radial-gradient(circle at 18% 22%, rgba(0,140,255,.35), rgba(0,0,0,0) 55%),
        linear-gradient(120deg, #0b2b4a, #050816 62%, #03040a);
      background-image: url("assets/bg_office.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    canvas{ display:block; width:100vw; height:100vh; }

    .hud{
      position:fixed; left:14px; top:14px;
      background: rgba(8,16,28,.55);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 12px 12px;
      color:#dbe8ff;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      max-width: 360px;
    }
    .hud .row{ display:flex; align-items:center; gap:10px; }
    .pill{
      font-weight:700;
      font-size:12px;
      letter-spacing:.04em;
      padding:4px 10px;
      border-radius:999px;
      background: rgba(0,200,255,.15);
      border: 1px solid rgba(0,200,255,.25);
      color:#bff3ff;
    }
    .title{ font-weight:800; }
    .sub{ opacity:.9; font-size:12px; margin-top:6px; line-height:1.35; }
    .btn{
      margin-left:auto;
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color:#eaf2ff;
      font-weight:700;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }

    .goal{
      position:fixed; right:14px; top:14px;
      background: rgba(8,16,28,.55);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 12px 12px;
      color:#dbe8ff;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      max-width: 320px;
      font-size:12px;
      line-height:1.35;
    }
    .goal b{ font-size:13px; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="row">
      <span class="pill">LEVEL 1</span>
      <span class="title">Office Birds</span>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="sub">
      –ó–∞–∂–º–∏ –Ω–∞ —á–µ–ª–æ–≤–µ—á–∫–µ ‚Üí –ø–æ—Ç—è–Ω–∏ –Ω–∞–∑–∞–¥ ‚Üí –æ—Ç–ø—É—Å—Ç–∏.<br/>
      –ß–µ–º —Å–∏–ª—å–Ω–µ–µ –Ω–∞—Ç—è–∂–∫–∞, —Ç–µ–º –¥–∞–ª—å—à–µ –ø–æ–ª—ë—Ç.
    </div>
  </div>

  <div class="goal">
    <b>–¶–µ–ª—å</b><br/>
    –†–∞–∑–≤–∞–ª–∏ –æ—Ñ–∏—Å–Ω—ã–π –¥–æ–º–∏–∫ (2 —ç—Ç–∞–∂–∞).<br/>
    –í–Ω—É—Ç—Ä–∏ –±—É–¥–µ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä –≤ –Ω–∞—É—à–Ω–∏–∫–∞—Ö (–≥–æ—Ç–æ–≤–æ –ø–æ–¥ manager.png).
  </div>

  <canvas id="c"></canvas>

  <!-- Matter.js -->
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ---------- helpers ----------
    const asset = (rel) => {
      // –ù–∞–¥—ë–∂–Ω–æ –¥–ª—è GitHub Pages: —Å—Ç—Ä–æ–∏–º URL –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
      try { return new URL(rel, location.href).toString(); }
      catch { return rel; }
    };

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    // ---------- canvas ----------
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0); // —Ä–∏—Å—É–µ–º –≤ CSS-–ø–∏–∫—Å–µ–ª—è—Ö
    }
    window.addEventListener('resize', resize);
    resize();

    // ---------- load images ----------
    function loadImg(url){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = ()=>reject(new Error("IMG FAIL: " + url));
        img.src = url + (url.includes('?') ? '&' : '?') + 'v=' + Date.now(); // anti-cache
      });
    }

    const IMAGES = {};
    const toLoad = {
      // player
      humanIdle: asset('assets/player/human_idle.png'), // (—Ç–∞–º —É–∂–µ —Å—Ç—É–ª)
      humanFly:  asset('assets/player/human_fly.png'),
      // structure
      beam:      asset('assets/office/beam.png'),
      pillar:    asset('assets/office/pillar.png'),
      // manager (–ø–æ–∫–∞ –º–æ–∂–µ—Ç –Ω–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å)
      manager:   asset('assets/office/manager.png'),
    };

    async function preload(){
      // manager –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–º ‚Äî –Ω–µ –≤–∞–ª–∏–º –≤—Å—é –∏–≥—Ä—É
      const entries = Object.entries(toLoad);
      for (const [key,url] of entries){
        try{
          IMAGES[key] = await loadImg(url);
        }catch(e){
          if(key === 'manager'){
            IMAGES[key] = null;
          }else{
            throw e;
          }
        }
      }
    }

    // ---------- Matter ----------
    const { Engine, World, Bodies, Body, Events, Runner, Composite, Vector } = Matter;

    const engine = Engine.create();
    engine.gravity.y = 1.05;

    const world = engine.world;

    // world sizes in CSS px
    function setupWorld(){
      World.clear(world, false);
      Engine.clear(engine);

      const W = window.innerWidth;
      const H = window.innerHeight;

      // ground
      const ground = Bodies.rectangle(W/2, H + 40, W + 200, 120, {
        isStatic: true,
        friction: 0.9,
        restitution: 0.0
      });
      World.add(world, ground);

      // ---------- player ----------
      // spawn closer and bigger (–∫–∞–∫ —Ç—ã –ø—Ä–æ—Å–∏–ª)
      const playerStart = { x: Math.max(140, W*0.12), y: H*0.80 };

      const player = Bodies.circle(playerStart.x, playerStart.y, 26, {
        density: 0.0045,
        frictionAir: 0.008,
        restitution: 0.15,
        friction: 0.6
      });
      player.label = 'player';
      World.add(world, player);

      // ---------- office house (2 floors) ----------
      // –î–æ–º–∏–∫ –±–ª–∏–∂–µ –∫ –∏–≥—Ä–æ–∫—É –∏ –º–µ–Ω—å—à–µ
      const houseX = clamp(W*0.56, playerStart.x + 360, W - 380);
      const houseY = H*0.80;

      const pillarH = 260;
      const pillarW = 46;

      const floorGap = 120; // –≤—ã—Å–æ—Ç–∞ "—ç—Ç–∞–∂–∞"
      const beamLen = 360;
      const beamH = 26;

      // 2 pillar (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ, —á—Ç–æ–±—ã —Ä—É—à–∏–ª–∏—Å—å)
      const leftP  = Bodies.rectangle(houseX - beamLen/2 + 35, houseY - pillarH/2 + 10, pillarW, pillarH, {
        density: 0.0032, friction: 0.9, restitution: 0.05
      });
      leftP.label = 'pillar';

      const rightP = Bodies.rectangle(houseX + beamLen/2 - 35, houseY - pillarH/2 + 10, pillarW, pillarH, {
        density: 0.0032, friction: 0.9, restitution: 0.05
      });
      rightP.label = 'pillar';

      // 3 beam: –Ω–∏–∑/—Å–µ—Ä–µ–¥–∏–Ω–∞/–≤–µ—Ä—Ö (–≤–∏–∑—É–∞–ª—å–Ω–æ = 2 —ç—Ç–∞–∂–∞)
      const bottomBeam = Bodies.rectangle(houseX, houseY, beamLen, beamH, {
        density: 0.0026, friction: 0.9, restitution: 0.03
      });
      bottomBeam.label = 'beam';

      const midBeam = Bodies.rectangle(houseX, houseY - floorGap, beamLen, beamH, {
        density: 0.0026, friction: 0.9, restitution: 0.03
      });
      midBeam.label = 'beam';

      const topBeam = Bodies.rectangle(houseX, houseY - floorGap*2, beamLen, beamH, {
        density: 0.0026, friction: 0.9, restitution: 0.03
      });
      topBeam.label = 'beam';

      World.add(world, [leftP, rightP, bottomBeam, midBeam, topBeam]);

      // ---------- manager placeholder (center space reserved) ----------
      // –ú–µ—Å—Ç–æ –ø–æ–¥ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –≤–Ω—É—Ç—Ä–∏ "—ç—Ç–∞–∂–∞"
      // –°–µ–π—á–∞—Å: –ø—Ä–æ—Å—Ç–∞—è "–º–∏—à–µ–Ω—å" –Ω–∞ —Å—Ä–µ–¥–Ω–µ–º —É—Ä–æ–≤–Ω–µ
      const manager = Bodies.circle(houseX, houseY - floorGap - 32, 22, {
        density: 0.0012,
        restitution: 0.2,
        friction: 0.4,
        frictionAir: 0.01
      });
      manager.label = 'manager';
      World.add(world, manager);

      // ---------- slingshot / aiming ----------
      let aiming = false;
      let aimStart = null;     // —Ç–æ—á–∫–∞ –∑–∞—Ö–≤–∞—Ç–∞
      let aimNow = null;       // —Ç–µ–∫—É—â–∞—è –º—ã—à—å
      let canShoot = true;
      let flying = false;

      // —á—Ç–æ–±—ã "–Ω–µ –±—ã–ª–æ –æ–±—Ä–∞—Ç–Ω–æ–π —Ñ–∏–∑–∏–∫–∏":
      // launch velocity = (aimStart - aimNow) * power
      const MAX_PULL = 160; // px
      const POWER = 0.12;   // tweak

      function screenToWorld(e){
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        return { x, y };
      }

      function isOverPlayer(p){
        const dx = p.x - player.position.x;
        const dy = p.y - player.position.y;
        return (dx*dx + dy*dy) <= (32*32);
      }

      canvas.addEventListener('mousedown', (e)=>{
        const p = screenToWorld(e);
        if(!canShoot) return;
        if(isOverPlayer(p)){
          aiming = true;
          aimStart = { x: player.position.x, y: player.position.y };
          aimNow = { ...p };
          // –¥–µ—Ä–∂–∏–º –∏–≥—Ä–æ–∫–∞ –Ω–∞ –º–µ—Å—Ç–µ, –ø–æ–∫–∞ —Ç—è–Ω–µ–º
          Body.setVelocity(player, { x: 0, y: 0 });
          Body.setAngularVelocity(player, 0);
          Body.setPosition(player, { x: aimStart.x, y: aimStart.y });
          Body.setStatic(player, true);
        }
      });

      window.addEventListener('mousemove', (e)=>{
        if(!aiming) return;
        aimNow = screenToWorld(e);
      });

      window.addEventListener('mouseup', ()=>{
        if(!aiming) return;
        aiming = false;

        // pull vector
        const pull = { x: aimStart.x - aimNow.x, y: aimStart.y - aimNow.y };
        const len = Math.hypot(pull.x, pull.y);
        const k = (len > 0) ? Math.min(1, MAX_PULL / len) : 1;
        const pullClamped = { x: pull.x * k, y: pull.y * k };

        // launch
        Body.setStatic(player, false);
        Body.setVelocity(player, { x: pullClamped.x * POWER * 60, y: pullClamped.y * POWER * 60 });
        Body.setAngularVelocity(player, pullClamped.x * 0.002);

        flying = true;
        canShoot = false;

        // —á–µ—Ä–µ–∑ 3.5—Å –º–æ–∂–Ω–æ —Å–Ω–æ–≤–∞
        setTimeout(()=>{ canShoot = true; }, 3500);
      });

      // reset button
      document.getElementById('resetBtn').onclick = ()=>{
        setupWorld();
      };

      // damage detection (–¥–ª—è –±—É–¥—É—â–µ–≥–æ)
      let managerHit = false;
      Events.on(engine, 'collisionStart', (ev)=>{
        for(const pair of ev.pairs){
          const a = pair.bodyA, b = pair.bodyB;
          const labels = [a.label, b.label].sort().join('+');
          if(labels === 'manager+player'){
            // —É–¥–∞—Ä —Å—á–∏—Ç–∞–µ–º –ø–æ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
            const rel = Vector.magnitude(Vector.sub(a.velocity, b.velocity));
            if(rel > 6) managerHit = true;
          }
        }
      });

      // ---------- render ----------
      const state = {
        W, H, player, manager,
        get aiming(){ return aiming; },
        get aimStart(){ return aimStart; },
        get aimNow(){ return aimNow; },
        get flying(){ return flying; },
        get canShoot(){ return canShoot; },
        get managerHit(){ return managerHit; },
        houseX, houseY, floorGap, beamLen, pillarH
      };

      return state;
    }

    // draw helpers
    function drawImageCentered(img, x, y, w, h, angle=0){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.drawImage(img, -w/2, -h/2, w, h);
      ctx.restore();
    }

    function draw(){
      const W = window.innerWidth, H = window.innerHeight;
      ctx.clearRect(0,0,W,H);

      // draw bodies with sprites
      const bodies = Composite.allBodies(world);

      // structure sprites scale
      const beamScale = 1.0;
      const pillarScale = 1.0;

      for(const b of bodies){
        if(b.isStatic && b.label === 'Rectangle Body') continue;

        if(b.label === 'beam' && IMAGES.beam){
          // –ø–æ–¥–≥–æ–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –ø–æ–¥ —Ä–∞–∑–º–µ—Ä—ã —Ç–µ–ª–∞
          drawImageCentered(IMAGES.beam, b.position.x, b.position.y, b.bounds.max.x - b.bounds.min.x, b.bounds.max.y - b.bounds.min.y, b.angle);
        }else if(b.label === 'pillar' && IMAGES.pillar){
          drawImageCentered(IMAGES.pillar, b.position.x, b.position.y, b.bounds.max.x - b.bounds.min.x, b.bounds.max.y - b.bounds.min.y, b.angle);
        }else if(b.label === 'manager'){
          if(IMAGES.manager){
            const ww = 120; const hh = 120;
            drawImageCentered(IMAGES.manager, b.position.x, b.position.y, ww, hh, b.angle);
          }else{
            // placeholder
            ctx.save();
            ctx.translate(b.position.x, b.position.y);
            ctx.rotate(b.angle);
            ctx.fillStyle = 'rgba(255,255,255,.9)';
            ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(0,180,255,.9)';
            ctx.beginPath(); ctx.arc(10,-3,6,0,Math.PI*2); ctx.fill();
            ctx.restore();
          }
        }else if(b.label === 'player'){
          // player sprite
          const aimingNow = current?.aiming;
          const flyingNow = current?.flying;

          const img = (flyingNow ? IMAGES.humanFly : IMAGES.humanIdle);
          if(img){
            // BIGGER
            const scale = flyingNow ? 0.55 : 0.62;
            const ww = img.width * scale;
            const hh = img.height * scale;

            // rocking while aiming (–≤–ø–µ—Ä—ë–¥/–Ω–∞–∑–∞–¥)
            let extraAngle = 0;
            if(aimingNow && current?.aimStart && current?.aimNow){
              const pullX = current.aimStart.x - current.aimNow.x;
              const pullY = current.aimStart.y - current.aimNow.y;
              const pullLen = Math.hypot(pullX, pullY);
              const a = clamp(pullLen / 160, 0, 1);
              extraAngle = Math.sin(perfT*0.012) * (0.18*a);
            }else{
              // –ª—ë–≥–∫–æ–µ idle –∫–∞—á–∞–Ω–∏–µ
              extraAngle = Math.sin(perfT*0.006) * 0.03;
            }

            drawImageCentered(img, b.position.x, b.position.y, ww, hh, extraAngle);
          }else{
            // fallback circle
            ctx.fillStyle="#fff";
            ctx.beginPath(); ctx.arc(b.position.x,b.position.y,26,0,Math.PI*2); ctx.fill();
          }
        }
      }

      // slingshot line / aim preview
      if(current?.aiming && current?.aimStart && current?.aimNow){
        const s = current.aimStart;
        const n = current.aimNow;

        // pull = s - n
        const pull = { x: s.x - n.x, y: s.y - n.y };
        const len = Math.hypot(pull.x, pull.y);
        const k = (len > 0) ? Math.min(1, 160 / len) : 1;
        const cl = { x: pull.x * k, y: pull.y * k };

        // –ª–∏–Ω–∏—è
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'rgba(255,90,90,.85)';
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x - cl.x, s.y - cl.y);
        ctx.stroke();

        // —Ç–æ—á–∫–∞
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.beginPath();
        ctx.arc(s.x - cl.x, s.y - cl.y, 7, 0, Math.PI*2);
        ctx.fill();
      }

      // manager hit text
      if(current?.managerHit){
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,.92)';
        ctx.font = '800 34px system-ui, -apple-system, Segoe UI, Roboto';
        ctx.fillText('üí• –ú–µ–Ω–µ–¥–∂–µ—Ä –≤—ã–±–∏—Ç!', 18, H - 22);
        ctx.restore();
      }
    }

    // ---------- main ----------
    let current = null;
    let perfT = 0;

    (async ()=>{
      await preload();

      current = setupWorld();

      const runner = Runner.create();
      Runner.run(runner, engine);

      function tick(t){
        perfT = t || 0;
        draw();
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })().catch(err=>{
      console.error(err);
      alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—Å—Å–µ—Ç–æ–≤: ' + err.message + '\n\n–ü—Ä–æ–≤–µ—Ä—å –ø—É—Ç–∏ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏.');
    });
  </script>
</body>
</html>
