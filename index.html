<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — Level 1</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body{
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(circle at 18% 22%, rgba(0,140,255,.35), rgba(0,0,0,0) 55%),
        linear-gradient(120deg, #0b2b4a, #050816 62%, #03040a);
      background-image: url("assets/bg_office.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }
    canvas{ display:block; width:100vw; height:100vh; }

    .hud{
      position:fixed; left:14px; top:14px;
      background: rgba(8,16,28,.55);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 12px 12px;
      color:#dbe8ff;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      max-width: 360px;
      z-index: 5;
      user-select: none;
    }
    .hud .row{ display:flex; align-items:center; gap:10px; }
    .pill{
      font-weight:700;
      font-size:12px;
      letter-spacing:.04em;
      padding:4px 10px;
      border-radius:999px;
      background: rgba(0,200,255,.15);
      border: 1px solid rgba(0,200,255,.25);
      color:#bff3ff;
    }
    .title{ font-weight:800; }
    .sub{ opacity:.9; font-size:12px; margin-top:6px; line-height:1.35; }
    .btn{
      margin-left:auto;
      cursor:pointer;
      padding:6px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color:#eaf2ff;
      font-weight:700;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }

    .goal{
      position:fixed; right:14px; top:14px;
      background: rgba(8,16,28,.55);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 12px 12px;
      color:#dbe8ff;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      max-width: 320px;
      font-size:12px;
      line-height:1.35;
      z-index: 5;
      user-select: none;
    }
    .goal b{ font-size:13px; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="row">
      <span class="pill">LEVEL 1</span>
      <span class="title">Office Birds</span>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="sub">
      Зажми на человечке → потяни назад → отпусти.<br/>
      Чем сильнее натяжка, тем дальше полёт.
    </div>
  </div>

  <div class="goal">
    <b>Цель</b><br/>
    Развали домик из балок/стоек (2 этажа).<br/>
    Внутри будет менеджер в наушниках (<code>assets/office/manager.png</code>).
  </div>

  <canvas id="c"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
  <script>
    // ---------- helpers ----------
    const asset = (rel) => {
      try { return new URL(rel, location.href).toString(); }
      catch { return rel; }
    };
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    // ---------- canvas ----------
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resize);
    resize();

    // ---------- load images ----------
    function loadImg(url){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = ()=>reject(new Error("IMG FAIL: " + url));
        img.src = url + (url.includes('?') ? '&' : '?') + 'v=' + Date.now();
      });
    }

    const IMAGES = {};
    const toLoad = {
      humanIdle: asset('assets/player/human_idle.png'), // да, там стул внутри — пока ок
      humanFly:  asset('assets/player/human_fly.png'),
      beam:      asset('assets/office/beam.png'),
      pillar:    asset('assets/office/pillar.png'),
      manager:   asset('assets/office/manager.png'),
    };

    async function preload(){
      const entries = Object.entries(toLoad);
      for (const [key,url] of entries){
        try{
          IMAGES[key] = await loadImg(url);
        }catch(e){
          if(key === 'manager'){
            IMAGES[key] = null; // менеджера можно дорисовать позже
          }else{
            throw e;
          }
        }
      }
    }

    // ---------- Matter ----------
    const { Engine, World, Bodies, Body, Events, Runner, Composite, Vector } = Matter;

    const engine = Engine.create();
    engine.gravity.y = 1.05;
    const world = engine.world;

    // ---------- rendering helpers ----------
    function drawImageCentered(img, x, y, w, h, angle=0){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.drawImage(img, -w/2, -h/2, w, h);
      ctx.restore();
    }

    // ---------- globals for input ----------
    let current = null;
    let perfT = 0;

    // pointer state
    let aiming = false;
    let aimStart = null;
    let aimNow = null;
    let canShoot = true;
    let flying = false;

    // tuning
    const MAX_PULL = 170;
    const POWER = 0.12;

    // player sprite scales
    const IDLE_SCALE = 0.62;
    const FLY_SCALE  = 0.55;

    function getPointerPos(ev){
      const rect = canvas.getBoundingClientRect();
      const x = (ev.clientX ?? (ev.touches && ev.touches[0]?.clientX) ?? 0) - rect.left;
      const y = (ev.clientY ?? (ev.touches && ev.touches[0]?.clientY) ?? 0) - rect.top;
      return { x, y };
    }

    // ВАЖНО: хитбокс по размеру СПРАЙТА (а не по маленькому кружку)
    function isOverPlayer(point, playerBody){
      const img = IMAGES.humanIdle;
      if(!img) {
        const dx = point.x - playerBody.position.x;
        const dy = point.y - playerBody.position.y;
        return (dx*dx + dy*dy) <= (60*60);
      }
      const w = img.width * IDLE_SCALE;
      const h = img.height * IDLE_SCALE;

      // чуть расширим, чтобы было удобно хватать
      const pad = 18;

      const left = playerBody.position.x - w/2 - pad;
      const right = playerBody.position.x + w/2 + pad;
      const top = playerBody.position.y - h/2 - pad;
      const bottom = playerBody.position.y + h/2 + pad;

      return (point.x >= left && point.x <= right && point.y >= top && point.y <= bottom);
    }

    function setupWorld(){
      World.clear(world, false);
      Engine.clear(engine);

      const W = window.innerWidth;
      const H = window.innerHeight;

      // ground
      World.add(world, Bodies.rectangle(W/2, H + 40, W + 200, 120, {
        isStatic: true, friction: 0.9, restitution: 0.0
      }));

      // player (чуть крупнее физ.тело, чтобы всё было стабильнее)
      const playerStart = { x: Math.max(160, W*0.12), y: H*0.80 };
      const player = Bodies.circle(playerStart.x, playerStart.y, 34, {
        density: 0.0045,
        frictionAir: 0.008,
        restitution: 0.15,
        friction: 0.6
      });
      player.label = 'player';
      World.add(world, player);

      // домик: 2 pillar + 3 beam (низ/середина/верх)
      const houseX = clamp(W*0.58, playerStart.x + 360, W - 340);
      const houseY = H*0.80;

      const pillarH = 220;
      const pillarW = 40;

      const floorGap = 96;
      const beamLen = 310;
      const beamH = 22;

      const leftP  = Bodies.rectangle(houseX - beamLen/2 + 30, houseY - pillarH/2 + 8, pillarW, pillarH,
        { density: 0.0032, friction: 0.9, restitution: 0.05 }
      );
      leftP.label = 'pillar';

      const rightP = Bodies.rectangle(houseX + beamLen/2 - 30, houseY - pillarH/2 + 8, pillarW, pillarH,
        { density: 0.0032, friction: 0.9, restitution: 0.05 }
      );
      rightP.label = 'pillar';

      const bottomBeam = Bodies.rectangle(houseX, houseY, beamLen, beamH,
        { density: 0.0026, friction: 0.9, restitution: 0.03 }
      );
      bottomBeam.label = 'beam';

      const midBeam = Bodies.rectangle(houseX, houseY - floorGap, beamLen, beamH,
        { density: 0.0026, friction: 0.9, restitution: 0.03 }
      );
      midBeam.label = 'beam';

      const topBeam = Bodies.rectangle(houseX, houseY - floorGap*2, beamLen, beamH,
        { density: 0.0026, friction: 0.9, restitution: 0.03 }
      );
      topBeam.label = 'beam';

      World.add(world, [leftP, rightP, bottomBeam, midBeam, topBeam]);

      // менеджер внутри (место зарезервировано)
      const manager = Bodies.circle(houseX, houseY - floorGap - 28, 22, {
        density: 0.0012, restitution: 0.2, friction: 0.4, frictionAir: 0.01
      });
      manager.label = 'manager';
      World.add(world, manager);

      // reset button
      document.getElementById('resetBtn').onclick = () => setupWorld();

      // collisions (позже можно расширить на "ломание")
      let managerHit = false;
      Events.off(engine, 'collisionStart'); // чтобы не копились хэндлеры при reset
      Events.on(engine, 'collisionStart', (ev)=>{
        for(const pair of ev.pairs){
          const a = pair.bodyA, b = pair.bodyB;
          const labels = [a.label, b.label].sort().join('+');
          if(labels === 'manager+player'){
            const rel = Vector.magnitude(Vector.sub(a.velocity, b.velocity));
            if(rel > 6) managerHit = true;
          }
        }
      });

      current = { W, H, player, manager, managerHit };
    }

    // ---------- input (Pointer Events) ----------
    canvas.addEventListener('pointerdown', (e)=>{
      if(!current) return;
      if(!canShoot) return;

      canvas.setPointerCapture(e.pointerId);

      const p = getPointerPos(e);
      if(isOverPlayer(p, current.player)){
        aiming = true;
        flying = false;

        aimStart = { x: current.player.position.x, y: current.player.position.y };
        aimNow = { ...p };

        Body.setVelocity(current.player, { x: 0, y: 0 });
        Body.setAngularVelocity(current.player, 0);
        Body.setPosition(current.player, { x: aimStart.x, y: aimStart.y });
        Body.setStatic(current.player, true);
      }
    });

    canvas.addEventListener('pointermove', (e)=>{
      if(!aiming) return;
      aimNow = getPointerPos(e);
    });

    function releaseShot(){
      if(!aiming || !current) return;
      aiming = false;

      const pull = { x: aimStart.x - aimNow.x, y: aimStart.y - aimNow.y };
      const len = Math.hypot(pull.x, pull.y);
      const k = (len > 0) ? Math.min(1, MAX_PULL / len) : 1;
      const pullClamped = { x: pull.x * k, y: pull.y * k };

      Body.setStatic(current.player, false);
      Body.setVelocity(current.player, {
        x: pullClamped.x * POWER * 60,
        y: pullClamped.y * POWER * 60
      });
      Body.setAngularVelocity(current.player, pullClamped.x * 0.002);

      flying = true;
      canShoot = false;
      setTimeout(()=>{ canShoot = true; }, 3500);
    }

    canvas.addEventListener('pointerup', releaseShot);
    canvas.addEventListener('pointercancel', releaseShot);

    // ---------- draw ----------
    function draw(){
      const W = window.innerWidth, H = window.innerHeight;
      ctx.clearRect(0,0,W,H);

      const bodies = Composite.allBodies(world);

      for(const b of bodies){
        if(b.label === 'beam' && IMAGES.beam){
          drawImageCentered(IMAGES.beam, b.position.x, b.position.y,
            b.bounds.max.x - b.bounds.min.x,
            b.bounds.max.y - b.bounds.min.y,
            b.angle
          );
        }else if(b.label === 'pillar' && IMAGES.pillar){
          drawImageCentered(IMAGES.pillar, b.position.x, b.position.y,
            b.bounds.max.x - b.bounds.min.x,
            b.bounds.max.y - b.bounds.min.y,
            b.angle
          );
        }else if(b.label === 'manager'){
          if(IMAGES.manager){
            drawImageCentered(IMAGES.manager, b.position.x, b.position.y, 130, 130, b.angle);
          }else{
            ctx.save();
            ctx.translate(b.position.x, b.position.y);
            ctx.rotate(b.angle);
            ctx.fillStyle = 'rgba(255,255,255,.9)';
            ctx.beginPath(); ctx.arc(0,0,22,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = 'rgba(0,180,255,.9)';
            ctx.beginPath(); ctx.arc(10,-3,6,0,Math.PI*2); ctx.fill();
            ctx.restore();
          }
        }else if(b.label === 'player'){
          const img = (flying ? IMAGES.humanFly : IMAGES.humanIdle);
          if(img){
            const scale = flying ? FLY_SCALE : IDLE_SCALE;
            const ww = img.width * scale;
            const hh = img.height * scale;

            // качание вперёд/назад
            let extraAngle = 0;
            if(aiming && aimStart && aimNow){
              const pullX = aimStart.x - aimNow.x;
              const pullY = aimStart.y - aimNow.y;
              const pullLen = Math.hypot(pullX, pullY);
              const a = clamp(pullLen / MAX_PULL, 0, 1);
              extraAngle = Math.sin(perfT*0.012) * (0.18*a);
            }else{
              extraAngle = Math.sin(perfT*0.006) * 0.03;
            }
            drawImageCentered(img, b.position.x, b.position.y, ww, hh, extraAngle);
          }else{
            ctx.fillStyle="#fff";
            ctx.beginPath(); ctx.arc(b.position.x,b.position.y,34,0,Math.PI*2); ctx.fill();
          }
        }
      }

      // линия натяжки
      if(aiming && aimStart && aimNow){
        const s = aimStart;
        const n = aimNow;

        const pull = { x: s.x - n.x, y: s.y - n.y };
        const len = Math.hypot(pull.x, pull.y);
        const k = (len > 0) ? Math.min(1, MAX_PULL / len) : 1;
        const cl = { x: pull.x * k, y: pull.y * k };

        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'rgba(255,90,90,.85)';
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x - cl.x, s.y - cl.y);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.beginPath();
        ctx.arc(s.x - cl.x, s.y - cl.y, 7, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // ---------- main ----------
    (async ()=>{
      await preload();

      setupWorld();

      const runner = Runner.create();
      Runner.run(runner, engine);

      function tick(t){
        perfT = t || 0;
        draw();
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })().catch(err=>{
      console.error(err);
      alert('Ошибка загрузки ассетов: ' + err.message + '\n\nПроверь пути в репозитории.');
    });
  </script>
</body>
</html>
