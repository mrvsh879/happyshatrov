<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — Level 1</title>
  <style>
    html,body{height:100%;margin:0;background:#050914;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #ui {
      position:fixed; left:14px; top:12px; z-index:10; color:#d7f6ff;
      display:flex; gap:10px; align-items:flex-start;
    }
    .panel{
      background:rgba(20,28,40,.62);
      border:1px solid rgba(140,220,255,.18);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      border-radius:12px; padding:10px 12px; backdrop-filter: blur(8px);
      max-width:520px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      font-size:12px; font-weight:700; letter-spacing:.3px;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(140,220,255,.25);
      background:rgba(0,0,0,.18)
    }
    .title{font-weight:800;margin:2px 0 6px 0;font-size:14px}
    .hint{opacity:.92;font-size:12px;line-height:1.25}
    button{
      cursor:pointer; border-radius:10px; border:1px solid rgba(140,220,255,.25);
      background:rgba(255,255,255,.06); color:#d7f6ff;
      padding:8px 12px; font-weight:700;
    }
    button:hover{background:rgba(255,255,255,.10)}
    #goal{
      position:fixed; right:14px; top:12px; z-index:10; color:#d7f6ff;
      width:360px;
    }

    #loading {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(1200px 700px at 20% 20%, rgba(0,140,255,.25), rgba(0,0,0,.65));
      z-index:20; color:#d7f6ff;
    }
    .loadbox{
      width:min(560px,92vw);
      background:rgba(10,16,26,.72);
      border:1px solid rgba(140,220,255,.18);
      border-radius:14px;
      padding:14px 16px;
      box-shadow:0 18px 45px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .bar{height:10px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:10px}
    .bar > div{height:100%;width:0%;background:linear-gradient(90deg,#7efcff,#5aa8ff)}
    .small{font-size:12px;opacity:.9;margin-top:8px;line-height:1.25}
    canvas{display:block;width:100vw;height:100vh}
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div class="badge">LEVEL 1</div>
      <div class="title">Office Birds</div>
      <div class="hint">
        Зажми на <b>человечке</b> → потяни <b>назад</b> → отпусти.<br>
        Чем сильнее натяжка, тем дальше полёт.
      </div>
    </div>
    <button id="resetBtn">Reset</button>
  </div>

  <div id="goal" class="panel">
    <div class="title">Цель</div>
    <div class="hint">
      Развали домик: <b>2 pillar</b> + <b>3 beam</b> (2 этажа).<br>
      <b>Менеджер</b> появится в верхнем этаже, когда добавим PNG.
    </div>
  </div>

  <div id="loading">
    <div class="loadbox">
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:center">
        <div style="font-weight:800">Грузим офисный цирк…</div>
        <div id="pct" style="opacity:.9">0%</div>
      </div>
      <div class="bar"><div id="bar"></div></div>
      <div class="small" id="files"></div>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
  (() => {
    // ===========================
    // Assets
    // ===========================
    const ASSETS_REQUIRED = {
      humanIdle: "./assets/player/human_idle.png",
      humanFly:  "./assets/player/human_fly.png",
      beam:      "./assets/office/beam.png",
      pillar:    "./assets/office/pillar.png"
    };

    // менеджер будет тут (прозрачный PNG)
    const ASSETS_OPTIONAL = {
      manager: "./assets/manager/manager.png"
    };

    // ===========================
    // Canvas
    // ===========================
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    function resize(){
      canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
      canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", () => { resize(); resetWorld(); });
    resize();

    // ===========================
    // Loader UI
    // ===========================
    const loadingEl = document.getElementById("loading");
    const pctEl = document.getElementById("pct");
    const barEl = document.getElementById("bar");
    const filesEl = document.getElementById("files");
    const img = {};

    function loadImage(url){
      return new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Failed: " + url));
        im.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    async function preload(){
      const reqKeys = Object.keys(ASSETS_REQUIRED);
      const optKeys = Object.keys(ASSETS_OPTIONAL);

      filesEl.textContent = [
        ...reqKeys.map(k => ASSETS_REQUIRED[k]),
        ...optKeys.map(k => ASSETS_OPTIONAL[k] + " (optional)")
      ].join("   •   ");

      let done = 0;
      const total = reqKeys.length + optKeys.length;

      for (const k of reqKeys){
        img[k] = await loadImage(ASSETS_REQUIRED[k]);
        done++;
        const p = Math.round((done/total)*100);
        pctEl.textContent = p + "%";
        barEl.style.width = p + "%";
      }

      for (const k of optKeys){
        try { img[k] = await loadImage(ASSETS_OPTIONAL[k]); }
        catch { img[k] = null; }
        done++;
        const p = Math.round((done/total)*100);
        pctEl.textContent = p + "%";
        barEl.style.width = p + "%";
      }

      loadingEl.style.display = "none";
    }

    // ===========================
    // Physics
    // ===========================
    const G = 1700;
    const AIR = 0.994;
    const RESTITUTION = 0.16;

    const world = {
      groundY: () => window.innerHeight - 18,

      playerX: 0,
      playerY: 0,
      anchor: { x: 0, y: 0 },

      aiming: false,
      launched: false,
      pointer: { x: 0, y: 0 },
      pull: { x: 0, y: 0 },

      proj: null,
      parts: [],

      managerSlot: null,
      showManager: true
    };

    function ptInRect(px,py,r){
      return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;
    }
    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // ===========================
    // Office background (building + windows)
    // ===========================
    function drawOfficeBackground(t){
      const W = window.innerWidth, H = window.innerHeight;

      // base sky
      const g = ctx.createRadialGradient(W*0.22,H*0.25,60, W*0.22,H*0.25, Math.max(W,H));
      g.addColorStop(0, "rgba(40,150,255,0.22)");
      g.addColorStop(0.35, "rgba(8,22,44,0.88)");
      g.addColorStop(1, "rgba(0,0,0,0.94)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // distant building silhouettes
      const base = H * 0.78;
      ctx.fillStyle = "rgba(0,0,0,0.35)";
      for (let i=0;i<6;i++){
        const bw = 220 + i*70;
        const bh = 220 + (i%3)*110;
        const x = (i*260 - ((t*12)%260)) - 120;
        ctx.fillRect(x, base - bh, bw, bh);
      }

      // main “office wall” with subtle window grid on right half
      const wallX = W*0.48;
      const wallW = W*0.58;
      ctx.fillStyle = "rgba(10,18,28,0.45)";
      ctx.fillRect(wallX, 0, wallW, H);

      // windows
      const cell = 46;
      const padX = wallX + 26;
      const padY = 30;
      const cols = Math.floor((wallW - 60) / cell);
      const rows = Math.floor((H - 90) / cell);

      const flicker = (Math.sin(t*0.8)*0.5+0.5);
      for (let r=0;r<rows;r++){
        for (let c=0;c<cols;c++){
          const x = padX + c*cell + ((t*8)%cell)*0.08; // micro parallax
          const y = padY + r*cell;
          const on = ((r*17 + c*23) % 11) < (4 + (flicker*2));
          ctx.fillStyle = on ? "rgba(120,210,255,0.10)" : "rgba(255,255,255,0.03)";
          ctx.fillRect(x, y, cell-14, cell-18);
        }
      }

      // ground line
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(0, world.groundY(), W, 2);
    }

    // ===========================
    // Building (smaller now)
    // ===========================
    function buildOfficeLayout(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      // было крупнее — теперь меньше/компактнее
      const scale = Math.max(0.85, Math.min(1.08, W / 1400));

      const BW = 560 * scale; // ширина домика
      const BH = 410 * scale; // высота домика

      const GAP = Math.max(70, Math.min(110, W * 0.06)); // ближе к игроку

      const baseY = H - BH - 52;
      const baseX = Math.min(W - BW - 24, world.playerX + (290 * scale) + GAP);

      const parts = [];
      const add = (type, x,y,w,h, hp, z=0) => {
        parts.push({
          type, x,y,w,h, hp, maxHp:hp,
          vx:0, vy:0, ang:0, vang:0,
          broken:false, z
        });
      };

      const pillarW = 110 * scale;
      const pillarH = BH * 0.90;
      const beamH   = 72 * scale;

      const leftPillarX  = baseX + 16*scale;
      const rightPillarX = baseX + BW - pillarW - 16*scale;
      const pillarY      = baseY + (BH - pillarH);

      const over = 18 * scale; // перекрытие балкой стойки
      const beamX = leftPillarX - over;
      const beamW = (rightPillarX + pillarW + over) - beamX;

      const yBottom = baseY + BH - beamH - 10*scale;
      const yMid    = baseY + (BH * 0.55) - (beamH * 0.50);
      const yTop    = baseY + 10*scale;

      add("pillar", leftPillarX,  pillarY, pillarW, pillarH, 420, 0);
      add("pillar", rightPillarX, pillarY, pillarW, pillarH, 420, 0);

      add("beam", beamX, yBottom, beamW, beamH, 320, 1);
      add("beam", beamX, yMid,    beamW, beamH, 320, 1);
      add("beam", beamX, yTop,    beamW, beamH, 320, 1);

      // место под менеджера (верхний этаж, центр) — широкое
      const innerLeft  = leftPillarX + pillarW * 0.55;
      const innerRight = rightPillarX - pillarW * 0.20;
      const innerW = innerRight - innerLeft;

      world.managerSlot = {
        x: innerLeft + innerW * 0.28,
        y: yTop + beamH * 0.62,
        w: innerW * 0.44,
        h: (yMid - yTop) * 0.78
      };

      return parts;
    }

    // ===========================
    // Damage / break
    // ===========================
    function applyHit(part, impulse){
      if (part.broken) return;
      const dmg = Math.max(10, impulse * 0.14);
      part.hp -= dmg;

      if (part.hp <= 0){
        part.broken = true;
        part.vx += (Math.random()*2-1) * 220;
        part.vy -= 190 + Math.random()*120;
        part.vang += (Math.random()*2-1) * 2.7;
      }
    }

    // ===========================
    // Player
    // ===========================
    const PLAYER_SCALE = 1.75;

    function seatedRect(){
      const w = 140 * PLAYER_SCALE;
      const h = 140 * PLAYER_SCALE;
      return { x: world.playerX, y: world.playerY, w, h };
    }

    function resetWorld(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      world.aiming = false;
      world.launched = false;
      world.proj = null;

      world.playerX = Math.max(34, Math.min(210, W * 0.08));
      world.playerY = H - (182 * PLAYER_SCALE) - 46;

      world.parts = buildOfficeLayout();
    }

    // ===========================
    // Slingshot
    // ===========================
    function startAiming(px,py){
      if (world.launched) return;
      const r = seatedRect();
      if (!ptInRect(px,py,r)) return;
      world.aiming = true;
      world.pointer.x = px;
      world.pointer.y = py;
      updatePull();
    }

    function updatePull(){
      const maxLen = 220;
      const dx = world.anchor.x - world.pointer.x;
      const dy = world.anchor.y - world.pointer.y;
      const len = Math.hypot(dx,dy) || 1;
      const k = Math.min(1, maxLen/len);
      world.pull.x = dx * k;
      world.pull.y = dy * k;
    }

    function release(){
      if (!world.aiming) return;
      world.aiming = false;

      const power = 8.6;
      const vx = world.pull.x * power;
      const vy = world.pull.y * power;

      world.proj = {
        x: world.anchor.x + 10,
        y: world.anchor.y - 10,
        r: 34 * PLAYER_SCALE,
        vx, vy,
        alive: true
      };
      world.launched = true;
    }

    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      const p = getPos(e);
      startAiming(p.x,p.y);
    });
    canvas.addEventListener("pointermove", (e) => {
      const p = getPos(e);
      world.pointer.x = p.x;
      world.pointer.y = p.y;
      if (world.aiming) updatePull();
    });
    canvas.addEventListener("pointerup", () => release());
    canvas.addEventListener("pointercancel", () => release());

    document.getElementById("resetBtn").addEventListener("click", resetWorld);

    // ===========================
    // Draw helpers
    // ===========================
    function drawImageFit(im, x,y,w,h){ ctx.drawImage(im, x,y,w,h); }

    function drawOffice(){
      const parts = [...world.parts].sort((a,b)=>a.z-b.z);
      for (const it of parts){
        const im = img[it.type];
        if (!im) continue;

        ctx.save();
        if (it.broken){
          ctx.translate(it.x + it.w/2, it.y + it.h/2);
          ctx.rotate(it.ang);
          ctx.translate(-(it.x + it.w/2), -(it.y + it.h/2));
        }
        drawImageFit(im, it.x, it.y, it.w, it.h);

        const hpRatio = Math.max(0, it.hp / it.maxHp);
        if (!it.broken && hpRatio < 0.55){
          ctx.fillStyle = `rgba(255,80,120,${(0.55-hpRatio)*0.18})`;
          ctx.fillRect(it.x, it.y, it.w, it.h);
        }
        ctx.restore();
      }

      // менеджер (появится, когда положишь PNG)
      if (world.showManager && world.managerSlot && img.manager){
        const s = world.managerSlot;
        drawImageFit(img.manager, s.x, s.y, s.w, s.h);
      } else if (world.managerSlot) {
        // тонкий placeholder-контур, чтобы видно было место
        const s = world.managerSlot;
        ctx.save();
        ctx.strokeStyle = "rgba(120,210,255,0.18)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6,6]);
        ctx.strokeRect(s.x, s.y, s.w, s.h);
        ctx.restore();
      }
    }

    function drawSeatedHuman(t){
      if (world.launched) return;

      const im = img.humanIdle;
      const w = 150 * PLAYER_SCALE;
      const h = 150 * PLAYER_SCALE;

      const x = world.playerX;
      const y = world.playerY;

      // качание вперед/назад
      const rock = Math.sin(t*2.2) * 0.14;
      const bob  = Math.sin(t*3.1) * 2.4;

      ctx.save();
      ctx.translate(x + w*0.45, y + h*0.80);
      ctx.rotate(rock);
      ctx.translate(-(x + w*0.45), -(y + h*0.80));
      drawImageFit(im, x, y + bob, w, h);
      ctx.restore();

      world.anchor.x = x + w*0.62;
      world.anchor.y = y + h*0.50;
    }

    function drawAimBand(){
      if (!world.aiming) return;

      const ax = world.anchor.x;
      const ay = world.anchor.y;
      const px = ax - world.pull.x;
      const py = ay - world.pull.y;

      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(120,240,255,0.20)";
      ctx.lineWidth = 12;
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(px,py); ctx.stroke();

      ctx.strokeStyle = "rgba(255,80,120,0.88)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(px,py); ctx.stroke();

      ctx.fillStyle = "rgba(120,240,255,0.12)";
      ctx.strokeStyle = "rgba(120,240,255,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(px,py,20,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }

    function drawProjectile(){
      if (!world.proj) return;
      const p = world.proj;

      const im = img.humanFly;
      const size = 160 * PLAYER_SCALE;

      ctx.save();
      const ang = Math.atan2(p.vy, p.vx);
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.translate(-p.x, -p.y);
      drawImageFit(im, p.x - size*0.50, p.y - size*0.50, size, size);
      ctx.restore();
    }

    // ===========================
    // Step
    // ===========================
    function step(dt){
      const ground = world.groundY();

      if (world.proj){
        const p = world.proj;

        p.vy += G * dt;

        const drag = Math.pow(AIR, dt*60);
        p.vx *= drag;
        p.vy *= drag;

        p.x += p.vx * dt;
        p.y += p.vy * dt;

        if (p.y + p.r > ground){
          p.y = ground - p.r;
          p.vy = -p.vy * (0.24 + RESTITUTION);
          p.vx *= 0.72;
          if (Math.abs(p.vy) < 120) p.vy = 0;
          if (Math.abs(p.vx) < 40) p.vx = 0;
        }

        const projRect = { x: p.x - p.r, y: p.y - p.r, w: p.r*2, h: p.r*2 };
        for (const it of world.parts){
          const r = { x: it.x, y: it.y, w: it.w, h: it.h };
          if (!rectsOverlap(projRect, r)) continue;

          const impulse = Math.hypot(p.vx, p.vy);
          applyHit(it, impulse);

          const ox = Math.min(projRect.x+projRect.w - r.x, r.x+r.w - projRect.x);
          const oy = Math.min(projRect.y+projRect.h - r.y, r.y+r.h - projRect.y);

          if (ox < oy){
            if (p.x < it.x + it.w/2) p.x -= ox; else p.x += ox;
            p.vx = -p.vx * (0.30 + RESTITUTION);
            p.vy *= 0.92;
          } else {
            if (p.y < it.y + it.h/2) p.y -= oy; else p.y += oy;
            p.vy = -p.vy * (0.30 + RESTITUTION);
            p.vx *= 0.92;
          }

          if (it.broken){
            it.vx += p.vx * 0.02;
            it.vy += p.vy * 0.02;
          }
        }
      }

      for (const it of world.parts){
        if (!it.broken) continue;

        it.vy += G * 0.6 * dt;
        it.x += it.vx * dt;
        it.y += it.vy * dt;
        it.ang += it.vang * dt;

        if (it.y + it.h > ground){
          it.y = ground - it.h;
          it.vy = -it.vy * 0.18;
          it.vx *= 0.75;
          it.vang *= 0.7;
          if (Math.abs(it.vy) < 60) it.vy = 0;
          if (Math.abs(it.vx) < 25) it.vx = 0;
        }
      }
    }

    // ===========================
    // Loop
    // ===========================
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      step(dt);

      drawOfficeBackground(now/1000);
      drawOffice();
      drawSeatedHuman(now/1000);
      drawAimBand();
      drawProjectile();

      requestAnimationFrame(loop);
    }

    preload()
      .then(() => { resetWorld(); requestAnimationFrame(loop); })
      .catch(err => {
        console.error(err);
        alert("Ошибка загрузки PNG. Проверь пути/имена.\n\n" + err.message);
      });

  })();
  </script>
</body>
</html>
