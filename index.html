<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <!-- ‚úÖ mobile + disable page zoom (we do camera zoom instead) -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Office Birds ‚Äî Destruction</title>

  <style>
    html, body {
      margin:0; padding:0; width:100%; height:100%;
      overflow:hidden; background:#050a12;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      -webkit-user-select:none; user-select:none;
      -webkit-touch-callout:none;
    }
    #wrap { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    .hud {
      position:fixed; left:16px; top:16px; z-index:10;
      display:flex; gap:12px; align-items:flex-start;
      max-width: calc(100vw - 32px);
      pointer-events:none;
    }
    .panel {
      pointer-events:auto;
      background:rgba(9,18,28,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
      backdrop-filter: blur(6px);
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      min-width:270px;
    }
    .panel h1{ font-size:14px; margin:0 0 6px 0; font-weight:900; letter-spacing:.2px; }
    .panel small{ display:block; opacity:.88; font-size:12px; line-height:1.35; }

    .btnbar{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    button{
      background:rgba(255,255,255,.10);
      color:rgba(255,255,255,.92);
      border:1px solid rgba(255,255,255,.16);
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
      user-select:none;
      touch-action: manipulation;
    }
    button:hover{ background:rgba(255,255,255,.16); }
    button.super-on{
      background:rgba(255, 210, 70, .18);
      border-color:rgba(255, 210, 70, .38);
      box-shadow: 0 0 0 2px rgba(255, 210, 70, .14) inset;
    }

    .right{
      position:fixed; top:16px; right:16px; z-index:10; width:360px;
      pointer-events:none;
    }
    .right .panel{ pointer-events:auto; }

    .kv{
      display:grid; grid-template-columns:1fr auto;
      gap:6px 10px; margin-top:8px; font-size:12px; opacity:.95;
    }
    .kv div:nth-child(2n){ font-weight:900; }

    .toast{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      z-index:10; padding:7px 12px; font-size:12px; color:rgba(255,255,255,.94);
      background:rgba(0,0,0,.44); border:1px solid rgba(255,255,255,.12);
      border-radius:999px; backdrop-filter: blur(6px);
      pointer-events:none; opacity:0; transition:opacity .18s ease;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      max-width: calc(100vw - 24px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .toast.show{ opacity:1; }

    /* SUPER –∫–Ω–æ–ø–∫–∞ (–∫–∞–∫ –±—ã–ª–æ ‚Äî –±–æ–ª—å—à–∞—è) */
    .super-fly {
      position: fixed;
      left: 50%;
      bottom: 26px;
      transform: translateX(-50%);
      z-index: 20;
      display: none;
      pointer-events:auto;
    }
    .super-fly.show { display:block; }

    .super-fly button{
      font-size: 32px;
      padding: 38px 68px;
      border-radius: 28px;
      border: 3px solid rgba(255,210,70,.75);
      background: rgba(255,210,70,.18);
      box-shadow:
        0 20px 70px rgba(0,0,0,.48),
        0 0 0 5px rgba(255,210,70,.14) inset;
      letter-spacing: 1.1px;
    }
    .super-fly button:hover{ background: rgba(255,210,70,.26); }
    .super-fly button.super-on{
      background: rgba(255,210,70,.33);
      box-shadow:
        0 22px 78px rgba(0,0,0,.55),
        0 0 0 5px rgba(255,210,70,.18) inset;
    }
    .super-fly .hint{
      text-align:center;
      margin-top:10px;
      font-size:14px;
      color: rgba(255,255,255,.88);
      opacity:.92;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
      user-select:none;
      pointer-events:none;
    }

    /* ‚úÖ START MENU overlay */
    .menu {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(8px);
    }
    .menu.show { display: flex; }
    .menu-card{
      width: min(760px, calc(100vw - 40px));
      border-radius: 18px;
      padding: 24px 22px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(12,18,28,0.75);
      box-shadow: 0 30px 120px rgba(0,0,0,0.55);
      text-align: center;
      color: rgba(255,255,255,0.95);
      pointer-events:auto;
    }
    .menu-card h2{
      margin: 0 0 10px 0;
      font-size: 38px;
      letter-spacing: 0.5px;
      font-weight: 1000;
    }
    .menu-card p{
      margin: 0 auto 14px auto;
      max-width: 560px;
      opacity: .9;
      line-height: 1.45;
      font-size: 15px;
    }
    .menu-start{
      margin-top: 14px;
      font-size: 28px;
      padding: 20px 42px;
      border-radius: 18px;
      border: 2px solid rgba(255,210,70,.75);
      background: rgba(255,210,70,.20);
      box-shadow:
        0 18px 80px rgba(0,0,0,.55),
        0 0 0 6px rgba(255,210,70,.10) inset;
    }
    .menu-start:hover{ background: rgba(255,210,70,.30); }
    .menu-mini{
      margin-top: 12px;
      font-size: 12px;
      opacity: .85;
    }
    .kbd{
      display:inline-block;
      padding: 2px 7px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      font-weight: 800;
      font-size: 12px;
      margin: 0 3px;
    }

    /* ‚úÖ Mobile layout tweaks */
    @media (max-width: 820px){
      .hud{ left:10px; top:10px; flex-direction:column; gap:10px; }
      .panel{ min-width: 0; width: min(420px, calc(100vw - 20px)); }
      .right{ right:10px; top:auto; bottom:10px; width: auto; max-width: 420px; }
      .right .panel{ width: min(420px, calc(100vw - 20px)); }
      .super-fly{ bottom: 18px; }
      .super-fly button{ font-size: 28px; padding: 30px 52px; border-radius: 24px; }
      .menu-card h2{ font-size: 30px; }
      .menu-start{ font-size: 24px; padding: 18px 36px; }
      button{ padding: 12px 14px; }
    }
  </style>
</head>

<body>
  <!-- ‚úÖ START MENU -->
  <div class="menu show" id="startMenu">
    <div class="menu-card">
      <h2>OFFICE BIRDS</h2>
      <p>
        –ó–∞–∂–º–∏ —á–µ–ª–æ–≤–µ—á–∫–∞, —Ç—è–Ω–∏ –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É –∏ –æ—Ç–ø—É—Å–∫–∞–π ‚Äî –æ–Ω –ª–µ—Ç–∏—Ç –≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é.
        –í–æ –≤—Ä–µ–º—è –ø–æ–ª—ë—Ç–∞ –º–æ–∂–Ω–æ –Ω–∞–∂–∞—Ç—å <b>SUPER</b> –¥–ª—è —Ä–µ–∂–∏–º–∞ ‚Äú–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!‚Äù.
      </p>
      <p style="margin-top:10px; opacity:.85;">
        ‚úÖ <b>–ú–∞—Å—à—Ç–∞–±:</b> –∫–æ–ª–µ—Å–æ –º—ã—à–∏ –∏–ª–∏ pinch –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏.<br/>
        ‚úÖ <b>–ü–∞–Ω–æ—Ä–∞–º–∞:</b> –¥–µ—Ä–∂–∏ 2 –ø–∞–ª—å—Ü–∞ –∏ –¥–≤–∏–≥–∞–π ‚Äî –∫–∞–º–µ—Ä–∞ –ø–æ–µ–¥–µ—Ç.
      </p>
      <button class="menu-start" id="startBtn">START GAME</button>
      <div class="menu-mini">
        –ü–æ–¥—Å–∫–∞–∑–∫–∞: <span class="kbd">R</span> ‚Äî reset, <span class="kbd">D</span> ‚Äî debug, <span class="kbd">+</span>/<span class="kbd">-</span> ‚Äî zoom.
      </div>
    </div>
  </div>

  <div class="hud">
    <div class="panel">
      <h1>Office Birds ‚Äî Destruction</h1>
      <small><b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</b> –∑–∞–∂–º–∏ —á–µ–ª–æ–≤–µ—á–∫–∞ ‚Üí —Ç—è–Ω–∏ –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É ‚Üí –æ—Ç–ø—É—Å—Ç–∏ (–ª–µ—Ç–∏—Ç –≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é).</small>
      <small><b>–ü—Ä–∏—Ü–µ–ª:</b> –ø—Ä–∏ –Ω–∞—Ç—è–∂–µ–Ω–∏–∏ –≤–∏–¥–Ω–æ –ø—É–Ω–∫—Ç–∏—Ä–Ω—É—é —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é.</small>
      <small><b>–õ–æ–º–∞–Ω–∏–µ:</b> –ø–æ–ø–æ–ª–∞–º ‚Üí —á–µ—Ç–≤–µ—Ä—Ç–∏–Ω–∫–∏ ‚Üí –∏—Å—á–µ–∑–∞–µ—Ç.</small>
      <div class="kv">
        <div>–°—á—ë—Ç:</div><div id="score">0</div>
        <div>–°–ª–æ–º–∞–Ω–æ:</div><div id="broken">0</div>
        <div>–ü–æ–ø–∞–¥–∞–Ω–∏–π:</div><div id="hits">0</div>
        <div>–ü–æ–±–µ–¥:</div><div id="wins">0</div>
      </div>
    </div>

    <div class="btnbar">
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">DEBUG</button>

      <button id="zoomOutBtn">‚àí</button>
      <button id="zoomInBtn">+</button>
      <button id="zoomResetBtn">100%</button>
    </div>
  </div>

  <div class="right">
    <div class="panel">
      <h1>–¶–µ–ª—å</h1>
      <small>–í—ã–±–µ–π –≤—Å–µ—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ üèÜ</small>
      <small>–°–∏–ª—å–Ω—ã–π —É–¥–∞—Ä ‚Üí —à–µ–π–∫ –∫–∞–º–µ—Ä—ã. SUPER ‚Üí –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ + ¬´–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!¬ª</small>
      <div class="kv">
        <div>–°—Ç–∞—Ç—É—Å:</div><div id="status">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
        <div>SUPER:</div><div id="superState">OFF</div>
        <div>ZOOM:</div><div id="zoomLabel">100%</div>
      </div>
    </div>
  </div>

  <div class="super-fly" id="superFlyWrap">
    <button id="superFlyBtn">SUPER ‚ö°</button>
    <div class="hint">–ù–∞–∂–º–∏ –æ–¥–∏–Ω —Ä–∞–∑, –ø–æ–∫–∞ –ª–µ—Ç–∏—à—å</div>
  </div>

  <div id="wrap"><canvas id="c"></canvas></div>
  <div id="toast" class="toast">‚Ä¶</div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
  (function(){
    "use strict";

    const $ = (id) => document.getElementById(id);
    const toastEl = $("toast");
    function toast(msg, ms=1400){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(()=>toastEl.classList.remove("show"), ms);
    }

    function loadImage(src){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = ()=>reject(new Error("–ù–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å –∫–∞—Ä—Ç–∏–Ω–∫–∞: " + src));
        img.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    // ‚úÖ START MENU CONTROL
    const startMenu = $("startMenu");
    const startBtn  = $("startBtn");
    let GAME_STARTED = false;

    function showMenu(){
      GAME_STARTED = false;
      startMenu.classList.add("show");
      if (runner) runner.enabled = false;
    }
    function hideMenu(){
      GAME_STARTED = true;
      startMenu.classList.remove("show");
      if (runner) runner.enabled = true;
    }
    startBtn.addEventListener("click", hideMenu);

    // –∞—Å—Å–µ—Ç—ã
    const ASSETS = {
      bg: "assets/bg_office.png",

      // ‚úÖ NEW: ground texture (put it in repo: assets/ground/ground.png)
      ground: "assets/ground/ground.png",

      beam: "assets/office/beam.png",
      pillar: "assets/office/pillar.png",
      manager: "assets/office/manager.png",
      humanIdle: "assets/player/human_idle.png",
      humanFly: "assets/player/human_fly.png",
      chair: "assets/player/chair.png",
      superSkin: "assets/player/human_idle.png"
    };

    // ‚úÖ VISUAL GROUND SETTINGS (tweak only these if you want)
    const GROUND_VIS = {
      // height of visible ground in WORLD units (not pixels)
      hWorld: 300,
      // small overlap into ground to avoid 1px gaps
      overlap: 2,
      // slight darkness overlay to blend with scene (0..0.6)
      shadeAlpha: 0.10
    };

    const {
      Engine, Render, Runner, World, Bodies, Body,
      Constraint, Events, Composite, Vector
    } = Matter;

    let engine, world, render, runner, ground;

    let bird = null;
    let birdLaunched = false;
    let birdRespawnTimer = null;

    let slingshot = null;
    let slingAnchor = null;

    let draggingBird = false;
    let canLaunch = true;
    let dragView = null;

    let DEBUG = false;

    // –¥–µ–∫–æ—Ä-—Å—Ç—É–ª (–ù–ï —Ñ–∏–∑–∏–∫–∞)
    let chairDecal = null;

    // SUPER
    let superActive = false;
    let superPulseT = 0;
    let superBannerFrames = 0;
    let superDim = 0;
    let superAuraPulse = 0;
    let birdSwingBaseAngle = 0;

    // —à–µ–π–∫
    let shakeTime = 0;
    let shakeMag = 0;

    // debris
    const debris = [];

    // level
    const structure = { pillars: [], beams: [], managers: [], activated: false };
    const stats = { score:0, broken:0, hits:0, wins:0 };

    // –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –ø—Ç–∏—Ü—ã
    const AUTO_RESPAWN_MS = 12000;

    // –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ SUPER
    const SUPER_VISUAL = {
      dimTarget: 0.60,
      vignette: 0.38
    };

    // –ø–ª–∞–≤–Ω–æ—Å—Ç—å
    const FLIGHT = {
      airFrictionFlying: 0.0032,
      maxSpeed: 52,
      maxAngular: 0.18,
      settleFrictionAir: 0.012
    };

    // —É—Ä–æ–Ω/–ª–æ–º–∞–Ω–∏–µ
    const DMG = {
      dmgK: 0.08,
      minHitEnergy: 1.8,
      hpStage0: 1.25,
      hpStage1: 1.10,
      hpStage2: 0.90,
      shakeEnergyThreshold: 9.0,
      shakeMax: 22,
      superMultiplier: 2.8,
      superAuraRadius: 240,
      superAuraEnergyPerTick: 12.0,
      superAuraTickEvery: 6
    };

    const DEBRIS = {
      ttlMs: 6500,
      minSpeedToCountStill: 0.18,
      stillFramesToVanish: 55,
      airFriction: 0.020,
    };

    const SPR = {
      pillarH: 330,
      beamW: 440,

      birdRadius: 56,
      birdWIdle: 165,
      birdWFly: 135,
      birdWSuper: 190,

      managerW: 86,
      chairW: 120
    };

    const LEVEL = {
      floorHeight: 95,
      birdStartX: 210,
      birdStartYOffset: 190,
      houses: [
        { x: 0.56, w: 470, managers: 4 },
        { x: 0.72, w: 470, managers: 4 },
        { x: 0.88, w: 470, managers: 3 },
      ]
    };

    // ‚úÖ Camera + user zoom + pan
    const camera = {
      cx: 0, cy: 0,
      tx: 0, ty: 0,
      zoom: 1.0,
      tzoom: 1.0,
      smoothing: 0.14,

      baseZoom: 0.86,
      userZoom: 1.0,

      panX: 0,
      panY: 0,
      panHoldFrames: 0
    };

    const ZOOM = {
      min: 0.55,
      max: 1.85,
      step: 1.10
    };

    function lerp(a,b,t){ return a + (b-a)*t; }
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

    function setUserZoom(mult, showToast=true){
      camera.userZoom = clamp(mult, ZOOM.min, ZOOM.max);
      const pct = Math.round(camera.userZoom * 100);
      $("zoomLabel").textContent = pct + "%";
      $("zoomResetBtn").textContent = pct + "%";
      if (showToast) toast("ZOOM: " + pct + "%", 700);
    }

    // —Ä–æ–≥–∞—Ç–∫–∞
    const SLING = { pullMax: 420, launchK: 0.165 };

    // –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ
    const AIM = {
      enabled: true,
      steps: 26,
      stepTicks: 6,
      dotEvery: 1,
      dotRadius: 3.2,
      alphaStart: 0.85,
      alphaEnd: 0.10
    };

    // UI —Å—É–ø–µ—Ä
    const superFlyWrap = $("superFlyWrap");
    const superFlyBtn  = $("superFlyBtn");

    function refreshSuperButtonVisibility(){
      const shouldShow = !!(bird && birdLaunched && !superActive);
      superFlyWrap.classList.toggle("show", shouldShow);
      superFlyBtn.classList.toggle("super-on", superActive);
    }

    function setSuperActive(next){
      superActive = next;

      if (superActive){
        superPulseT = 0;
        superBannerFrames = 180;
        superDim = Math.max(superDim, SUPER_VISUAL.dimTarget);
        superAuraPulse = 1.0;
        birdSwingBaseAngle = (bird && typeof bird.angle === "number") ? bird.angle : 0;
        toast("SUPER ON ‚ö°", 900);
        if (bird && birdLaunched) setBirdSuper();
      } else {
        toast("SUPER OFF", 700);
      }

      $("superState").textContent = superActive ? "ON" : "OFF";
      refreshSuperButtonVisibility();
    }

    superFlyBtn.addEventListener("click", ()=>{
      if (!bird || !birdLaunched || superActive) return;
      setSuperActive(true);
    });

    function updateHUD(){
      $("score").textContent  = String(stats.score);
      $("broken").textContent = String(stats.broken);
      $("hits").textContent   = String(stats.hits);
      $("wins").textContent   = String(stats.wins);
      $("superState").textContent = superActive ? "ON" : "OFF";
      refreshSuperButtonVisibility();
      $("zoomLabel").textContent = Math.round(camera.userZoom * 100) + "%";
    }

    // ‚úÖ Zoom buttons
    $("zoomInBtn").addEventListener("click", ()=> setUserZoom(camera.userZoom * ZOOM.step));
    $("zoomOutBtn").addEventListener("click", ()=> setUserZoom(camera.userZoom / ZOOM.step));
    $("zoomResetBtn").addEventListener("click", ()=> setUserZoom(1.0));

    $("status").textContent = "–ó–∞–≥—Ä—É–∑–∫–∞ –∞—Å—Å–µ—Ç–æ–≤‚Ä¶";

    Promise.all([
      loadImage(ASSETS.bg),

      // ‚úÖ NEW: load ground texture
      loadImage(ASSETS.ground),

      loadImage(ASSETS.beam),
      loadImage(ASSETS.pillar),
      loadImage(ASSETS.manager),
      loadImage(ASSETS.humanIdle),
      loadImage(ASSETS.humanFly),
      loadImage(ASSETS.chair),
      loadImage(ASSETS.superSkin)
    ]).then(([imgBg, imgGround, imgBeam, imgPillar, imgManager, imgIdle, imgFly, imgChair, imgSuper])=>{
      start({imgBg, imgGround, imgBeam, imgPillar, imgManager, imgIdle, imgFly, imgChair, imgSuper});
    }).catch((e)=>{
      console.error(e);
      $("status").textContent = "–û—à–∏–±–∫–∞ PNG";
      toast("PNG –æ—à–∏–±–∫–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä—å assets/‚Ä¶", 2500);
    });

    // ======== BROWSER ADAPT HELPERS ========
    function dpr(){
      return Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    }
    function resizeCanvasToDisplaySize(canvas){
      const ratio = dpr();
      const w = Math.floor(window.innerWidth * ratio);
      const h = Math.floor(window.innerHeight * ratio);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    // ‚úÖ create/recreate ground on resize/reset (fixes stale ground position)
    function createGround(){
      const y = window.innerHeight - (LEVEL.floorHeight / 2);
      const w = 9000;
      const x = 2600;
      const g = Bodies.rectangle(
        x, y, w, LEVEL.floorHeight,
        {
          isStatic:true,
          friction:1.0,
          restitution:0.0,
          render: DEBUG
            ? { fillStyle:"rgba(255,255,255,0.10)" }
            : { fillStyle:"rgba(0,0,0,0)" } // invisible physics floor, visual drawn separately
        }
      );
      return g;
    }

    function start(IMGS){
      $("status").textContent = "–ó–∞–ø—É—Å–∫‚Ä¶";

      const canvas = $("c");
      const wrap = $("wrap");

      engine = Engine.create();
      world = engine.world;
      world.gravity.y = 0.98;

      engine.positionIterations = 8;
      engine.velocityIterations = 7;
      engine.constraintIterations = 3;

      resizeCanvasToDisplaySize(canvas);

      render = Render.create({
        element: wrap,
        canvas,
        engine,
        options: {
          width: window.innerWidth,
          height: window.innerHeight,
          wireframes: false,
          background: ASSETS.bg,
          pixelRatio: dpr(),
          hasBounds: true
        }
      });

      runner = Runner.create();

      ground = createGround();
      World.add(world, ground);

      buildLevel(IMGS);
      spawnBird(IMGS);
      setupSlingshot();
      setupCameraInitial();
      bindInput(IMGS);
      bindPhysics(IMGS);

      // ‚úÖ draw ground BEFORE bodies (so it is under objects)
      Events.on(render, "beforeRender", ()=>{
        const ctx = render.context;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        drawGround(IMGS);
        ctx.restore();
      });

      // overlays AFTER bodies
      Events.on(render, "afterRender", ()=>{
        const ctx = render.context;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (AIM.enabled) drawAimTrajectory();
        if (chairDecal) drawChairDecal(IMGS);
        drawSuperOverlay();

        ctx.restore();
      });

      Render.run(render);
      Runner.run(runner, engine);

      // ‚úÖ Start paused (menu shown)
      runner.enabled = false;

      $("resetBtn").addEventListener("click", ()=>{ resetAll(IMGS); showMenu(); });
      $("debugBtn").addEventListener("click", ()=>{
        DEBUG = !DEBUG;
        toast(DEBUG ? "DEBUG: ON" : "DEBUG: OFF", 900);
        resetAll(IMGS);
        if (!GAME_STARTED) showMenu();
      });

      // ‚úÖ wheel zoom (desktop)
      canvas.addEventListener("wheel", (e)=>{
        e.preventDefault();
        const dir = Math.sign(e.deltaY);
        if (dir > 0) setUserZoom(camera.userZoom / ZOOM.step, false);
        else setUserZoom(camera.userZoom * ZOOM.step, false);
      }, { passive:false });

      // ‚úÖ keyboard shortcuts
      window.addEventListener("keydown", (e)=>{
        if (e.key === "r" || e.key === "R"){ resetAll(IMGS); showMenu(); }
        if (e.key === "d" || e.key === "D"){ DEBUG = !DEBUG; toast(DEBUG ? "DEBUG: ON" : "DEBUG: OFF", 900); resetAll(IMGS); if (!GAME_STARTED) showMenu(); }
        if (e.key === "+" || e.key === "="){ setUserZoom(camera.userZoom * ZOOM.step); }
        if (e.key === "-" || e.key === "_"){ setUserZoom(camera.userZoom / ZOOM.step); }
        if ((e.key === "Enter" || e.key === " ") && !GAME_STARTED){ hideMenu(); }
      });

      window.addEventListener("resize", ()=>onResize(IMGS));

      $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
      setUserZoom(1.0, false);
      updateHUD();

      showMenu();
    }

    function onResize(IMGS){
      resizeCanvasToDisplaySize(render.canvas);
      render.options.pixelRatio = dpr();
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;
      resetAll(IMGS);
      if (!GAME_STARTED) showMenu();
    }

    function resetAll(IMGS){
      if (birdRespawnTimer){ clearTimeout(birdRespawnTimer); birdRespawnTimer = null; }

      Composite.clear(world, false);

      // ‚úÖ recreate ground with new window size
      ground = createGround();
      World.add(world, ground);

      stats.score = 0; stats.broken = 0; stats.hits = 0; stats.wins = 0;
      structure.pillars = []; structure.beams = []; structure.managers = []; structure.activated = false;

      debris.length = 0;

      bird = null; slingshot = null; slingAnchor = null;
      draggingBird = false; canLaunch = true; birdLaunched = false; dragView = null;

      chairDecal = null;

      superActive = false; superPulseT = 0; superBannerFrames = 0; superDim = 0; superAuraPulse = 0;
      birdSwingBaseAngle = 0;

      shakeTime = 0; shakeMag = 0;

      // ‚úÖ reset camera pan too
      camera.panX = 0;
      camera.panY = 0;
      camera.panHoldFrames = 0;

      buildLevel(IMGS);
      spawnBird(IMGS);
      setupSlingshot();
      setupCameraInitial();

      refreshSuperButtonVisibility();
      $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
      updateHUD();
    }

    // ======== BREAKABLE METADATA ========
    function setBreakMeta(body, type, tex, sx, sy){
      body.__type = type;
      body.__broken = false;
      body.__breakStage = 0; // 0=—Ü–µ–ª—ã–π, 1=–ø–æ–ª–æ–≤–∏–Ω–∫–∏, 2=—á–µ—Ç–≤–µ—Ä—Ç–∏–Ω–∫–∏
      body.__tex = tex;
      body.__sx = sx;
      body.__sy = sy;
      body.__hp = DMG.hpStage0;
      return body;
    }

    // ======== LEVEL BUILD ========
    function buildLevel(IMGS){
      const baseY = window.innerHeight - LEVEL.floorHeight;

      structure.pillars = [];
      structure.beams = [];
      structure.managers = [];

      for (let hi=0; hi<LEVEL.houses.length; hi++){
        const H = LEVEL.houses[hi];
        const cx = Math.round(window.innerWidth * H.x);
        const w = H.w;

        const leftX  = cx - Math.round(w/2);
        const rightX = cx + Math.round(w/2);

        const pillarScale = SPR.pillarH / IMGS.imgPillar.height;
        const beamScale   = SPR.beamW   / IMGS.imgBeam.width;

        const pillarH = IMGS.imgPillar.height * pillarScale;
        const pillarW = IMGS.imgPillar.width  * pillarScale;

        const pLeft = Bodies.rectangle(leftX, baseY - pillarH/2, pillarW, pillarH, {
          isStatic:true,
          render: DEBUG ? { fillStyle:"rgba(0,210,255,0.20)", strokeStyle:"rgba(110,240,255,0.9)", lineWidth:2 }
                        : { sprite:{ texture: ASSETS.pillar, xScale: pillarScale, yScale: pillarScale } }
        });
        setBreakMeta(pLeft, "pillar", ASSETS.pillar, pillarScale, pillarScale);

        const pRight = Bodies.rectangle(rightX, baseY - pillarH/2, pillarW, pillarH, {
          isStatic:true,
          render: DEBUG ? { fillStyle:"rgba(0,210,255,0.20)", strokeStyle:"rgba(110,240,255,0.9)", lineWidth:2 }
                        : { sprite:{ texture: ASSETS.pillar, xScale: pillarScale, yScale: pillarScale } }
        });
        setBreakMeta(pRight, "pillar", ASSETS.pillar, pillarScale, pillarScale);

        const beamW = IMGS.imgBeam.width  * beamScale;
        const beamH = IMGS.imgBeam.height * beamScale;

        const yBot  = baseY - 46;
        const yMid  = baseY - 182;
        const yTop  = baseY - 318;
        const yTop2 = baseY - 454;

        function makeBeam(x,y){
          const b = Bodies.rectangle(x, y, beamW, beamH, {
            isStatic:true,
            friction:0.95,
            restitution:0.02,
            density:0.0022,
            chamfer:{ radius:4 },
            render: DEBUG ? { fillStyle:"rgba(255,120,0,0.25)", strokeStyle:"rgba(255,170,90,0.9)", lineWidth:2 }
                          : { sprite:{ texture: ASSETS.beam, xScale: beamScale, yScale: beamScale } }
          });
          setBreakMeta(b, "beam", ASSETS.beam, beamScale, beamScale);
          return b;
        }

        const bTop2 = makeBeam(cx, yTop2);
        const bTop  = makeBeam(cx, yTop);
        const bMid  = makeBeam(cx, yMid);
        const bBot  = makeBeam(cx, yBot);

        // managers
        const mScale = SPR.managerW / IMGS.imgManager.width;
        const mW = IMGS.imgManager.width * mScale;
        const mH = IMGS.imgManager.height * mScale;

        const tiers = [
          { y: yTop2 - beamH/2 - mH/2 + 10, span: w*0.50 },
          { y: yTop  - beamH/2 - mH/2 + 10, span: w*0.46 },
          { y: yMid  - beamH/2 - mH/2 + 10, span: w*0.42 }
        ];

        const managers = [];
        for (let i=0; i<H.managers; i++){
          const tier = tiers[i % tiers.length];
          const t = (i+1)/(H.managers+1);
          const x = cx - tier.span/2 + t * tier.span;
          const y = tier.y;

          const m = Bodies.rectangle(x, y, mW, mH, {
            isStatic:true,
            friction:0.85,
            restitution:0.02,
            density:0.002,
            render: DEBUG ? { fillStyle:"rgba(255,255,255,0.16)", strokeStyle:"rgba(255,255,255,0.9)", lineWidth:2 }
                          : { sprite:{ texture: ASSETS.manager, xScale: mScale, yScale: mScale } }
          });
          setBreakMeta(m, "manager", ASSETS.manager, mScale, mScale);
          m.__alive = true;
          managers.push(m);
        }

        structure.pillars.push(pLeft, pRight);
        structure.beams.push(bTop2, bTop, bMid, bBot);
        structure.managers.push(...managers);

        World.add(world, [pLeft, pRight, bTop2, bTop, bMid, bBot, ...managers]);
      }
    }

    function activateStructure(){
      if (structure.activated) return;
      structure.activated = true;

      const all = [...structure.beams, ...structure.pillars, ...structure.managers];
      for (const b of all){
        Body.setStatic(b,false);
        b.frictionAir = 0.010;
      }
    }

    // ======== BIRD ========
    function spawnBird(IMGS){
      const baseY = window.innerHeight - LEVEL.floorHeight;
      const start = { x: LEVEL.birdStartX, y: baseY - LEVEL.birdStartYOffset };

      const idleScale = SPR.birdWIdle / IMGS.imgIdle.width;
      const flyScale  = SPR.birdWFly  / IMGS.imgFly.width;
      const superScale = SPR.birdWSuper / IMGS.imgIdle.width;

      bird = Bodies.circle(start.x, start.y, SPR.birdRadius, {
        restitution:0.20,
        friction:0.95,
        frictionAir:0.012,
        density:0.0048,
        render: DEBUG ? { fillStyle:"rgba(255,0,0,0.22)", strokeStyle:"rgba(255,0,0,0.9)", lineWidth:2 }
                      : { sprite:{ texture: ASSETS.humanIdle, xScale: idleScale, yScale: idleScale } }
      });

      bird.__start = start;
      bird.__idleTexture = ASSETS.humanIdle;
      bird.__idleScale = idleScale;

      bird.__flyTexture = ASSETS.humanFly;
      bird.__flyScale = flyScale;

      bird.__superTexture = ASSETS.superSkin;
      bird.__superScale = superScale;

      birdLaunched = false;
      World.add(world, bird);
      refreshSuperButtonVisibility();
    }

    function setBirdIdle(){
      if (!bird || DEBUG) return;
      bird.render.sprite.texture = bird.__idleTexture;
      bird.render.sprite.xScale = bird.__idleScale;
      bird.render.sprite.yScale = bird.__idleScale;
    }
    function setBirdFly(){
      if (!bird || DEBUG) return;
      bird.render.sprite.texture = bird.__flyTexture;
      bird.render.sprite.xScale = bird.__flyScale;
      bird.render.sprite.yScale = bird.__flyScale;
    }
    function setBirdSuper(){
      if (!bird || DEBUG) return;
      bird.render.sprite.texture = bird.__superTexture;
      bird.render.sprite.xScale = bird.__superScale;
      bird.render.sprite.yScale = bird.__superScale;
    }

    function setupSlingshot(){
      const start = bird.__start;
      slingAnchor = { x:start.x, y:start.y };
      slingshot = Constraint.create({
        pointA: { x:slingAnchor.x, y:slingAnchor.y },
        bodyB: bird,
        stiffness: 0.035,
        damping: 0.06,
        length: 0,
        render: { visible: DEBUG }
      });
      World.add(world, slingshot);
    }
    function detachSlingshot(){
      if (!slingshot) return;
      World.remove(world, slingshot);
      slingshot = null;
    }

    // –¥–µ–∫–æ—Ä-—Å—Ç—É–ª (–Ω–µ —Ñ–∏–∑–∏–∫–∞)
    function spawnChairDecal(IMGS, atPos){
      const chairScale = SPR.chairW / IMGS.imgChair.width;
      chairDecal = { x: atPos.x, y: atPos.y + 64, w: IMGS.imgChair.width*chairScale, h: IMGS.imgChair.height*chairScale };
    }
    function clearChairDecal(){ chairDecal = null; }

    function scheduleBirdRespawn(IMGS, delayMs){
      if (birdRespawnTimer) return;
      birdRespawnTimer = setTimeout(()=>{
        birdRespawnTimer = null;

        if (bird){ World.remove(world, bird); bird = null; }
        if (slingshot){ World.remove(world, slingshot); slingshot = null; }

        clearChairDecal();

        superActive = false;
        superPulseT = 0;
        superBannerFrames = 0;
        superDim = 0;
        superAuraPulse = 0;
        birdSwingBaseAngle = 0;

        spawnBird(IMGS);
        setupSlingshot();
        setBirdIdle();

        birdLaunched = false;
        draggingBird = false;
        canLaunch = true;
        dragView = null;

        refreshSuperButtonVisibility();
        $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
        updateHUD();
      }, delayMs);
    }

    // ======== CAMERA ========
    function setupCameraInitial(){
      const baseY = window.innerHeight - LEVEL.floorHeight;
      camera.cx = camera.tx = 900;
      camera.cy = camera.ty = baseY - 300;
      camera.baseZoom = 0.86;
      camera.zoom = camera.tzoom = camera.baseZoom * camera.userZoom;
      applyCamera(true);
    }

    function triggerShake(energy){
      const over = energy - DMG.shakeEnergyThreshold;
      const strength = clamp(over * 2.0, 6, DMG.shakeMax);
      shakeMag = Math.max(shakeMag, strength);
      shakeTime = Math.max(shakeTime, 20);
    }

    function applyCamera(force=false){
      camera.cx = force ? camera.tx : lerp(camera.cx, camera.tx, camera.smoothing);
      camera.cy = force ? camera.ty : lerp(camera.cy, camera.ty, camera.smoothing);
      camera.zoom = force ? camera.tzoom : lerp(camera.zoom, camera.tzoom, camera.smoothing);

      let sx = 0, sy = 0;
      if (shakeTime > 0){
        const amp = shakeMag * (shakeTime / 20);
        sx = (Math.random()*2 - 1) * amp;
        sy = (Math.random()*2 - 1) * amp;
      }

      const vw = window.innerWidth / camera.zoom;
      const vh = window.innerHeight / camera.zoom;

      render.bounds.min.x = (camera.cx + sx) - vw/2;
      render.bounds.min.y = (camera.cy + sy) - vh/2;
      render.bounds.max.x = render.bounds.min.x + vw;
      render.bounds.max.y = render.bounds.min.y + vh;

      Render.lookAt(render, { min: render.bounds.min, max: render.bounds.max });
    }

    // ======== INPUT ========
    function pointerToWorld(clientX, clientY){
      const rect = render.canvas.getBoundingClientRect();
      const sx = (clientX - rect.left) / rect.width;
      const sy = (clientY - rect.top) / rect.height;
      const b = (draggingBird && dragView) ? dragView : render.bounds;
      return { x: b.min.x + sx * (b.max.x - b.min.x), y: b.min.y + sy * (b.max.y - b.min.y) };
    }

    // ‚úÖ pinch+pan support (2 pointers)
    const pointers = new Map();
    let pinching = false;
    let pinchStartDist = 0;
    let pinchStartZoom = 1.0;

    let lastMid = null;

    function dist2(a,b){
      const dx = a.x-b.x, dy=a.y-b.y;
      return Math.sqrt(dx*dx+dy*dy);
    }
    function midPoint(a,b){
      return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
    }

    function startPinchIfPossible(){
      if (pointers.size !== 2) return;
      const pts = Array.from(pointers.values());
      pinching = true;
      pinchStartDist = dist2(pts[0], pts[1]);
      pinchStartZoom = camera.userZoom;

      lastMid = midPoint(pts[0], pts[1]);

      draggingBird = false;
      dragView = null;

      camera.panHoldFrames = Math.max(camera.panHoldFrames, 60);
    }

    function updatePinchAndPan(){
      if (!pinching || pointers.size !== 2) return;

      const pts = Array.from(pointers.values());
      const d = dist2(pts[0], pts[1]);
      if (pinchStartDist > 0){
        const factor = d / pinchStartDist;
        setUserZoom(pinchStartZoom * factor, false);
      }

      const m = midPoint(pts[0], pts[1]);
      if (lastMid){
        const dx = (m.x - lastMid.x);
        const dy = (m.y - lastMid.y);
        lastMid = m;

        const rect = render.canvas.getBoundingClientRect();
        const b = render.bounds;
        const vw = (b.max.x - b.min.x);
        const vh = (b.max.y - b.min.y);

        const worldDX = (dx / rect.width)  * vw;
        const worldDY = (dy / rect.height) * vh;

        camera.panX -= worldDX;
        camera.panY -= worldDY;

        camera.panX = clamp(camera.panX, -2200, 2200);
        camera.panY = clamp(camera.panY, -1200, 1200);

        camera.panHoldFrames = Math.max(camera.panHoldFrames, 60);
      }
    }

    function endPinchIfNeeded(){
      if (pointers.size < 2){
        pinching = false;
        lastMid = null;
        camera.panHoldFrames = Math.max(camera.panHoldFrames, 45);
      }
    }

    function onDown(clientX, clientY, setCaptureFn){
      if (!GAME_STARTED) return;
      if (pinching) return;
      if (!bird || birdLaunched || !canLaunch) return;

      const p = pointerToWorld(clientX, clientY);
      const dist = Math.hypot(p.x - bird.position.x, p.y - bird.position.y);
      if (dist <= SPR.birdRadius * 1.25){
        if (setCaptureFn) setCaptureFn();
        draggingBird = true;
        dragView = { min: { x: render.bounds.min.x, y: render.bounds.min.y }, max: { x: render.bounds.max.x, y: render.bounds.max.y } };
        Body.setStatic(bird, true);
        $("status").textContent = "–¢—è–Ω–∏‚Ä¶";
      }
    }

    function onMove(clientX, clientY){
      if (!GAME_STARTED) return;
      if (pinching) return;
      if (!bird || !draggingBird || birdLaunched) return;

      const start = bird.__start;
      const p = pointerToWorld(clientX, clientY);
      const dx = p.x - start.x, dy = p.y - start.y;

      const dist = Math.hypot(dx, dy) || 1;
      const k = Math.min(1, SLING.pullMax / dist);

      Body.setPosition(bird, { x: start.x + dx * k, y: start.y + dy * k });
      Body.setVelocity(bird, { x: 0, y: 0 });
      Body.setAngularVelocity(bird, 0);
    }

    function onUp(IMGS){
      if (!GAME_STARTED) return;
      if (pinching) return;
      if (!bird || !draggingBird || birdLaunched) { draggingBird = false; dragView = null; return; }
      draggingBird = false; dragView = null;
      if (!canLaunch) return;

      activateStructure();

      setBirdFly();
      spawnChairDecal(IMGS, bird.__start);
      detachSlingshot();

      Body.setStatic(bird, false);

      const pull = Vector.sub(bird.__start, bird.position);
      const d = Math.min(Vector.magnitude(pull), SLING.pullMax);

      if (d > 8){
        const dir = Vector.normalise(pull);
        const vel = Vector.mult(dir, d * SLING.launchK);

        Body.setVelocity(bird, { x: 0, y: 0 });
        Body.setAngularVelocity(bird, 0);
        Body.setVelocity(bird, vel);

        bird.frictionAir = FLIGHT.airFrictionFlying;
        birdSwingBaseAngle = 0;
      }

      birdLaunched = true;
      canLaunch = false;
      stats.score += 1;
      updateHUD();
      $("status").textContent = "–ü–æ–ª–µ—Ç–µ–ª!";

      refreshSuperButtonVisibility();
      scheduleBirdRespawn(IMGS, AUTO_RESPAWN_MS);
    }

    function bindInput(IMGS){
      const canvas = render.canvas;

      if (window.PointerEvent){
        canvas.addEventListener("pointerdown", (e)=>{
          pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

          if (pointers.size === 2){
            startPinchIfPossible();
          } else {
            onDown(e.clientX, e.clientY, ()=>canvas.setPointerCapture(e.pointerId));
          }
        });

        canvas.addEventListener("pointermove", (e)=>{
          if (pointers.has(e.pointerId)) pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
          if (pointers.size === 2){
            updatePinchAndPan();
          } else {
            onMove(e.clientX, e.clientY);
          }
        });

        canvas.addEventListener("pointerup", (e)=>{
          pointers.delete(e.pointerId);
          endPinchIfNeeded();
          onUp(IMGS);
        });

        canvas.addEventListener("pointercancel", (e)=>{
          pointers.delete(e.pointerId);
          endPinchIfNeeded();
          onUp(IMGS);
        });

        return;
      }

      // Mouse fallback
      let mouseDown = false;
      canvas.addEventListener("mousedown", (e)=>{
        mouseDown = true;
        onDown(e.clientX, e.clientY, null);
      });
      window.addEventListener("mousemove", (e)=>{
        if (!mouseDown) return;
        onMove(e.clientX, e.clientY);
      });
      window.addEventListener("mouseup", ()=>{
        mouseDown = false;
        onUp(IMGS);
      });

      // Touch fallback (single finger only)
      canvas.addEventListener("touchstart", (e)=>{
        e.preventDefault();
        const t = e.changedTouches[0];
        onDown(t.clientX, t.clientY, null);
      }, {passive:false});

      canvas.addEventListener("touchmove", (e)=>{
        e.preventDefault();
        const t = e.changedTouches[0];
        onMove(t.clientX, t.clientY);
      }, {passive:false});

      canvas.addEventListener("touchend", (e)=>{
        e.preventDefault();
        onUp(IMGS);
      }, {passive:false});

      canvas.addEventListener("touchcancel", (e)=>{
        e.preventDefault();
        onUp(IMGS);
      }, {passive:false});
    }

    // ======== WORLD->SCREEN HELPERS ========
    function worldToScreen(x, y){
      const b = render.bounds;
      return {
        x: (x - b.min.x) / (b.max.x - b.min.x) * render.canvas.width,
        y: (y - b.min.y) / (b.max.y - b.min.y) * render.canvas.height
      };
    }
    function worldSizeToScreen(w, h){
      const b = render.bounds;
      const vw = (b.max.x - b.min.x);
      const vh = (b.max.y - b.min.y);
      return {
        w: (w / vw) * render.canvas.width,
        h: (h / vh) * render.canvas.height
      };
    }

    // ‚úÖ NEW: draw tiled ground texture in WORLD coords (camera-safe)
    function drawGround(IMGS){
      if (!IMGS || !IMGS.imgGround) return;

      const img = IMGS.imgGround;
      const b = render.bounds;

      const baseY = window.innerHeight - LEVEL.floorHeight; // world y where floor starts (top of physics ground)
      const topY = baseY - GROUND_VIS.overlap;
      const hWorld = GROUND_VIS.hWorld + GROUND_VIS.overlap;

      // scale so that image height becomes hWorld in world units
      const scale = hWorld / img.height;
      const tileWWorld = img.width * scale;

      // start tiling slightly before visible bounds
      const xStart = Math.floor((b.min.x - tileWWorld) / tileWWorld) * tileWWorld;
      const xEnd = b.max.x + tileWWorld;

      const sTop = worldToScreen(xStart, topY);
      const sizeOne = worldSizeToScreen(tileWWorld, hWorld);
      const tileWpx = sizeOne.w;
      const tileHpx = sizeOne.h;

      // y in px: compute from topY to screen
      const sY = worldToScreen(0, topY).y;

      const ctx = render.context;
      ctx.save();

      // draw tiles
      for (let x = xStart; x <= xEnd; x += tileWWorld){
        const sX = worldToScreen(x, topY).x;
        ctx.drawImage(img, sX, sY, tileWpx, tileHpx);
      }

      // subtle shade overlay to blend
      if (GROUND_VIS.shadeAlpha > 0){
        ctx.globalAlpha = GROUND_VIS.shadeAlpha;
        ctx.fillStyle = "rgba(0,0,0,1)";
        const left = worldToScreen(b.min.x, topY).x;
        const right = worldToScreen(b.max.x, topY).x;
        const width = (right - left);
        const height = worldSizeToScreen(0, hWorld).h;
        ctx.fillRect(left, sY, width, height);
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }

    // ======== TRAJECTORY (aim) ========
    function drawAimTrajectory(){
      if (!bird || birdLaunched || !draggingBird || !canLaunch) return;

      const ctx = render.context;
      const start = bird.__start;

      const pull = Vector.sub(start, bird.position);
      const dist = Math.min(Vector.magnitude(pull), SLING.pullMax);
      if (dist < 6) return;

      const dir = Vector.normalise(pull);
      const v0 = Vector.mult(dir, dist * SLING.launchK);

      const gTick = (world.gravity.y || 1) * (world.gravity.scale || 0.001) * 1000 / 60;

      let x = bird.position.x;
      let y = bird.position.y;
      let vx = v0.x;
      let vy = v0.y;

      const sA = worldToScreen(start.x, start.y);
      const sB = worldToScreen(bird.position.x, bird.position.y);

      ctx.save();
      ctx.lineWidth = 2.2;
      ctx.setLineDash([7, 8]);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.beginPath();
      ctx.moveTo(sA.x, sA.y);
      ctx.lineTo(sB.x, sB.y);
      ctx.stroke();
      ctx.setLineDash([]);

      for (let i=0; i<AIM.steps; i++){
        x += vx * AIM.stepTicks;
        y += vy * AIM.stepTicks;
        vy += gTick * AIM.stepTicks;

        if (i % AIM.dotEvery !== 0) continue;

        const p = worldToScreen(x, y);
        const a = lerp(AIM.alphaStart, AIM.alphaEnd, i / (AIM.steps - 1));

        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 225, 140, ${a})`;
        ctx.arc(p.x, p.y, AIM.dotRadius, 0, Math.PI*2);
        ctx.fill();
      }

      const sc = worldToScreen(start.x, start.y);
      const bnd = render.bounds;
      const vw = (bnd.max.x - bnd.min.x);
      const rPx = (SLING.pullMax / vw) * render.canvas.width;

      ctx.beginPath();
      ctx.lineWidth = 2.0;
      ctx.strokeStyle = "rgba(255, 225, 140, 0.18)";
      ctx.arc(sc.x, sc.y, rPx, 0, Math.PI*2);
      ctx.stroke();

      ctx.restore();
    }

    function drawChairDecal(IMGS){
      if (!chairDecal) return;
      const ctx = render.context;
      const img = IMGS.imgChair;
      const b = render.bounds;

      if (chairDecal.x < b.min.x - 500 || chairDecal.x > b.max.x + 500) return;

      const p = worldToScreen(chairDecal.x, chairDecal.y);

      const vw = (b.max.x - b.min.x);
      const sw = chairDecal.w / vw * render.canvas.width;
      const sh = chairDecal.h / (b.max.y - b.min.y) * render.canvas.height;

      ctx.save();
      ctx.drawImage(img, p.x - sw/2, p.y - sh/2, sw, sh);
      ctx.restore();
    }

    function drawSuperOverlay(){
      if (!superActive && superDim <= 0.004 && superBannerFrames <= 0) return;

      const ctx = render.context;
      const W = render.canvas.width;
      const H = render.canvas.height;

      if (superDim > 0.004){
        ctx.save();
        ctx.globalAlpha = clamp(superDim, 0, 0.80);
        ctx.fillStyle = "rgba(0,0,0,1)";
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = clamp(SUPER_VISUAL.vignette * superDim, 0, 0.60);
        const grdV = ctx.createRadialGradient(W*0.5, H*0.52, Math.min(W,H)*0.18, W*0.5, H*0.52, Math.min(W,H)*0.78);
        grdV.addColorStop(0, "rgba(0,0,0,0)");
        grdV.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = grdV;
        ctx.fillRect(0,0,W,H);
        ctx.restore();

        const pulse = 0.16 + Math.sin((superPulseT||0)*0.10)*0.07;
        ctx.save();
        ctx.globalAlpha = clamp(superAuraPulse * pulse, 0, 0.30);
        const grd = ctx.createRadialGradient(W*0.5, H*0.50, 40, W*0.5, H*0.50, Math.min(W,H)*0.62);
        grd.addColorStop(0, "rgba(255,210,70,0.70)");
        grd.addColorStop(1, "rgba(255,210,70,0.0)");
        ctx.fillStyle = grd;
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }

      if (superBannerFrames > 0){
        const t = superBannerFrames / 180;
        const alpha = clamp(0.10 + t, 0, 1);

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const big = Math.max(120, Math.min(210, Math.floor(W * 0.13)));
        ctx.font = `900 ${big}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;

        ctx.lineWidth = 16;
        ctx.strokeStyle = "rgba(0,0,0,0.68)";
        ctx.strokeText("–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!", W*0.50, H*0.22);

        ctx.shadowColor = "rgba(255,210,70,0.98)";
        ctx.shadowBlur = 34;

        ctx.fillStyle = "rgba(255,235,170,0.98)";
        ctx.fillText("–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!", W*0.50, H*0.22);

        ctx.shadowBlur = 0;
        ctx.globalAlpha = alpha * 0.16;
        const huge = Math.max(180, Math.min(320, Math.floor(W * 0.20)));
        ctx.font = `900 ${huge}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = "rgba(255,210,70,0.85)";
        ctx.fillText("–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!", W*0.50, H*0.54);

        ctx.restore();
      }
    }

    // ======== BREAK LOGIC + COLLISIONS + PHYSICS LOOP ========
    function addDebrisBody(body){
      body.__debris = true;
      body.frictionAir = DEBRIS.airFriction;
      debris.push({ body, ttl: Date.now() + DEBRIS.ttlMs, stillFrames: 0 });
      World.add(world, body);
    }

    function copyRenderMeta(srcBody, dstBody){
      dstBody.__type = srcBody.__type;
      dstBody.__tex = srcBody.__tex;
      dstBody.__sx = srcBody.__sx;
      dstBody.__sy = srcBody.__sy;
      dstBody.__breakStage = srcBody.__breakStage;
      dstBody.__broken = false;
      dstBody.__debris = true;
      dstBody.__hp = DMG.hpStage0;

      if (!DEBUG){
        dstBody.render.sprite.texture = srcBody.__tex;
        dstBody.render.sprite.xScale = srcBody.__sx;
        dstBody.render.sprite.yScale = srcBody.__sy;
      }
    }

    function makePiece(x,y,w,h,angle,srcBody){
      const piece = Bodies.rectangle(x, y, Math.max(10,w), Math.max(10,h), {
        isStatic:false,
        friction:0.95,
        restitution:0.05,
        density:0.0022,
        chamfer:{ radius:2 },
        render: DEBUG
          ? { fillStyle:"rgba(255,255,255,0.12)", strokeStyle:"rgba(255,255,255,0.5)", lineWidth:1 }
          : { sprite:{ texture: srcBody.__tex, xScale: srcBody.__sx, yScale: srcBody.__sy } }
      });
      Body.setAngle(piece, angle);
      copyRenderMeta(srcBody, piece);
      return piece;
    }

    function splitBodyByStage(body){
      if (!body) return;
      const stage = body.__breakStage || 0;

      if (body.__type === "manager" && body.__alive){
        body.__alive = false;
        stats.hits += 1;
        stats.score += 30;
        updateHUD();
        checkWin();
      }

      if (stage >= 2){
        World.remove(world, body);
        stats.broken += 1;
        stats.score += 6;
        updateHUD();
        return;
      }

      const pos = body.position;
      const angle = body.angle;
      const w = body.bounds.max.x - body.bounds.min.x;
      const h = body.bounds.max.y - body.bounds.min.y;

      const right = Vector.rotate({x:1,y:0}, angle);
      const down  = Vector.rotate({x:0,y:1}, angle);

      World.remove(world, body);

      const baseVel = body.velocity || {x:0,y:0};
      const baseAV = body.angularVelocity || 0;

      if (stage === 0){
        const splitAlongX = (w >= h);
        if (splitAlongX){
          const hw = w/2;
          const ph = h;
          const offset = w/4;

          const p1 = Vector.add(pos, Vector.mult(right, -offset));
          const p2 = Vector.add(pos, Vector.mult(right, +offset));

          const a = makePiece(p1.x, p1.y, hw*0.95, ph*0.95, angle, body);
          const b = makePiece(p2.x, p2.y, hw*0.95, ph*0.95, angle, body);

          a.__breakStage = 1; b.__breakStage = 1;
          a.__hp = DMG.hpStage1;
          b.__hp = DMG.hpStage1;

          Body.setVelocity(a, { x: baseVel.x + (Math.random()-0.5)*1.4, y: baseVel.y + (Math.random()-0.5)*1.4 });
          Body.setVelocity(b, { x: baseVel.x + (Math.random()-0.5)*1.4, y: baseVel.y + (Math.random()-0.5)*1.4 });
          Body.setAngularVelocity(a, baseAV + (Math.random()-0.5)*0.30);
          Body.setAngularVelocity(b, baseAV + (Math.random()-0.5)*0.30);

          addDebrisBody(a); addDebrisBody(b);
        } else {
          const hh = h/2;
          const pw = w;
          const offset = h/4;

          const p1 = Vector.add(pos, Vector.mult(down, -offset));
          const p2 = Vector.add(pos, Vector.mult(down, +offset));

          const a = makePiece(p1.x, p1.y, pw*0.95, hh*0.95, angle, body);
          const b = makePiece(p2.x, p2.y, pw*0.95, hh*0.95, angle, body);

          a.__breakStage = 1; b.__breakStage = 1;
          a.__hp = DMG.hpStage1;
          b.__hp = DMG.hpStage1;

          Body.setVelocity(a, { x: baseVel.x + (Math.random()-0.5)*1.4, y: baseVel.y + (Math.random()-0.5)*1.4 });
          Body.setVelocity(b, { x: baseVel.x + (Math.random()-0.5)*1.4, y: baseVel.y + (Math.random()-0.5)*1.4 });
          Body.setAngularVelocity(a, baseAV + (Math.random()-0.5)*0.30);
          Body.setAngularVelocity(b, baseAV + (Math.random()-0.5)*0.30);

          addDebrisBody(a); addDebrisBody(b);
        }

        stats.broken += 1;
        stats.score += 12;
        updateHUD();
        return;
      }

      // stage === 1 -> quarters
      const qw = w/2;
      const qh = h/2;
      const ox = w/4;
      const oy = h/4;

      const offsets = [
        Vector.add(Vector.mult(right, -ox), Vector.mult(down, -oy)),
        Vector.add(Vector.mult(right, +ox), Vector.mult(down, -oy)),
        Vector.add(Vector.mult(right, -ox), Vector.mult(down, +oy)),
        Vector.add(Vector.mult(right, +ox), Vector.mult(down, +oy))
      ];

      for (const off of offsets){
        const p = Vector.add(pos, off);
        const piece = makePiece(p.x, p.y, qw*0.92, qh*0.92, angle, body);
        piece.__breakStage = 2;
        piece.__hp = DMG.hpStage2;

        Body.setVelocity(piece, { x: baseVel.x + (Math.random()-0.5)*2.0, y: baseVel.y + (Math.random()-0.5)*2.0 });
        Body.setAngularVelocity(piece, baseAV + (Math.random()-0.5)*0.45);
        addDebrisBody(piece);
      }

      stats.broken += 1;
      stats.score += 16;
      updateHUD();
    }

    function impactEnergy(bodyA, bodyB){
      const rv = Vector.sub(bodyA.velocity, bodyB.velocity);
      const rel = Vector.magnitude(rv);
      const massRef = (bird && (bodyA === bird || bodyB === bird)) ? bird.mass : Math.min(bodyA.mass||1, bodyB.mass||1);
      return 0.5 * massRef * rel * rel;
    }

    function tryBreak(body, energy, fromBird){
      if (!body || !body.__type) return;
      if (body.isStatic) return;

      const allow = (fromBird === true) || (superActive === true);
      if (!allow) return;

      const mult = superActive ? DMG.superMultiplier : 1.0;
      const e = energy * mult;
      if (e < DMG.minHitEnergy) return;

      const dmg = e * DMG.dmgK;
      body.__hp = (typeof body.__hp === "number" ? body.__hp : DMG.hpStage0) - dmg;

      if (body.__hp > 0) return;
      splitBodyByStage(body);
    }

    function processCollisionPairs(pairs){
      if (!structure.activated) return;

      for (const pair of pairs){
        const a = pair.bodyA, b = pair.bodyB;
        const energy = impactEnergy(a, b);

        if (energy >= DMG.shakeEnergyThreshold) triggerShake(energy);

        if (bird && (a === bird || b === bird)){
          const other = (a === bird) ? b : a;
          tryBreak(other, energy, true);
        }
      }
    }

    function bindPhysics(IMGS){
      Events.on(engine, "collisionStart", (event)=>{
        processCollisionPairs(event.pairs);
      });

      Events.on(engine, "collisionActive", (event)=>{
        for (const pair of event.pairs){
          const energy = impactEnergy(pair.bodyA, pair.bodyB) * 0.12;
          if (energy >= DMG.shakeEnergyThreshold) triggerShake(energy);
        }
      });

      Events.on(engine, "beforeUpdate", ()=>{
        const baseY = window.innerHeight - LEVEL.floorHeight;

        for (let i = debris.length - 1; i >= 0; i--){
          const d = debris[i];
          const body = d.body;
          if (!body){ debris.splice(i,1); continue; }

          const sp = Vector.magnitude(body.velocity);
          d.stillFrames = (sp < DEBRIS.minSpeedToCountStill) ? (d.stillFrames + 1) : 0;

          if (Date.now() > d.ttl || d.stillFrames >= DEBRIS.stillFramesToVanish){
            World.remove(world, body);
            debris.splice(i,1);
          }
        }

        if (bird && birdLaunched){
          const v = bird.velocity;
          const speed = Math.hypot(v.x, v.y);
          if (speed > FLIGHT.maxSpeed){
            const k = FLIGHT.maxSpeed / speed;
            Body.setVelocity(bird, { x: v.x * k, y: v.y * k });
          }
          const av = bird.angularVelocity || 0;
          if (Math.abs(av) > FLIGHT.maxAngular){
            Body.setAngularVelocity(bird, Math.sign(av) * FLIGHT.maxAngular);
          }
          if (speed < 1.1){
            bird.frictionAir = lerp(bird.frictionAir, FLIGHT.settleFrictionAir, 0.06);
          }
        }

        if (shakeTime > 0){
          shakeTime -= 1;
          shakeMag = lerp(shakeMag, 0, 0.22);
        }

        if (superActive){
          superDim = lerp(superDim, SUPER_VISUAL.dimTarget, 0.10);
          superAuraPulse = lerp(superAuraPulse, 1.0, 0.10);
        } else {
          superDim = lerp(superDim, 0.0, 0.12);
          superAuraPulse = lerp(superAuraPulse, 0.0, 0.12);
        }
        if (superBannerFrames > 0) superBannerFrames -= 1;

        if (superActive && bird && birdLaunched){
          superPulseT += 1;
          setBirdSuper();

          const swing = Math.sin(superPulseT * 0.24) * 0.55;
          const targetAngle = birdSwingBaseAngle + swing;
          Body.setAngularVelocity(bird, 0);
          Body.setAngle(bird, targetAngle);

          if ((superPulseT % DMG.superAuraTickEvery) === 0){
            const bodies = Composite.allBodies(world);
            const r = DMG.superAuraRadius;
            const r2 = r*r;

            for (const obj of bodies){
              if (!obj || obj === bird) continue;
              if (!obj.__type) continue;

              const dx = obj.position.x - bird.position.x;
              const dy = obj.position.y - bird.position.y;
              const dist2 = dx*dx+dy*dy;
              if (dist2 > r2) continue;

              const t = 1 - (Math.sqrt(dist2) / r);
              const bonusEnergy = DMG.superAuraEnergyPerTick * (0.35 + 0.65*t);

              tryBreak(obj, bonusEnergy, false);

              if (!obj.isStatic){
                const dir = Vector.normalise({x:dx, y:dy});
                Body.applyForce(obj, obj.position, { x: dir.x * 0.016 * t, y: dir.y * 0.016 * t });
              }
            }
          }
        }

        if (draggingBird && !birdLaunched){
          camera.tx = camera.cx; camera.ty = camera.cy; camera.tzoom = camera.zoom;
          applyCamera(false);
          return;
        }

        const followZoom = (bird && birdLaunched) ? 1.10 : 0.86;

        let baseTx, baseTy;
        if (bird && birdLaunched){
          baseTx = bird.position.x + 280;
          baseTy = bird.position.y - 140;
        } else {
          baseTx = 900;
          baseTy = baseY - 300;
        }

        if (camera.panHoldFrames > 0){
          camera.panHoldFrames -= 1;
        } else {
          camera.panX = lerp(camera.panX, 0, 0.045);
          camera.panY = lerp(camera.panY, 0, 0.045);
          if (Math.abs(camera.panX) < 0.15) camera.panX = 0;
          if (Math.abs(camera.panY) < 0.15) camera.panY = 0;
        }

        camera.tx = baseTx + camera.panX;
        camera.ty = baseTy + camera.panY;
        camera.tzoom = followZoom * camera.userZoom;

        applyCamera(false);
        refreshSuperButtonVisibility();
      });
    }

    function checkWin(){
      const alive = structure.managers.some(m => m.__alive);
      if (!alive){
        stats.wins += 1;
        stats.score += 140;
        updateHUD();
        toast("–ü–û–ë–ï–î–ê! –í—Å–µ –º–µ–Ω–µ–¥–∂–µ—Ä—ã –≤—ã–±–∏—Ç—ã üèÜ", 1600);
      }
    }

  })();
  </script>
</body>
</html>
