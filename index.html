<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Office Birds — MVP</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b1320;
      /* ✅ фон грузим CSS'ом, не через Matter.Render.background */
      background-image: url("assets/bg_office.png");
      background-size: cover;
      background-position: center bottom;
      background-repeat: no-repeat;
    }
    canvas{ display:block; }

    .hud{
      position:fixed; left:16px; top:12px; z-index:10;
      display:flex; gap:10px; align-items:flex-start;
      pointer-events:none;
    }
    .panel{
      pointer-events:none;
      background: rgba(8,14,22,.55);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 10px 12px;
      color: rgba(255,255,255,.92);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      max-width: 360px;
    }
    .titleRow{
      display:flex; align-items:center; gap:10px; margin-bottom:6px;
      font-weight:700;
    }
    .badge{
      font-size:12px; font-weight:800;
      padding:4px 8px; border-radius:999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.14);
    }
    .btn{
      pointer-events:auto;
      cursor:pointer;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
      border-radius: 10px;
      padding: 8px 12px;
      font-weight:700;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.16); }
    .small{ font-size:12px; line-height:1.35; opacity:.92; }
    .statsRow{ display:flex; gap:12px; margin-top:6px; flex-wrap:wrap; }
    .kv{ font-size:12px; opacity:.9; }
    .kv b{ font-size:13px; opacity:1; }

    .hudRight{
      position:fixed; right:16px; top:12px; z-index:10;
      display:flex; gap:10px; align-items:flex-start;
      pointer-events:none;
    }
    .hint{
      position:fixed;
      left:50%; bottom:10px; transform:translateX(-50%);
      z-index:10;
      background: rgba(0,0,0,.42);
      color: rgba(255,255,255,.85);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      pointer-events:none;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
  </style>
</head>
<body>
  <div class="hud">
    <div class="panel">
      <div class="titleRow">
        <span class="badge">LEVEL 1</span>
        <span>Office Birds</span>
      </div>
      <div class="small">
        Зажми на человечке → потяни назад → отпусти.<br/>
        Чем сильнее натяжка, тем дальше полёт.
      </div>

      <div class="statsRow">
        <div class="kv">Счёт: <b id="score">0</b></div>
        <div class="kv">Сломано балок: <b id="broken">0</b></div>
        <div class="kv">Попыток: <b id="shots">0</b></div>
      </div>
    </div>

    <button class="btn" id="resetBtn">Reset (всё заново)</button>
  </div>

  <div class="hudRight">
    <div class="panel" style="max-width:380px;">
      <div style="font-weight:800; margin-bottom:6px;">Цель</div>
      <div class="small">
        Развали офисный домик (2 этажа).<br/>
        Внутри сидят менеджеры в наушниках.<br/>
        После выстрела идёт 2–3 сек разрушения → авто-ресpawn.<br/>
        Домик не восстанавливается (остаётся поломанным).
      </div>
      <div class="small" style="margin-top:6px;">
        Статус: <b id="status">Готов</b>
      </div>
    </div>
  </div>

  <div class="hint" id="hint">Если что-то “пропало” — проверь, что PNG лежат как в путях: assets/office/* и assets/player/*</div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    (() => {
      const {
        Engine, Render, Runner, World, Bodies, Body, Composite, Composites,
        Constraint, Mouse, MouseConstraint, Events, Sleeping, Vector
      } = Matter;

      // =========================
      // ✅ ПУТИ (под твой репо-дерево)
      // =========================
      const ASSETS = {
        beam:   "assets/office/beam.png",
        pillar: "assets/office/pillar.png",
        manager:"assets/office/manager.png",
        birdIdle:"assets/player/human_idle.png",
        birdFly:"assets/player/human_fly.png"
      };

      // =========================
      // UI
      // =========================
      const $score = document.getElementById("score");
      const $broken = document.getElementById("broken");
      const $shots = document.getElementById("shots");
      const $status = document.getElementById("status");
      const resetBtn = document.getElementById("resetBtn");

      let score = 0;
      let brokenBeams = 0;
      let shots = 0;

      function setStatus(t){ $status.textContent = t; }

      // =========================
      // Helpers: load images + fallback
      // =========================
      function loadImage(src){
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => resolve(null);
          img.src = src + "?v=" + Date.now(); // cache-bust
        });
      }

      function spriteOrFallback(body, img, w, h, fallbackColor){
        if (img) {
          body.render.sprite = {
            texture: img.src,
            xScale: w / (img.naturalWidth || w),
            yScale: h / (img.naturalHeight || h)
          };
          body.render.fillStyle = "transparent";
        } else {
          body.render.fillStyle = fallbackColor;
          body.render.strokeStyle = "rgba(255,255,255,0.25)";
          body.render.lineWidth = 2;
        }
      }

      // =========================
      // Engine / Render
      // =========================
      const engine = Engine.create();
      engine.world.gravity.y = 1.0; // ✅ вниз
      engine.world.gravity.x = 0;

      const W = () => window.innerWidth;
      const H = () => window.innerHeight;

      const render = Render.create({
        element: document.body,
        engine,
        options: {
          width: W(),
          height: H(),
          wireframes: false,
          background: "transparent",
          pixelRatio: Math.min(2, window.devicePixelRatio || 1)
        }
      });

      Render.run(render);
      const runner = Runner.create();
      Runner.run(runner, engine);

      window.addEventListener("resize", () => {
        render.canvas.width = W() * render.options.pixelRatio;
        render.canvas.height = H() * render.options.pixelRatio;
        render.options.width = W();
        render.options.height = H();
        Render.lookAt(render, {
          min: { x: 0, y: 0 },
          max: { x: W(), y: H() }
        });
      });

      // =========================
      // World bounds / floor
      // =========================
      function makeFloor(){
        // четкий пол
        const floorH = Math.max(40, Math.floor(H()*0.06));
        const floor = Bodies.rectangle(W()/2, H()-floorH/2, W(), floorH, {
          isStatic: true,
          friction: 1,
          restitution: 0,
          render: {
            fillStyle: "rgba(0,0,0,0.20)"
          }
        });

        // стены, чтобы ничего не улетало бесконечно
        const wallT = 80;
        const leftWall = Bodies.rectangle(-wallT/2, H()/2, wallT, H()*2, { isStatic:true, render:{visible:false} });
        const rightWall = Bodies.rectangle(W()+wallT/2, H()/2, wallT, H()*2, { isStatic:true, render:{visible:false} });
        const topWall = Bodies.rectangle(W()/2, -wallT/2, W()*2, wallT, { isStatic:true, render:{visible:false} });

        World.add(engine.world, [floor, leftWall, rightWall, topWall]);
        return floor;
      }

      let floorBody = makeFloor();

      // =========================
      // Game objects refs
      // =========================
      let bird = null;
      let sling = null;
      let slingAnchor = null;
      let mouseConstraint = null;

      let structureBodies = []; // beams + pillars
      let managers = [];
      let debris = [];
      let breakables = new Map(); // body.id -> {hp,maxHp,type}
      let launched = false;
      let respawnTimer = null;

      // =========================
      // Parameters (feel tuning)
      // =========================
      const params = {
        // Позиции
        birdStart: { x: 140, y: () => H() - 130 },
        slingAnchor: { x: 165, y: () => H() - 155 },

        // Ограничение натяжки
        maxPull: 115,
        power: 0.020, // чем меньше — тем слабее
        autoRespawnMs: 2700,

        // Домик — ближе к персонажу
        houseX: () => Math.max(420, Math.min(W()*0.55, 650)),
        houseYBase: () => H() - 160,

        // Размеры (два этажа)
        pillarW: 48,
        pillarH: 240,
        beamW: 360,
        beamH: 42,
        floorBeamW: 320,
        floorBeamH: 38,

        // Прочность
        beamHP: 95,
        pillarHP: 160,
        breakHitMin: 7.0 // порог силы удара
      };

      // =========================
      // Build: structure 2 floors + managers
      // =========================
      function addSleeping(body){
        // чтобы не “расползалось” до удара
        Sleeping.set(body, true);
        body.sleepThreshold = 60;
      }

      function makeBeam(x,y,w,h, imgBeam){
        const b = Bodies.rectangle(x,y,w,h,{
          friction: 0.9,
          frictionStatic: 0.9,
          restitution: 0.0,
          density: 0.0026,
          chamfer: 6
        });
        spriteOrFallback(b, imgBeam, w, h, "rgba(210,170,90,0.55)");
        addSleeping(b);

        breakables.set(b.id, { hp: params.beamHP, maxHp: params.beamHP, type:"beam" });
        structureBodies.push(b);
        return b;
      }

      function makePillar(x,y,w,h, imgPillar){
        const p = Bodies.rectangle(x,y,w,h,{
          friction: 1.0,
          frictionStatic: 1.0,
          restitution: 0.0,
          density: 0.0032,
          chamfer: 8
        });
        spriteOrFallback(p, imgPillar, w, h, "rgba(190,140,70,0.55)");
        addSleeping(p);

        breakables.set(p.id, { hp: params.pillarHP, maxHp: params.pillarHP, type:"pillar" });
        structureBodies.push(p);
        return p;
      }

      function makeManager(x,y, imgManager){
        const w = 86, h = 110;
        const m = Bodies.rectangle(x,y,w,h,{
          friction: 0.6,
          restitution: 0.0,
          density: 0.0016
        });
        spriteOrFallback(m, imgManager, w, h, "rgba(255,255,255,0.18)");
        addSleeping(m);
        managers.push(m);
        return m;
      }

      function buildHouse(imgBeam, imgPillar, imgManager){
        const hx = params.houseX();
        const baseY = params.houseYBase();

        const pillarW = params.pillarW;
        const pillarH = params.pillarH;

        const beamW = params.beamW;
        const beamH = params.beamH;

        const floorW = params.floorBeamW;
        const floorH = params.floorBeamH;

        // геометрия
        const leftPillarX = hx - beamW/2 + pillarW/2;
        const rightPillarX = hx + beamW/2 - pillarW/2;

        const pillarY = baseY - pillarH/2; // стоит на полу

        const topBeamY = baseY - pillarH + beamH/2;
        const bottomBeamY = baseY - beamH/2;

        const midBeamY = baseY - pillarH/2;          // “перекрытие” между этажами
        const upperFloorY = baseY - pillarH + 85;    // верхний “пол”/перекладина под менеджеров

        // 2 pillar
        const leftP = makePillar(leftPillarX, pillarY, pillarW, pillarH, imgPillar);
        const rightP = makePillar(rightPillarX, pillarY, pillarW, pillarH, imgPillar);

        // 2 beam сверху/снизу
        const topB = makeBeam(hx, topBeamY, beamW, beamH, imgBeam);
        const bottomB = makeBeam(hx, bottomBeamY, beamW, beamH, imgBeam);

        // “2 этажа” — перекладины
        const midB = makeBeam(hx, midBeamY, floorW, floorH, imgBeam);
        const upperB = makeBeam(hx, upperFloorY, floorW, floorH, imgBeam);

        // аккуратно размещаем менеджеров: 3 сверху, 2 снизу
        // важно: ширина этажа должна позволять менеджера — floorW достаточно.
        const topY = upperFloorY - floorH/2 - 55;
        const midY = midBeamY - floorH/2 - 55;

        const spacingTop = 95;
        const spacingMid = 115;

        const topStartX = hx - spacingTop;
        const midStartX = hx - spacingMid/2;

        const m1 = makeManager(topStartX, topY, imgManager);
        const m2 = makeManager(topStartX + spacingTop, topY, imgManager);
        const m3 = makeManager(topStartX + spacingTop*2, topY, imgManager);

        const m4 = makeManager(midStartX, midY, imgManager);
        const m5 = makeManager(midStartX + spacingMid, midY, imgManager);

        World.add(engine.world, [leftP, rightP, topB, bottomB, midB, upperB, m1, m2, m3, m4, m5]);
      }

      // =========================
      // Bird + Slingshot
      // =========================
      function makeBird(imgIdle){
        const x = params.birdStart.x;
        const y = params.birdStart.y();

        const w = 140, h = 110; // крупнее, как ты хотел
        const b = Bodies.rectangle(x, y, w, h, {
          friction: 0.6,
          restitution: 0.0,
          density: 0.0021
        });
        spriteOrFallback(b, imgIdle, w, h, "rgba(255,255,255,0.16)");

        // чтобы не “проваливался” и не дрожал
        b.sleepThreshold = 9999;
        Sleeping.set(b, true);

        return b;
      }

      function attachSlingshot(){
        slingAnchor = { x: params.slingAnchor.x, y: params.slingAnchor.y() };
        sling = Constraint.create({
          pointA: slingAnchor,
          bodyB: bird,
          stiffness: 0.055,
          damping: 0.12,
          length: 0
        });
        World.add(engine.world, sling);
      }

      function setupMouse(){
        if (mouseConstraint) {
          World.remove(engine.world, mouseConstraint);
          mouseConstraint = null;
        }

        const mouse = Mouse.create(render.canvas);
        mouse.pixelRatio = render.options.pixelRatio;

        mouseConstraint = MouseConstraint.create(engine, {
          mouse,
          constraint: {
            stiffness: 0.02,
            render: { visible: false }
          }
        });
        World.add(engine.world, mouseConstraint);

        // ограничим растягивание (пока тянем)
        Events.on(mouseConstraint, "mousemove", () => {
          if (!bird || launched) return;
          if (!mouseConstraint.body) return; // не тянем

          const mp = mouse.position;
          const dx = mp.x - slingAnchor.x;
          const dy = mp.y - slingAnchor.y;
          const dist = Math.sqrt(dx*dx + dy*dy);

          if (dist > params.maxPull) {
            const k = params.maxPull / dist;
            const nx = slingAnchor.x + dx * k;
            const ny = slingAnchor.y + dy * k;
            Body.setPosition(bird, { x: nx, y: ny });
          }
        });

        // отпуск
        Events.on(mouseConstraint, "enddrag", (e) => {
          if (!bird || launched) return;
          if (e.body !== bird) return;
          launchBird();
        });
      }

      function switchBirdSprite(imgFly){
        if (!bird) return;
        const w = 130, h = 100;
        spriteOrFallback(bird, imgFly, w, h, "rgba(255,255,255,0.16)");
      }

      function launchBird(){
        if (!bird || launched) return;

        setStatus("Пуск!");
        launched = true;
        shots++;
        $shots.textContent = shots;

        // разбудим птицу
        Sleeping.set(bird, false);
        bird.sleepThreshold = 60;

        // отсоединяем стропу
        World.remove(engine.world, sling);
        sling = null;

        // считаем импульс по натяжке
        const dx = slingAnchor.x - bird.position.x;
        const dy = slingAnchor.y - bird.position.y;
        const pull = Math.min(params.maxPull, Math.sqrt(dx*dx + dy*dy));

        // нормализуем
        const dir = Vector.normalise({ x: dx, y: dy });

        // сила
        const impulseMag = pull * params.power;
        const impulse = { x: dir.x * impulseMag, y: dir.y * impulseMag };

        // поднимем полёт чуть выше (чтобы не в пол)
        impulse.y -= 0.006;

        Body.applyForce(bird, bird.position, impulse);

        // авто-ресpawn через 2.7 сек, домик НЕ ресетим
        clearTimeout(respawnTimer);
        respawnTimer = setTimeout(() => {
          respawnBirdOnly();
        }, params.autoRespawnMs);
      }

      function respawnBirdOnly(){
        setStatus("Респавн птицы (домик остаётся поломанным)");
        // удалить старую птицу если улетела / мешает
        if (bird) World.remove(engine.world, bird);

        launched = false;

        // новая птица
        bird = makeBird(loaded.birdIdle);
        World.add(engine.world, bird);

        // вернуть стропу
        attachSlingshot();
        setupMouse();
        setStatus("Готов");
      }

      // =========================
      // Break system (ломаем балки)
      // =========================
      function spawnDebrisFrom(body, imgBeam){
        // создаем 3 обломка
        const { x, y } = body.position;
        const angle = body.angle;

        const pieces = [];
        for (let i=0;i<3;i++){
          const w = 46 + Math.random()*30;
          const h = 16 + Math.random()*14;
          const px = x + (Math.random()-0.5)*40;
          const py = y + (Math.random()-0.5)*20;

          const piece = Bodies.rectangle(px, py, w, h, {
            friction: 0.9,
            restitution: 0.0,
            density: 0.0018,
            angle: angle + (Math.random()-0.5)*0.6
          });

          // можно тем же beam.png (будет норм)
          spriteOrFallback(piece, imgBeam, w, h, "rgba(210,170,90,0.55)");
          pieces.push(piece);
          debris.push(piece);

          // чуть толкнём
          Body.applyForce(piece, piece.position, {
            x: (Math.random()-0.5)*0.005,
            y: (Math.random()-0.5)*0.005
          });
        }
        World.add(engine.world, pieces);
      }

      function damageBody(body, dmg){
        const rec = breakables.get(body.id);
        if (!rec) return;

        rec.hp -= dmg;

        if (rec.hp <= 0){
          // ломаем
          breakables.delete(body.id);

          // счет
          if (rec.type === "beam") {
            brokenBeams++;
            $broken.textContent = brokenBeams;
            score += 10;
            $score.textContent = score;
          } else if (rec.type === "pillar") {
            score += 15;
            $score.textContent = score;
          }

          // заменить на debris
          const isBeam = rec.type === "beam";
          const tex = loaded.beam;

          World.remove(engine.world, body);

          // убрать из массивов
          structureBodies = structureBodies.filter(b => b.id !== body.id);

          spawnDebrisFrom(body, tex);

          setStatus("ХРЯСЬ! (сломалось)");
        }
      }

      // collision -> считаем силу по относительной скорости
      Events.on(engine, "collisionStart", (evt) => {
        for (const pair of evt.pairs) {
          const a = pair.bodyA;
          const b = pair.bodyB;

          const aRec = breakables.get(a.id);
          const bRec = breakables.get(b.id);

          // относительная скорость
          const rvx = (a.velocity.x - b.velocity.x);
          const rvy = (a.velocity.y - b.velocity.y);
          const relSpeed = Math.sqrt(rvx*rvx + rvy*rvy);

          if (relSpeed < params.breakHitMin) continue;

          // урон
          const dmg = Math.min(40, relSpeed * 4.2);

          if (aRec) damageBody(a, dmg);
          if (bRec) damageBody(b, dmg);
        }
      });

      // =========================
      // Draw sling line (красиво)
      // =========================
      Events.on(render, "afterRender", () => {
        const ctx = render.context;
        if (!ctx) return;

        // рисуем резинку только если не запущено
        if (bird && !launched && slingAnchor) {
          ctx.save();
          ctx.lineWidth = 6;
          ctx.strokeStyle = "rgba(255,80,80,0.95)";
          ctx.beginPath();
          ctx.moveTo(slingAnchor.x, slingAnchor.y);
          ctx.lineTo(bird.position.x, bird.position.y);
          ctx.stroke();

          ctx.lineWidth = 2;
          ctx.strokeStyle = "rgba(255,255,255,0.45)";
          ctx.stroke();
          ctx.restore();
        }
      });

      // =========================
      // Reset (всё заново)
      // =========================
      function fullReset(){
        setStatus("Сброс...");

        clearTimeout(respawnTimer);
        respawnTimer = null;

        // очистить мир, но оставить стены/пол
        Composite.clear(engine.world, false);

        // пересоздать пол/стены
        floorBody = makeFloor();

        // сброс статистики
        score = 0; brokenBeams = 0; shots = 0;
        $score.textContent = "0";
        $broken.textContent = "0";
        $shots.textContent = "0";

        // очистить ссылки
        structureBodies = [];
        managers = [];
        debris = [];
        breakables.clear();

        launched = false;

        // домик + птица
        buildHouse(loaded.beam, loaded.pillar, loaded.manager);
        bird = makeBird(loaded.birdIdle);
        World.add(engine.world, bird);

        attachSlingshot();
        setupMouse();

        setStatus("Готов");
      }

      resetBtn.addEventListener("click", fullReset);

      // =========================
      // Load assets then start
      // =========================
      const loaded = {
        beam:null, pillar:null, manager:null,
        birdIdle:null, birdFly:null
      };

      async function boot(){
        setStatus("Загрузка ассетов...");

        // грузим PNG
        const [beam, pillar, manager, birdIdle, birdFly] = await Promise.all([
          loadImage(ASSETS.beam),
          loadImage(ASSETS.pillar),
          loadImage(ASSETS.manager),
          loadImage(ASSETS.birdIdle),
          loadImage(ASSETS.birdFly)
        ]);

        loaded.beam = beam;
        loaded.pillar = pillar;
        loaded.manager = manager;
        loaded.birdIdle = birdIdle;
        loaded.birdFly = birdFly;

        // подсказка в статус: если что-то не загрузилось
        const missing = [];
        if (!beam) missing.push("beam.png");
        if (!pillar) missing.push("pillar.png");
        if (!manager) missing.push("manager.png");
        if (!birdIdle) missing.push("human_idle.png");
        if (!birdFly) missing.push("human_fly.png");

        if (missing.length){
          setStatus("Часть PNG не загрузилась: " + missing.join(", ") + " (включён fallback)");
        } else {
          setStatus("Готов");
        }

        // строим дом + птица
        buildHouse(loaded.beam, loaded.pillar, loaded.manager);

        bird = makeBird(loaded.birdIdle);
        World.add(engine.world, bird);

        attachSlingshot();
        setupMouse();

        // при запуске дом не должен “поползти”
        // sleeping уже включён, но на всякий разбудим только при первом попадании
        setStatus("Готов");

        // переключаем спрайт птицы на летящий после старта движения
        Events.on(engine, "afterUpdate", () => {
          if (!bird) return;
          if (!launched) return;

          // когда скорость заметная — ставим fly
          const sp = Math.hypot(bird.velocity.x, bird.velocity.y);
          if (sp > 2.2 && !bird.__flySet){
            bird.__flySet = true;
            switchBirdSprite(loaded.birdFly);
          }

          // если птица улетела далеко — можно убрать (чтобы не копилась)
          if (bird.position.x > W() + 300 || bird.position.y > H() + 300 || bird.position.x < -300 || bird.position.y < -300){
            // ждём ресpawn таймером, но чистим старую
            World.remove(engine.world, bird);
            bird = null;
          }
        });
      }

      boot();
    })();
  </script>
</body>
</html>
