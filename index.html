<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds — Level 1</title>
  <style>
    html,body{height:100%;margin:0;background:#050914;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #ui {
      position:fixed; left:14px; top:12px; z-index:10; color:#d7f6ff;
      display:flex; gap:10px; align-items:flex-start;
    }
    .panel{
      background:rgba(20,28,40,.62);
      border:1px solid rgba(140,220,255,.18);
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      border-radius:12px; padding:10px 12px; backdrop-filter: blur(8px);
      max-width:520px;
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      font-size:12px; font-weight:700; letter-spacing:.3px;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(140,220,255,.25);
      background:rgba(0,0,0,.18)
    }
    .title{font-weight:800;margin:2px 0 6px 0;font-size:14px}
    .hint{opacity:.92;font-size:12px;line-height:1.25}
    button{
      cursor:pointer; border-radius:10px; border:1px solid rgba(140,220,255,.25);
      background:rgba(255,255,255,.06); color:#d7f6ff;
      padding:8px 12px; font-weight:700;
    }
    button:hover{background:rgba(255,255,255,.10)}
    #goal{
      position:fixed; right:14px; top:12px; z-index:10; color:#d7f6ff;
      width:320px;
    }
    #loading {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(1200px 700px at 20% 20%, rgba(0,140,255,.25), rgba(0,0,0,.65));
      z-index:20; color:#d7f6ff;
    }
    .loadbox{
      width:min(560px,92vw);
      background:rgba(10,16,26,.72);
      border:1px solid rgba(140,220,255,.18);
      border-radius:14px;
      padding:14px 16px;
      box-shadow:0 18px 45px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .bar{height:10px;border-radius:999px;background:rgba(255,255,255,.08);overflow:hidden;margin-top:10px}
    .bar > div{height:100%;width:0%;background:linear-gradient(90deg,#7efcff,#5aa8ff)}
    .small{font-size:12px;opacity:.9;margin-top:8px;line-height:1.25}
    canvas{display:block;width:100vw;height:100vh}
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div class="badge">LEVEL 1</div>
      <div class="title">Office Birds</div>
      <div class="hint">
        Зажми на <b>человечке</b> → потяни <b>назад</b> → отпусти.<br>
        Чем сильнее натяжка, тем дальше полёт.
      </div>
    </div>
    <button id="resetBtn">Reset</button>
  </div>

  <div id="goal" class="panel">
    <div class="title">Цель</div>
    <div class="hint">
      Развали офисный домик из стоек/балок/стекла/столов и мониторов.<br>
      Домик сделан “1×1” и оставляет <b>место под менеджера</b> (готово в коде).
    </div>
  </div>

  <div id="loading">
    <div class="loadbox">
      <div style="display:flex;justify-content:space-between;gap:10px;align-items:center">
        <div style="font-weight:800">Грузим офисный цирк…</div>
        <div id="pct" style="opacity:.9">0%</div>
      </div>
      <div class="bar"><div id="bar"></div></div>
      <div class="small" id="files"></div>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
  (() => {
    // ---------------------------
    // Assets (chair.png НЕ используем — чтобы не было "стул на стуле")
    // ---------------------------
    const ASSETS = {
      humanIdle: "./assets/player/human_idle.png", // человек на стуле (в одном спрайте)
      humanFly:  "./assets/player/human_fly.png",  // человек в полёте
      beam:      "./assets/office/beam.png",
      pillar:    "./assets/office/pillar.png",
      desk:      "./assets/office/desk.png",
      monitor:   "./assets/office/monitor",
      glass:     "./assets/office/glass.png",
    };

    // monitor path fix (на всякий случай, если ты назвал monitor.png)
    // если у тебя monitor.png — раскомментируй следующую строку и удали строку monitor выше:
    ASSETS.monitor = "./assets/office/monitor.png";

    // ---------------------------
    // Canvas
    // ---------------------------
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    function resize(){
      canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
      canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", () => { resize(); resetWorld(); });
    resize();

    // ---------------------------
    // Loader
    // ---------------------------
    const loadingEl = document.getElementById("loading");
    const pctEl = document.getElementById("pct");
    const barEl = document.getElementById("bar");
    const filesEl = document.getElementById("files");

    const img = {};
    const keys = Object.keys(ASSETS);

    function loadImage(key, url){
      return new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = () => reject(new Error("Failed: " + url));
        im.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    async function preload(){
      let done = 0;
      filesEl.textContent = keys.map(k => ASSETS[k]).join("   •   ");
      for (const k of keys){
        img[k] = await loadImage(k, ASSETS[k]);
        done++;
        const p = Math.round((done/keys.length)*100);
        pctEl.textContent = p + "%";
        barEl.style.width = p + "%";
      }
      loadingEl.style.display = "none";
    }

    // ---------------------------
    // Physics
    // ---------------------------
    const G = 1700;
    const AIR = 0.994;
    const RESTITUTION = 0.16;

    const world = {
      groundY: () => window.innerHeight - 18,

      // player placement (сделал ближе к центру и крупнее)
      playerX: 0,
      playerY: 0,

      // anchor point for slingshot (будет обновляться от сидячего спрайта)
      anchor: { x: 0, y: 0 },

      aiming: false,
      launched: false,
      pointer: { x: 0, y: 0 },
      pull: { x: 0, y: 0 },

      proj: null,
      parts: [],

      // manager slot (готово под добавление модели менеджера)
      managerSlot: null,
    };

    function ptInRect(px,py,r){
      return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;
    }
    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    // ---------------------------
    // Build a more "1x1" building + space for manager
    // ---------------------------
    function buildOfficeLayout(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      // gap between player and building (СИЛЬНО меньше, чем было)
      const GAP = Math.max(160, Math.min(240, W * 0.14));

      // building scale (чтобы был "квадратнее" и с запасом под менеджера)
      const scale = Math.max(1.05, Math.min(1.35, W / 1250));

      // building size target
      const BW = 520 * scale;
      const BH = 420 * scale;

      // place building near player
      const baseX = Math.min(W - BW - 40, world.playerX + 260 + GAP);
      const baseY = H - BH - 40;

      const parts = [];
      const add = (type, x,y,w,h, hp, z=0) => {
        parts.push({
          type, x,y,w,h, hp, maxHp:hp,
          vx:0, vy:0, ang:0, vang:0,
          broken:false, z
        });
      };

      // --- frame: pillars + beams (квадратнее)
      // bottom beam
      add("beam",   baseX + 40*scale, baseY + 340*scale, 440*scale, 64*scale, 260, 1);
      // mid beam
      add("beam",   baseX + 60*scale, baseY + 210*scale, 400*scale, 64*scale, 260, 1);
      // top beam/roof
      add("beam",   baseX + 80*scale, baseY +  80*scale, 360*scale, 64*scale, 260, 1);

      // pillars (4)
      add("pillar", baseX + 55*scale, baseY + 235*scale, 80*scale, 170*scale, 360, 0);
      add("pillar", baseX + 405*scale,baseY + 235*scale, 80*scale, 170*scale, 360, 0);
      add("pillar", baseX + 75*scale, baseY + 105*scale, 80*scale, 170*scale, 360, 0);
      add("pillar", baseX + 385*scale,baseY + 105*scale, 80*scale, 170*scale, 360, 0);

      // glass in the center (upper)
      add("glass",  baseX + 160*scale, baseY + 120*scale, 240*scale, 110*scale, 160, 2);

      // desks + monitors (lower floor) — оставляем центр чуть свободнее
      add("desk",   baseX + 95*scale,  baseY + 260*scale, 170*scale, 105*scale, 190, 2);
      add("monitor",baseX + 125*scale, baseY + 232*scale, 115*scale, 70*scale,  95, 3);

      add("desk",   baseX + 255*scale, baseY + 260*scale, 170*scale, 105*scale, 190, 2);
      add("monitor",baseX + 285*scale, baseY + 232*scale, 115*scale, 70*scale,  95, 3);

      // upper desks + monitors (смещаем вправо, чтобы слева был "менеджер-спот")
      add("desk",   baseX + 245*scale, baseY + 145*scale, 165*scale, 95*scale,  180, 2);
      add("monitor",baseX + 275*scale, baseY + 118*scale, 110*scale, 65*scale,   95, 3);

      // Manager platform/space (реальное место под менеджера)
      // небольшая "полка" слева сверху — менеджер будет стоять/сидеть тут
      add("beam",   baseX + 95*scale, baseY + 140*scale, 130*scale, 52*scale, 200, 1);

      // slot rect for future manager sprite (не рисуем менеджера, но место есть)
      world.managerSlot = {
        x: baseX + 110*scale,
        y: baseY + 70*scale,
        w: 110*scale,
        h: 130*scale,
        hp: 9999
      };

      return parts;
    }

    function applyHit(part, impulse){
      if (part.broken) return;
      const dmg = Math.max(10, impulse * 0.13);
      part.hp -= dmg;
      if (part.hp <= 0){
        part.broken = true;
        part.vx += (Math.random()*2-1) * 180;
        part.vy -= 160 + Math.random()*120;
        part.vang += (Math.random()*2-1) * 2.4;
      }
    }

    // ---------------------------
    // Player (сильно больше)
    // ---------------------------
    const PLAYER_SCALE = 1.75; // ← существенно больше
    function seatedRect(){
      // click area around seated sprite
      const w = 120 * PLAYER_SCALE;
      const h = 120 * PLAYER_SCALE;
      return { x: world.playerX, y: world.playerY, w, h };
    }

    function resetWorld(){
      const W = window.innerWidth;
      const H = window.innerHeight;

      world.aiming = false;
      world.launched = false;
      world.proj = null;

      // player position closer to center and higher
      world.playerX = Math.max(40, Math.min(180, W * 0.09));
      world.playerY = H - (170 * PLAYER_SCALE) - 40;

      world.parts = buildOfficeLayout();
    }

    // ---------------------------
    // Slingshot control (тянем назад -> летим вперед)
    // ---------------------------
    function startAiming(px,py){
      if (world.launched) return;
      const r = seatedRect();
      if (!ptInRect(px,py,r)) return;
      world.aiming = true;
      world.pointer.x = px;
      world.pointer.y = py;
      updatePull();
    }

    function updatePull(){
      const maxLen = 220;
      // ВАЖНО: anchor - pointer (так направление правильное)
      const dx = world.anchor.x - world.pointer.x;
      const dy = world.anchor.y - world.pointer.y;
      const len = Math.hypot(dx,dy) || 1;
      const k = Math.min(1, maxLen/len);
      world.pull.x = dx * k;
      world.pull.y = dy * k;
    }

    function release(){
      if (!world.aiming) return;
      world.aiming = false;

      const power = 8.6;
      const vx = world.pull.x * power;
      const vy = world.pull.y * power;

      world.proj = {
        x: world.anchor.x + 10,
        y: world.anchor.y - 10,
        r: 34 * PLAYER_SCALE,
        vx, vy,
        alive: true
      };
      world.launched = true;
    }

    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      const p = getPos(e);
      startAiming(p.x,p.y);
    });
    canvas.addEventListener("pointermove", (e) => {
      const p = getPos(e);
      world.pointer.x = p.x;
      world.pointer.y = p.y;
      if (world.aiming) updatePull();
    });
    canvas.addEventListener("pointerup", () => release());
    canvas.addEventListener("pointercancel", () => release());

    document.getElementById("resetBtn").addEventListener("click", resetWorld);

    // ---------------------------
    // Draw
    // ---------------------------
    function drawBackground(){
      const W = window.innerWidth, H = window.innerHeight;
      const g = ctx.createRadialGradient(W*0.2,H*0.2,50, W*0.2,H*0.2, Math.max(W,H));
      g.addColorStop(0, "rgba(30,120,200,0.26)");
      g.addColorStop(0.35, "rgba(7,18,38,0.82)");
      g.addColorStop(1, "rgba(0,0,0,0.92)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(0, world.groundY(), W, 2);
    }

    function drawImageFit(im, x,y,w,h){ ctx.drawImage(im, x,y,w,h); }

    function drawOffice(){
      const parts = [...world.parts].sort((a,b)=>a.z-b.z);
      for (const it of parts){
        const im = img[it.type];
        if (!im) continue;

        ctx.save();
        if (it.broken){
          ctx.translate(it.x + it.w/2, it.y + it.h/2);
          ctx.rotate(it.ang);
          ctx.translate(-(it.x + it.w/2), -(it.y + it.h/2));
        }
        drawImageFit(im, it.x, it.y, it.w, it.h);

        const hpRatio = Math.max(0, it.hp / it.maxHp);
        if (!it.broken && hpRatio < 0.55){
          ctx.fillStyle = `rgba(255,80,120,${(0.55-hpRatio)*0.18})`;
          ctx.fillRect(it.x, it.y, it.w, it.h);
        }
        ctx.restore();
      }

      // manager slot (место есть, но менеджера пока нет)
      if (world.managerSlot){
        ctx.save();
        ctx.globalAlpha = 0.0; // ← не показываем рамку, но слот существует
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        ctx.fillRect(world.managerSlot.x, world.managerSlot.y, world.managerSlot.w, world.managerSlot.h);
        ctx.restore();
      }
    }

    // сидячий спрайт (он уже со стулом) + качание вперед/назад
    function drawSeatedHuman(t){
      if (world.launched) return;

      const im = img.humanIdle;

      const w = 140 * PLAYER_SCALE;
      const h = 140 * PLAYER_SCALE;

      const x = world.playerX;
      const y = world.playerY;

      // качание вперед/назад (rotate around bottom)
      const rock = Math.sin(t*2.2) * 0.14;
      const bob  = Math.sin(t*3.1) * 2.4;

      ctx.save();
      ctx.translate(x + w*0.45, y + h*0.80);
      ctx.rotate(rock);
      ctx.translate(-(x + w*0.45), -(y + h*0.80));
      drawImageFit(im, x, y + bob, w, h);
      ctx.restore();

      // anchor point (где тянем/откуда летим)
      world.anchor.x = x + w*0.62;
      world.anchor.y = y + h*0.50;
    }

    function drawAimBand(){
      if (!world.aiming) return;

      const ax = world.anchor.x;
      const ay = world.anchor.y;
      const px = ax - world.pull.x;
      const py = ay - world.pull.y;

      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(120,240,255,0.20)";
      ctx.lineWidth = 12;
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(px,py); ctx.stroke();

      ctx.strokeStyle = "rgba(255,80,120,0.88)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(px,py); ctx.stroke();

      ctx.fillStyle = "rgba(120,240,255,0.12)";
      ctx.strokeStyle = "rgba(120,240,255,0.85)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(px,py,20,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }

    function drawProjectile(){
      if (!world.proj) return;
      const p = world.proj;

      const im = img.humanFly;
      const size = 150 * PLAYER_SCALE;

      ctx.save();
      const ang = Math.atan2(p.vy, p.vx);
      ctx.translate(p.x, p.y);
      ctx.rotate(ang);
      ctx.translate(-p.x, -p.y);
      drawImageFit(im, p.x - size*0.50, p.y - size*0.50, size, size);
      ctx.restore();
    }

    // ---------------------------
    // Step
    // ---------------------------
    function step(dt){
      const ground = world.groundY();

      if (world.proj){
        const p = world.proj;

        p.vy += G * dt;

        const drag = Math.pow(AIR, dt*60);
        p.vx *= drag;
        p.vy *= drag;

        p.x += p.vx * dt;
        p.y += p.vy * dt;

        // ground bounce
        if (p.y + p.r > ground){
          p.y = ground - p.r;
          p.vy = -p.vy * (0.24 + RESTITUTION);
          p.vx *= 0.72;
          if (Math.abs(p.vy) < 120) p.vy = 0;
          if (Math.abs(p.vx) < 40) p.vx = 0;
        }

        // collisions with building parts
        const projRect = { x: p.x - p.r, y: p.y - p.r, w: p.r*2, h: p.r*2 };
        for (const it of world.parts){
          const r = { x: it.x, y: it.y, w: it.w, h: it.h };
          if (!rectsOverlap(projRect, r)) continue;

          const impulse = Math.hypot(p.vx, p.vy);
          applyHit(it, impulse);

          const ox = Math.min(projRect.x+projRect.w - r.x, r.x+r.w - projRect.x);
          const oy = Math.min(projRect.y+projRect.h - r.y, r.y+r.h - projRect.y);

          if (ox < oy){
            if (p.x < it.x + it.w/2) p.x -= ox; else p.x += ox;
            p.vx = -p.vx * (0.30 + RESTITUTION);
            p.vy *= 0.92;
          } else {
            if (p.y < it.y + it.h/2) p.y -= oy; else p.y += oy;
            p.vy = -p.vy * (0.30 + RESTITUTION);
            p.vx *= 0.92;
          }

          if (it.broken){
            it.vx += p.vx * 0.02;
            it.vy += p.vy * 0.02;
          }
        }
      }

      // broken parts fall
      for (const it of world.parts){
        if (!it.broken) continue;

        it.vy += G * 0.6 * dt;
        it.x += it.vx * dt;
        it.y += it.vy * dt;
        it.ang += it.vang * dt;

        if (it.y + it.h > ground){
          it.y = ground - it.h;
          it.vy = -it.vy * 0.18;
          it.vx *= 0.75;
          it.vang *= 0.7;
          if (Math.abs(it.vy) < 60) it.vy = 0;
          if (Math.abs(it.vx) < 25) it.vx = 0;
        }
      }
    }

    // ---------------------------
    // Loop
    // ---------------------------
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      step(dt);

      drawBackground();
      drawOffice();
      drawSeatedHuman(now/1000);
      drawAimBand();
      drawProjectile();

      requestAnimationFrame(loop);
    }

    preload()
      .then(() => { resetWorld(); requestAnimationFrame(loop); })
      .catch(err => {
        console.error(err);
        alert("Ошибка загрузки PNG. Проверь пути/имена.\n\n" + err.message);
      });

  })();
  </script>
</body>
</html>
