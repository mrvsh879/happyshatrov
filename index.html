<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Office Birds ‚Äî Camera & Zoom</title>

  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#06121f; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #wrap { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; }

    .hud { position:fixed; left:16px; top:16px; z-index:10; display:flex; gap:12px; align-items:flex-start; }
    .panel { background:rgba(9,18,28,.55); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:10px 12px; color:rgba(255,255,255,.92); backdrop-filter: blur(6px); box-shadow:0 10px 30px rgba(0,0,0,.25); min-width:270px; }
    .panel h1{ font-size:14px; margin:0 0 6px 0; font-weight:900; letter-spacing:.2px; }
    .panel small{ display:block; opacity:.88; font-size:12px; line-height:1.35; }

    .btnbar{ display:flex; gap:10px; align-items:center; }
    button{ background:rgba(255,255,255,.10); color:rgba(255,255,255,.92); border:1px solid rgba(255,255,255,.16); padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:900; }
    button:hover{ background:rgba(255,255,255,.16); }

    .right{ position:fixed; top:16px; right:16px; z-index:10; width:360px; }
    .kv{ display:grid; grid-template-columns:1fr auto; gap:6px 10px; margin-top:8px; font-size:12px; opacity:.95; }
    .kv div:nth-child(2n){ font-weight:900; }

    .toast{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      z-index:10; padding:7px 12px; font-size:12px; color:rgba(255,255,255,.94);
      background:rgba(0,0,0,.44); border:1px solid rgba(255,255,255,.12);
      border-radius:999px; backdrop-filter: blur(6px);
      pointer-events:none; opacity:0; transition:opacity .18s ease;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    .toast.show{ opacity:1; }
  </style>
</head>

<body>
  <div class="hud">
    <div class="panel">
      <h1>Office Birds ‚Äî Camera/Zoom</h1>
      <small><b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</b> –∑–∞–∂–º–∏ —á–µ–ª–æ–≤–µ—á–∫–∞ ‚Üí —Ç—è–Ω–∏ <b>–≤–ª–µ–≤–æ</b> ‚Üí –æ—Ç–ø—É—Å—Ç–∏ (–ø–æ–ª–µ—Ç–∏—Ç <b>–≤–ø—Ä–∞–≤–æ</b>).</small>
      <small>–°–∏–ª–∞ = –Ω–∞—Ç—è–∂–µ–Ω–∏–µ. <b>–°—Ç—É–ª –ø–æ—è–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –±—Ä–æ—Å–∫–∞</b>.</small>
      <div class="kv">
        <div>–°—á—ë—Ç:</div><div id="score">0</div>
        <div>–°–ª–æ–º–∞–Ω–æ:</div><div id="broken">0</div>
        <div>–ü–æ–ø–∞–¥–∞–Ω–∏–π:</div><div id="hits">0</div>
        <div>–ü–æ–±–µ–¥:</div><div id="wins">0</div>
      </div>
    </div>

    <div class="btnbar">
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">DEBUG</button>
    </div>
  </div>

  <div class="right">
    <div class="panel">
      <h1>–¶–µ–ª—å</h1>
      <small>–í—ã–±–µ–π –≤—Å–µ—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ üèÜ</small>
      <small>–ö–∞–º–µ—Ä–∞ –ø–ª–∞–≤–Ω–æ —Å–ª–µ–¥–∏—Ç –∑–∞ –ø–æ–ª–µ—Ç–æ–º, –ø–æ—Ç–æ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è.</small>
      <div class="kv">
        <div>–°—Ç–∞—Ç—É—Å:</div><div id="status">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
      </div>
    </div>
  </div>

  <div id="wrap"><canvas id="c"></canvas></div>
  <div id="toast" class="toast">‚Ä¶</div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
  (function(){
    "use strict";

    const $ = (id) => document.getElementById(id);
    const toastEl = $("toast");
    function toast(msg, ms=1400){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(()=>toastEl.classList.remove("show"), ms);
    }

    function loadImage(src){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = ()=>reject(new Error("–ù–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å –∫–∞—Ä—Ç–∏–Ω–∫–∞: " + src));
        img.src = src + (src.includes("?") ? "&" : "?") + "v=" + Date.now();
      });
    }

    const ASSETS = {
      bg: "assets/bg_office.png",
      beam: "assets/office/beam.png",
      pillar: "assets/office/pillar.png",
      manager: "assets/office/manager.png",
      humanIdle: "assets/player/human_idle.png",
      humanFly: "assets/player/human_fly.png",
      chair: "assets/player/chair.png"
    };

    const {
      Engine, Render, Runner, World, Bodies, Body,
      Constraint, Mouse, MouseConstraint, Events, Composite, Query, Vector
    } = Matter;

    let engine, world, render, runner, ground;
    let mouse, mouseConstraint;

    let bird = null;
    let birdLaunched = false;
    let birdRespawnTimer = null;

    let slingshot = null;
    let slingAnchor = null;
    let draggingBird = false;
    let canLaunch = true;

    let chairAfterLaunch = null;
    let DEBUG = false;

    const structure = {
      pillars: [],
      beams: [],
      managers: [],
      activated: false
    };

    const stats = { score:0, broken:0, hits:0, wins:0 };

    const MANAGER_HIT_SPEED = 4.0;
    const BEAM_SPLIT_IMPACT = 6.6;
    const AUTO_RESPAWN_MS = 2700;

    // —Ä–∞–∑–º–µ—Ä—ã (—É–≤–µ–ª–∏—á–µ–Ω—ã)
    const SPR = {
      pillarH: 310,
      beamW: 420,
      birdRadius: 56,
      birdWIdle: 165,
      birdWFly: 135,
      managerW: 86,
      chairW: 120
    };

    // –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–æ–º–∏–∫–æ–≤
    const LEVEL = {
      floorHeight: 95,
      birdStartX: 210,
      birdStartYOffset: 190,
      houses: [
        { x: 0.56, w: 420, managers: 3 },
        { x: 0.72, w: 420, managers: 3 },
        { x: 0.88, w: 420, managers: 2 },
      ]
    };

    // –∫–∞–º–µ—Ä–∞/–∑—É–º
    const camera = {
      cx: 0, cy: 0,
      tx: 0, ty: 0,
      zoom: 1.0,
      tzoom: 1.0,
      worldMinX: -200,
      worldMaxX: 4200,
      worldMinY: -800,
      worldMaxY: 2200,
      smoothing: 0.12
    };

    function lerp(a,b,t){ return a + (b-a)*t; }
    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

    // ====== –ù–ê–°–¢–†–û–ô–ö–ò –ù–ê–¢–Ø–ñ–ï–ù–ò–Ø / –°–ò–õ–´ (–£–í–ï–õ–ò–ß–ï–ù–û) ======
    const SLING = {
      pullMax: 320,      // –±—ã–ª–æ 220 ‚Äî —Ç–µ–ø–µ—Ä—å –∫—Ä—É–≥ –Ω–∞—Ç—è–∂–µ–Ω–∏—è –±–æ–ª—å—à–µ
      launchK: 0.095     // –±—ã–ª–æ 0.070 ‚Äî —Ç–µ–ø–µ—Ä—å –±—Ä–æ—Å–æ–∫ —Å–∏–ª—å–Ω–µ–µ
    };

    $("status").textContent = "–ó–∞–≥—Ä—É–∑–∫–∞ –∞—Å—Å–µ—Ç–æ–≤‚Ä¶";

    Promise.all([
      loadImage(ASSETS.bg),
      loadImage(ASSETS.beam),
      loadImage(ASSETS.pillar),
      loadImage(ASSETS.manager),
      loadImage(ASSETS.humanIdle),
      loadImage(ASSETS.humanFly),
      loadImage(ASSETS.chair)
    ]).then(([imgBg, imgBeam, imgPillar, imgManager, imgIdle, imgFly, imgChair])=>{
      start({imgBg, imgBeam, imgPillar, imgManager, imgIdle, imgFly, imgChair});
    }).catch((e)=>{
      console.error(e);
      $("status").textContent = "–û—à–∏–±–∫–∞ PNG";
      toast("PNG –æ—à–∏–±–∫–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä—å assets/‚Ä¶", 2500);
    });

    function updateHUD(){
      $("score").textContent  = String(stats.score);
      $("broken").textContent = String(stats.broken);
      $("hits").textContent   = String(stats.hits);
      $("wins").textContent   = String(stats.wins);
    }

    function start(IMGS){
      $("status").textContent = "–ó–∞–ø—É—Å–∫‚Ä¶";

      const canvas = $("c");
      const wrap = $("wrap");

      engine = Engine.create();
      world = engine.world;
      world.gravity.y = 1.05;

      render = Render.create({
        element: wrap,
        canvas,
        engine,
        options: {
          width: window.innerWidth,
          height: window.innerHeight,
          wireframes: false,
          background: ASSETS.bg,
          pixelRatio: window.devicePixelRatio || 1,
          hasBounds: true
        }
      });

      runner = Runner.create();

      ground = Bodies.rectangle(
        2000,
        window.innerHeight - LEVEL.floorHeight/2,
        6000,
        LEVEL.floorHeight,
        {
          isStatic: true,
          friction: 1.0,
          restitution: 0.0,
          render: DEBUG ? { fillStyle:"rgba(255,255,255,0.10)" } : { fillStyle:"rgba(0,0,0,0)" }
        }
      );
      World.add(world, ground);

      mouse = Mouse.create(canvas);
      mouse.pixelRatio = render.options.pixelRatio;

      mouseConstraint = MouseConstraint.create(engine, {
        mouse,
        constraint: { stiffness: 0.00001, damping: 0.9, render: { visible:false } }
      });
      World.add(world, mouseConstraint);
      render.mouse = mouse;

      buildLevel(IMGS);
      spawnBird(IMGS);
      setupSlingshot();
      setupCameraInitial();
      bindGameplay(IMGS);

      Render.run(render);
      Runner.run(runner, engine);

      $("resetBtn").addEventListener("click", ()=>resetAll(IMGS));
      $("debugBtn").addEventListener("click", ()=>{
        DEBUG = !DEBUG;
        toast(DEBUG ? "DEBUG: ON" : "DEBUG: OFF", 900);
        resetAll(IMGS);
      });

      window.addEventListener("resize", ()=>onResize(IMGS));

      $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
      updateHUD();
    }

    function onResize(IMGS){
      render.canvas.width  = window.innerWidth;
      render.canvas.height = window.innerHeight;
      render.options.width  = window.innerWidth;
      render.options.height = window.innerHeight;
      resetAll(IMGS);
    }

    function resetAll(IMGS){
      if (birdRespawnTimer){ clearTimeout(birdRespawnTimer); birdRespawnTimer = null; }

      Composite.clear(world, false);
      World.add(world, ground);
      World.add(world, mouseConstraint);

      stats.score = 0; stats.broken = 0; stats.hits = 0; stats.wins = 0;
      updateHUD();

      structure.pillars = [];
      structure.beams = [];
      structure.managers = [];
      structure.activated = false;

      bird = null;
      slingshot = null;
      slingAnchor = null;

      if (chairAfterLaunch){
        World.remove(world, chairAfterLaunch);
        chairAfterLaunch = null;
      }

      birdLaunched = false;
      draggingBird = false;
      canLaunch = true;

      buildLevel(IMGS);
      spawnBird(IMGS);
      setupSlingshot();
      setupCameraInitial();

      $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
    }

    function buildLevel(IMGS){
      const baseY = window.innerHeight - LEVEL.floorHeight;

      structure.pillars = [];
      structure.beams = [];
      structure.managers = [];

      for (let hi=0; hi<LEVEL.houses.length; hi++){
        const H = LEVEL.houses[hi];
        const cx = Math.round(window.innerWidth * H.x);
        const w = H.w;

        const leftX  = cx - Math.round(w/2);
        const rightX = cx + Math.round(w/2);

        const pillarScale = SPR.pillarH / IMGS.imgPillar.height;
        const beamScale   = SPR.beamW   / IMGS.imgBeam.width;

        const pillarH = IMGS.imgPillar.height * pillarScale;
        const pillarW = IMGS.imgPillar.width  * pillarScale;

        const pLeft = Bodies.rectangle(leftX, baseY - pillarH/2, pillarW, pillarH, {
          isStatic: true,
          render: DEBUG
            ? { fillStyle:"rgba(0,210,255,0.20)", strokeStyle:"rgba(110,240,255,0.9)", lineWidth:2 }
            : { sprite:{ texture: ASSETS.pillar, xScale: pillarScale, yScale: pillarScale } }
        });

        const pRight = Bodies.rectangle(rightX, baseY - pillarH/2, pillarW, pillarH, {
          isStatic: true,
          render: DEBUG
            ? { fillStyle:"rgba(0,210,255,0.20)", strokeStyle:"rgba(110,240,255,0.9)", lineWidth:2 }
            : { sprite:{ texture: ASSETS.pillar, xScale: pillarScale, yScale: pillarScale } }
        });

        const beamW = IMGS.imgBeam.width  * beamScale;
        const beamH = IMGS.imgBeam.height * beamScale;

        const yBot = baseY - 46;
        const yMid = baseY - 172;
        const yTop = baseY - 298;

        function makeBeam(x,y){
          const b = Bodies.rectangle(x, y, beamW, beamH, {
            isStatic: true,
            friction: 0.95,
            restitution: 0.02,
            density: 0.0022,
            chamfer: { radius: 4 },
            render: DEBUG
              ? { fillStyle:"rgba(255,120,0,0.25)", strokeStyle:"rgba(255,170,90,0.9)", lineWidth:2 }
              : { sprite:{ texture: ASSETS.beam, xScale: beamScale, yScale: beamScale } }
          });
          b.__isBeam = true;
          b.__beamScale = beamScale;
          b.__split = false;
          return b;
        }

        const bTop = makeBeam(cx, yTop);
        const bMid = makeBeam(cx, yMid);
        const bBot = makeBeam(cx, yBot);

        const mScale = SPR.managerW / IMGS.imgManager.width;
        const mW = IMGS.imgManager.width * mScale;
        const mH = IMGS.imgManager.height * mScale;

        const managers = [];
        for (let i=0; i<H.managers; i++){
          const t = (i+1)/(H.managers+1);
          const x = cx - w*0.24 + t*(w*0.48);
          const y = yMid - beamH/2 - mH/2 + 10;

          const m = Bodies.rectangle(x, y, mW, mH, {
            isStatic: true,
            friction: 0.85,
            restitution: 0.02,
            density: 0.002,
            render: DEBUG
              ? { fillStyle:"rgba(255,255,255,0.16)", strokeStyle:"rgba(255,255,255,0.9)", lineWidth:2 }
              : { sprite:{ texture: ASSETS.manager, xScale: mScale, yScale: mScale } }
          });
          m.__isManager = true;
          m.__alive = true;
          managers.push(m);
        }

        structure.pillars.push(pLeft, pRight);
        structure.beams.push(bTop, bMid, bBot);
        structure.managers.push(...managers);

        World.add(world, [pLeft, pRight, bTop, bMid, bBot, ...managers]);
      }
    }

    function activateStructure(){
      if (structure.activated) return;
      structure.activated = true;

      for (const b of structure.beams){
        Body.setStatic(b, false);
        b.frictionAir = 0.010;
      }
      for (const m of structure.managers){
        Body.setStatic(m, false);
        m.frictionAir = 0.020;
      }
    }

    function spawnBird(IMGS){
      const baseY = window.innerHeight - LEVEL.floorHeight;
      const start = { x: LEVEL.birdStartX, y: baseY - LEVEL.birdStartYOffset };

      const idleScale = SPR.birdWIdle / IMGS.imgIdle.width;
      const flyScale  = SPR.birdWFly  / IMGS.imgFly.width;

      bird = Bodies.circle(start.x, start.y, SPR.birdRadius, {
        restitution: 0.18,
        friction: 0.95,
        frictionAir: 0.012,
        density: 0.0048,
        render: DEBUG
          ? { fillStyle:"rgba(255,0,0,0.22)", strokeStyle:"rgba(255,0,0,0.9)", lineWidth:2 }
          : { sprite:{ texture: ASSETS.humanIdle, xScale: idleScale, yScale: idleScale } }
      });

      bird.__start = start;
      bird.__flyTexture = ASSETS.humanFly;
      bird.__idleTexture = ASSETS.humanIdle;
      bird.__flyScale = flyScale;
      bird.__idleScale = idleScale;

      birdLaunched = false;
      World.add(world, bird);
    }

    function setBirdFly(){
      if (!bird || DEBUG) return;
      bird.render.sprite.texture = bird.__flyTexture;
      bird.render.sprite.xScale = bird.__flyScale;
      bird.render.sprite.yScale = bird.__flyScale;
    }
    function setBirdIdle(){
      if (!bird || DEBUG) return;
      bird.render.sprite.texture = bird.__idleTexture;
      bird.render.sprite.xScale = bird.__idleScale;
      bird.render.sprite.yScale = bird.__idleScale;
    }

    function setupSlingshot(){
      const start = bird.__start;
      slingAnchor = { x: start.x, y: start.y };

      slingshot = Constraint.create({
        pointA: { x: slingAnchor.x, y: slingAnchor.y },
        bodyB: bird,
        pointB: { x: 0, y: 0 },
        stiffness: 0.035,
        damping: 0.06,
        length: 0,
        render: { visible: DEBUG }
      });

      World.add(world, slingshot);
      slingshot.render.visible = DEBUG;
    }

    function detachSlingshot(){
      if (!slingshot) return;
      World.remove(world, slingshot);
      slingshot = null;
    }

    function spawnChairAfterLaunch(IMGS, atPos){
      if (chairAfterLaunch){
        World.remove(world, chairAfterLaunch);
        chairAfterLaunch = null;
      }

      const chairScale = SPR.chairW / IMGS.imgChair.width;
      const chairW = IMGS.imgChair.width * chairScale;
      const chairH = IMGS.imgChair.height * chairScale;

      chairAfterLaunch = Bodies.rectangle(
        atPos.x,
        atPos.y + 64,
        chairW,
        chairH,
        {
          isStatic: true,
          render: DEBUG
            ? { fillStyle:"rgba(160,160,160,0.2)", strokeStyle:"rgba(220,220,220,0.85)", lineWidth:2 }
            : { sprite:{ texture: ASSETS.chair, xScale: chairScale, yScale: chairScale } }
        }
      );
      chairAfterLaunch.__isChair = true;
      World.add(world, chairAfterLaunch);
    }

    function scheduleBirdRespawn(IMGS, delayMs){
      if (birdRespawnTimer) return;
      birdRespawnTimer = setTimeout(()=>{
        birdRespawnTimer = null;

        if (bird){
          World.remove(world, bird);
          bird = null;
        }
        if (slingshot){
          World.remove(world, slingshot);
          slingshot = null;
        }

        if (chairAfterLaunch){
          World.remove(world, chairAfterLaunch);
          chairAfterLaunch = null;
        }

        spawnBird(IMGS);
        setupSlingshot();
        setBirdIdle();

        birdLaunched = false;
        draggingBird = false;
        canLaunch = true;

        $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
      }, delayMs);
    }

    function splitBeam(beam){
      if (!beam || !beam.__isBeam || beam.__split) return;
      beam.__split = true;

      const pos = beam.position;
      const angle = beam.angle;
      const w = beam.bounds.max.x - beam.bounds.min.x;
      const h = beam.bounds.max.y - beam.bounds.min.y;

      const gap = 12;
      const w2 = Math.max(72, (w - gap) / 2);

      const dir = Vector.rotate({ x: 1, y: 0 }, angle);
      const off = Vector.mult(dir, (w2/2 + gap/2));

      const leftPos  = Vector.sub(pos, off);
      const rightPos = Vector.add(pos, off);

      function makePiece(p){
        const piece = Bodies.rectangle(p.x, p.y, w2, h, {
          isStatic: false,
          friction: 0.95,
          restitution: 0.02,
          density: 0.0022,
          chamfer: { radius: 4 },
          render: DEBUG
            ? { fillStyle:"rgba(255,120,0,0.25)", strokeStyle:"rgba(255,170,90,0.95)", lineWidth:2 }
            : { sprite:{ texture: ASSETS.beam, xScale: beam.__beamScale * (w2 / (SPR.beamW)), yScale: beam.__beamScale } }
        });
        piece.__isBeam = true;
        piece.__split = true;
        piece.__beamScale = beam.__beamScale;

        Body.setAngle(piece, angle);
        Body.setVelocity(piece, beam.velocity);
        Body.setAngularVelocity(piece, beam.angularVelocity);
        piece.frictionAir = beam.frictionAir || 0.010;
        return piece;
      }

      const p1 = makePiece(leftPos);
      const p2 = makePiece(rightPos);

      World.remove(world, beam);
      const idx = structure.beams.indexOf(beam);
      if (idx >= 0) structure.beams.splice(idx, 1);
      structure.beams.push(p1, p2);
      World.add(world, [p1, p2]);

      stats.broken += 1;
      stats.score += 15;
      updateHUD();
      toast("–ë–ê–õ–ö–ê –¢–†–ï–°–ù–£–õ–ê üí•", 900);
    }

    function checkWin(){
      const alive = structure.managers.some(m => m.__alive);
      if (!alive){
        stats.wins += 1;
        stats.score += 120;
        updateHUD();
        toast("–ü–û–ë–ï–î–ê! –í—Å–µ –º–µ–Ω–µ–¥–∂–µ—Ä—ã –≤—ã–±–∏—Ç—ã üèÜ", 1600);
      }
    }

    function setupCameraInitial(){
      const baseY = window.innerHeight - LEVEL.floorHeight;
      camera.cx = camera.tx = 900;
      camera.cy = camera.ty = baseY - 260;
      camera.zoom = camera.tzoom = 0.88;
      applyCamera(true);
    }

    function applyCamera(force=false){
      camera.cx = force ? camera.tx : lerp(camera.cx, camera.tx, camera.smoothing);
      camera.cy = force ? camera.ty : lerp(camera.cy, camera.ty, camera.smoothing);
      camera.zoom = force ? camera.tzoom : lerp(camera.zoom, camera.tzoom, camera.smoothing);

      const vw = window.innerWidth / camera.zoom;
      const vh = window.innerHeight / camera.zoom;

      let minX = camera.cx - vw/2;
      let maxX = camera.cx + vw/2;
      let minY = camera.cy - vh/2;
      let maxY = camera.cy + vh/2;

      const wWorld = camera.worldMaxX - camera.worldMinX;
      const hWorld = camera.worldMaxY - camera.worldMinY;

      if (maxX - minX > wWorld){
        minX = camera.worldMinX; maxX = camera.worldMaxX;
      } else {
        minX = clamp(minX, camera.worldMinX, camera.worldMaxX - vw);
        maxX = minX + vw;
      }

      if (maxY - minY > hWorld){
        minY = camera.worldMinY; maxY = camera.worldMaxY;
      } else {
        minY = clamp(minY, camera.worldMinY, camera.worldMaxY - vh);
        maxY = minY + vh;
      }

      render.bounds.min.x = minX;
      render.bounds.min.y = minY;
      render.bounds.max.x = maxX;
      render.bounds.max.y = maxY;

      Render.lookAt(render, { min: render.bounds.min, max: render.bounds.max });
    }

    // –∑–∞–ø—É—Å–∫ –ø–æ –Ω–∞—Ç—è–∂–µ–Ω–∏—é
    function launchBirdFromTension(){
      if (!bird || !slingAnchor) return;

      const pull = Vector.sub(slingAnchor, bird.position);
      const dist = Vector.magnitude(pull);
      const d = Math.min(dist, SLING.pullMax);

      if (d < 6) return;

      const dir = Vector.normalise(pull);
      const vel = Vector.mult(dir, d * SLING.launchK);

      Body.setVelocity(bird, vel);
      Body.setAngularVelocity(bird, 0);
      bird.frictionAir = 0.010;
    }

    function bindGameplay(IMGS){
      Events.on(mouseConstraint, "mousedown", ()=>{
        if (!bird || birdLaunched || !canLaunch) return;
        const found = Query.point([bird], mouse.position);
        if (found && found.length){
          draggingBird = true;
          $("status").textContent = "–¢—è–Ω–∏ –≤–ª–µ–≤–æ‚Ä¶";
        }
      });

      Events.on(mouseConstraint, "mousemove", ()=>{
        if (!bird || !draggingBird || birdLaunched) return;

        const start = bird.__start;
        const mp = mouse.position;

        let dx = mp.x - start.x;
        let dy = mp.y - start.y;

        if (dx > 0) dx = 0;

        const dist = Math.hypot(dx, dy) || 1;
        const k = Math.min(1, SLING.pullMax / dist);

        const px = start.x + dx * k;
        const py = start.y + dy * k;

        Body.setPosition(bird, { x: px, y: py });
        Body.setVelocity(bird, { x: 0, y: 0 });
        Body.setAngularVelocity(bird, 0);

        const tension = Math.min(1, dist / SLING.pullMax);
        camera.tzoom = 0.92 - tension * 0.10;
      });

      Events.on(mouseConstraint, "mouseup", ()=>{
        if (!bird || !draggingBird || birdLaunched) { draggingBird = false; return; }
        draggingBird = false;
        if (!canLaunch) return;

        activateStructure();
        setBirdFly();

        spawnChairAfterLaunch(IMGS, bird.__start);

        launchBirdFromTension();
        detachSlingshot();

        birdLaunched = true;
        canLaunch = false;

        stats.score += 1;
        updateHUD();
        $("status").textContent = "–ü–æ–ª–µ—Ç–µ–ª!";

        camera.tzoom = 1.08;
        scheduleBirdRespawn(IMGS, AUTO_RESPAWN_MS);
      });

      Events.on(engine, "collisionStart", (event)=>{
        if (!structure.activated) return;
        for (const pair of event.pairs){
          const a = pair.bodyA, b = pair.bodyB;

          const va = Math.hypot(a.velocity.x, a.velocity.y);
          const vb = Math.hypot(b.velocity.x, b.velocity.y);
          const impact = Math.abs(va - vb);

          if ((a.__isManager && b===bird) || (b.__isManager && a===bird)){
            const m = a.__isManager ? a : b;
            const v = bird ? Math.hypot(bird.velocity.x, bird.velocity.y) : 0;

            if (m.__alive && v > MANAGER_HIT_SPEED){
              m.__alive = false;
              stats.hits += 1;
              stats.score += 28;
              updateHUD();
              toast("–ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–µ—Ö–∞–ª üòµ", 800);
              checkWin();
            }
          }

          if (impact > BEAM_SPLIT_IMPACT){
            if (a.__isBeam) splitBeam(a);
            if (b.__isBeam) splitBeam(b);
          }
        }
      });

      Events.on(engine, "beforeUpdate", ()=>{
        const baseY = window.innerHeight - LEVEL.floorHeight;

        if (!bird){
          camera.tx = lerp(camera.tx, 900, 0.06);
          camera.ty = lerp(camera.ty, baseY - 260, 0.06);
          camera.tzoom = lerp(camera.tzoom, 0.90, 0.06);
          applyCamera(false);
          return;
        }

        if (birdLaunched){
          camera.tx = bird.position.x + 240;
          camera.ty = bird.position.y - 120;
          camera.tzoom = 1.10;

          const out =
            bird.position.x < -260 ||
            bird.position.x > camera.worldMaxX + 260 ||
            bird.position.y > window.innerHeight + 520 ||
            bird.position.y < -520;

          if (out) scheduleBirdRespawn(IMGS, 220);

          const speed = Math.hypot(bird.velocity.x, bird.velocity.y);
          if (speed < 0.35 && bird.position.y > baseY - 260){
            setBirdIdle();
            camera.tzoom = 0.98;
          }
        } else {
          camera.tx = 900;
          camera.ty = baseY - 260;
          camera.tzoom = 0.88;
        }

        applyCamera(false);
      });
    }

  })();
  </script>
</body>
</html>
