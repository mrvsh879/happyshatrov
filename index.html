<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <!-- ‚úÖ mobile + disable page zoom (we do camera zoom instead) -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Office Birds ‚Äî Destruction</title>

  <style>
    html, body {
      margin:0; padding:0; width:100%; height:100%;
      overflow:hidden; background:#050a12;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      -webkit-user-select:none; user-select:none;
      -webkit-touch-callout:none;
    }
    #wrap { position:fixed; inset:0; }
    canvas { display:block; width:100%; height:100%; touch-action:none; }

    .hud {
      position:fixed; left:16px; top:16px; z-index:10;
      display:flex; gap:12px; align-items:flex-start;
      max-width: calc(100vw - 32px);
      pointer-events:none;
    }
    .panel {
      pointer-events:auto;
      background:rgba(9,18,28,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:10px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
      backdrop-filter: blur(6px);
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      min-width:270px;
    }
    .panel h1{ font-size:14px; margin:0 0 6px 0; font-weight:900; letter-spacing:.2px; }
    .panel small{ display:block; opacity:.88; font-size:12px; line-height:1.35; }

    .btnbar{
      pointer-events:auto;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    button{
      background:rgba(255,255,255,.10);
      color:rgba(255,255,255,.92);
      border:1px solid rgba(255,255,255,.16);
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
      user-select:none;
      touch-action: manipulation;
    }
    button:hover{ background:rgba(255,255,255,.16); }
    button.super-on{
      background:rgba(255, 210, 70, .18);
      border-color:rgba(255, 210, 70, .38);
      box-shadow: 0 0 0 2px rgba(255, 210, 70, .14) inset;
    }

    .right{
      position:fixed; top:16px; right:16px; z-index:10; width:360px;
      pointer-events:none;
    }
    .right .panel{ pointer-events:auto; }

    .kv{
      display:grid; grid-template-columns:1fr auto;
      gap:6px 10px; margin-top:8px; font-size:12px; opacity:.95;
    }
    .kv div:nth-child(2n){ font-weight:900; }

    .toast{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      z-index:10; padding:7px 12px; font-size:12px; color:rgba(255,255,255,.94);
      background:rgba(0,0,0,.44); border:1px solid rgba(255,255,255,.12);
      border-radius:999px; backdrop-filter: blur(6px);
      pointer-events:none; opacity:0; transition:opacity .18s ease;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      max-width: calc(100vw - 24px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .toast.show{ opacity:1; }

    /* SUPER –∫–Ω–æ–ø–∫–∞ (–∫–∞–∫ –±—ã–ª–æ ‚Äî –±–æ–ª—å—à–∞—è) */
    .super-fly {
      position: fixed;
      left: 50%;
      bottom: 26px;
      transform: translateX(-50%);
      z-index: 20;
      display: none;
      pointer-events:auto;
    }
    .super-fly.show { display:block; }

    .super-fly button{
      font-size: 32px;
      padding: 38px 68px;
      border-radius: 28px;
      border: 3px solid rgba(255,210,70,.75);
      background: rgba(255,210,70,.18);
      box-shadow:
        0 20px 70px rgba(0,0,0,.48),
        0 0 0 5px rgba(255,210,70,.14) inset;
      letter-spacing: 1.1px;
    }
    .super-fly button:hover{ background: rgba(255,210,70,.26); }
    .super-fly button.super-on{
      background: rgba(255,210,70,.33);
      box-shadow:
        0 22px 78px rgba(0,0,0,.55),
        0 0 0 5px rgba(255,210,70,.18) inset;
    }
    .super-fly .hint{
      text-align:center;
      margin-top:10px;
      font-size:14px;
      color: rgba(255,255,255,.88);
      opacity:.92;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
      user-select:none;
      pointer-events:none;
    }

    /* ‚úÖ START MENU overlay */
    .menu {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(8px);
    }
    .menu.show { display: flex; }
    .menu-card{
      width: min(760px, calc(100vw - 40px));
      border-radius: 18px;
      padding: 24px 22px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(12,18,28,0.75);
      box-shadow: 0 30px 120px rgba(0,0,0,0.55);
      text-align: center;
      color: rgba(255,255,255,0.95);
      pointer-events:auto;
    }
    .menu-card h2{
      margin: 0 0 10px 0;
      font-size: 38px;
      letter-spacing: 0.5px;
      font-weight: 1000;
    }
    .menu-card p{
      margin: 0 auto 14px auto;
      max-width: 560px;
      opacity: .9;
      line-height: 1.45;
      font-size: 15px;
    }
    .menu-start{
      margin-top: 14px;
      font-size: 28px;
      padding: 20px 42px;
      border-radius: 18px;
      border: 2px solid rgba(255,210,70,.75);
      background: rgba(255,210,70,.20);
      box-shadow:
        0 18px 80px rgba(0,0,0,.55),
        0 0 0 6px rgba(255,210,70,.10) inset;
    }
    .menu-start:hover{ background: rgba(255,210,70,.30); }
    .menu-mini{
      margin-top: 12px;
      font-size: 12px;
      opacity: .85;
    }
    .kbd{
      display:inline-block;
      padding: 2px 7px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      font-weight: 800;
      font-size: 12px;
      margin: 0 3px;
    }

    /* ‚úÖ Mobile layout tweaks */
    @media (max-width: 820px){
      .hud{ left:10px; top:10px; flex-direction:column; gap:10px; }
      .panel{ min-width: 0; width: min(420px, calc(100vw - 20px)); }
      .right{ right:10px; top:auto; bottom:10px; width: auto; max-width: 420px; }
      .right .panel{ width: min(420px, calc(100vw - 20px)); }
      .super-fly{ bottom: 18px; }
      .super-fly button{ font-size: 28px; padding: 30px 52px; border-radius: 24px; }
      .menu-card h2{ font-size: 30px; }
      .menu-start{ font-size: 24px; padding: 18px 36px; }
      button{ padding: 12px 14px; }
    }
  </style>
</head>

<body>
  <!-- ‚úÖ START MENU -->
  <div class="menu show" id="startMenu">
    <div class="menu-card">
      <h2>OFFICE BIRDS</h2>
      <p>
        –ó–∞–∂–º–∏ —á–µ–ª–æ–≤–µ—á–∫–∞, —Ç—è–Ω–∏ –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É –∏ –æ—Ç–ø—É—Å–∫–∞–π ‚Äî –æ–Ω –ª–µ—Ç–∏—Ç –≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é.
        –í–æ –≤—Ä–µ–º—è –ø–æ–ª—ë—Ç–∞ –º–æ–∂–Ω–æ –Ω–∞–∂–∞—Ç—å <b>SUPER</b> –¥–ª—è —Ä–µ–∂–∏–º–∞ ‚Äú–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!‚Äù.
      </p>
      <p style="margin-top:10px; opacity:.85;">
        ‚úÖ <b>–ú–∞—Å—à—Ç–∞–±:</b> –∫–æ–ª–µ—Å–æ –º—ã—à–∏ –∏–ª–∏ pinch –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏.<br/>
        ‚úÖ <b>–ü–∞–Ω–æ—Ä–∞–º–∞:</b> –¥–µ—Ä–∂–∏ 2 –ø–∞–ª—å—Ü–∞ –∏ –¥–≤–∏–≥–∞–π ‚Äî –∫–∞–º–µ—Ä–∞ –ø–æ–µ–¥–µ—Ç.
      </p>
      <button class="menu-start" id="startBtn">START GAME</button>
      <div class="menu-mini">
        –ü–æ–¥—Å–∫–∞–∑–∫–∞: <span class="kbd">R</span> ‚Äî reset, <span class="kbd">D</span> ‚Äî debug, <span class="kbd">+</span>/<span class="kbd">-</span> ‚Äî zoom.
      </div>
    </div>
  </div>

  <div class="hud">
    <div class="panel">
      <h1>Office Birds ‚Äî Destruction</h1>
      <small><b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</b> –∑–∞–∂–º–∏ —á–µ–ª–æ–≤–µ—á–∫–∞ ‚Üí —Ç—è–Ω–∏ –≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É ‚Üí –æ—Ç–ø—É—Å—Ç–∏ (–ª–µ—Ç–∏—Ç –≤ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é).</small>
      <small><b>–ü—Ä–∏—Ü–µ–ª:</b> –ø—Ä–∏ –Ω–∞—Ç—è–∂–µ–Ω–∏–∏ –≤–∏–¥–Ω–æ –ø—É–Ω–∫—Ç–∏—Ä–Ω—É—é —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—é.</small>
      <small><b>–õ–æ–º–∞–Ω–∏–µ:</b> –ø–æ–ø–æ–ª–∞–º ‚Üí —á–µ—Ç–≤–µ—Ä—Ç–∏–Ω–∫–∏ ‚Üí –∏—Å—á–µ–∑–∞–µ—Ç.</small>
      <div class="kv">
        <div>–°—á—ë—Ç:</div><div id="score">0</div>
        <div>–°–ª–æ–º–∞–Ω–æ:</div><div id="broken">0</div>
        <div>–ü–æ–ø–∞–¥–∞–Ω–∏–π:</div><div id="hits">0</div>
        <div>–ü–æ–±–µ–¥:</div><div id="wins">0</div>
      </div>
    </div>

    <div class="btnbar">
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">DEBUG</button>

      <button id="zoomOutBtn">‚àí</button>
      <button id="zoomInBtn">+</button>
      <button id="zoomResetBtn">100%</button>
    </div>
  </div>

  <div class="right">
    <div class="panel">
      <h1>–¶–µ–ª—å</h1>
      <small>–í—ã–±–µ–π –≤—Å–µ—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ üèÜ</small>
      <small>–°–∏–ª—å–Ω—ã–π —É–¥–∞—Ä ‚Üí —à–µ–π–∫ –∫–∞–º–µ—Ä—ã. SUPER ‚Üí –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ + ¬´–†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!¬ª</small>
      <div class="kv">
        <div>–°—Ç–∞—Ç—É—Å:</div><div id="status">–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</div>
        <div>SUPER:</div><div id="superState">OFF</div>
        <div>ZOOM:</div><div id="zoomLabel">100%</div>
      </div>
    </div>
  </div>

  <div class="super-fly" id="superFly">
    <button id="superBtn">SUPER</button>
    <div class="hint">–ù–∞–∂–º–∏ –≤–æ –≤—Ä–µ–º—è –ø–æ–ª—ë—Ç–∞</div>
  </div>

  <div id="wrap"><canvas id="c"></canvas></div>
  <div class="toast" id="toast"></div>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

  <script>
    // ============================================================
    // Office Birds ‚Äî Destruction (single-file)
    // - slingshot reverse launch
    // - breakable beams/pillars (2-stage)
    // - managers targets + score
    // - camera follow + zoom (wheel/buttons/pinch) + pan (2-finger)
    // - SUPER mode: dim + banner + "swing" + aura damage
    // - camera shake on heavy hits
    // - ‚úÖ visible tiled ground (assets/ground/ground.png)
    // ============================================================

    const $ = (id)=>document.getElementById(id);

    // ======== ASSETS ========
    const ASSETS = {
      bg: "assets/bg_office.png",
      ground: "assets/ground/ground.png",   // ‚úÖ –í–ê–ñ–ù–û: –ø—É—Ç—å –∫–∞–∫ —É —Ç–µ–±—è –≤ —Ä–µ–ø–æ
      beam: "assets/office/beam.png",
      pillar: "assets/office/pillar.png",
      manager: "assets/office/manager.png",
      humanIdle: "assets/player/human_idle.png",
      humanFly: "assets/player/human_fly.png",
      chair: "assets/player/chair.png",
      superSkin: "assets/office/glass.png"
    };

    // ======== GAME CONSTANTS ========
    const LEVEL = {
      floorHeight: 160,
      // where the main structure starts
      structureX: 3000,
      structureY: 520
    };

    // ‚úÖ –ü–æ–ª ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
    const GROUND_VIS = {
      // —Å–∫–æ–ª—å–∫–æ "–º–∏—Ä–æ–≤—ã—Ö" –µ–¥–∏–Ω–∏—Ü –∑–∞–Ω–∏–º–∞–µ—Ç –∑–µ–º–ª—è –ø–æ –≤—ã—Å–æ—Ç–µ
      hWorld: 220,
      overlap: 2,

      // –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ (—á—Ç–æ–± –≤ —Å—Ü–µ–Ω—É –≤–ª–µ–∑–∞–ª–æ –∞–∫–∫—É—Ä–∞—Ç–Ω–æ)
      shadeAlpha: 0.10,

      // –∞–≤—Ç–æ-–∫—Ä–æ–ø –ø–æ —è—Ä–∫–æ—Å—Ç–∏: –Ω–∞–π–¥—ë—Ç –ø–æ–ª–æ—Å–∫—É –∑–µ–º–ª–∏ –≤–Ω—É—Ç—Ä–∏ 1024px –≤—ã—Å–æ—Ç—ã
      // –µ—Å–ª–∏ –∑–∞—Ö–æ—á–µ—à—å –æ—Ç–∫–ª—é—á–∏—Ç—å ‚Äî –ø–æ—Å—Ç–∞–≤—å false –∏ –±—É–¥–µ—Ç —Ä–∏—Å–æ–≤–∞—Ç—å –≤—Å—é –∫–∞—Ä—Ç–∏–Ω–∫—É
      autoCrop: true,

      // –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è "—è—Ä–∫–æ—Å—Ç—å" —Å—Ç—Ä–æ–∫–∏, —á—Ç–æ–±—ã —Å—á–∏—Ç–∞—Ç—å –µ—ë —á–∞—Å—Ç—å—é –∑–µ–º–ª–∏
      // (—É —Ç–≤–æ–µ–π —Ç–µ–∫—Å—Ç—É—Ä—ã –ø–æ–ª–æ—Å–∞ –∑–µ–º–ª–∏ —è—Ä–∫–∞—è, —Ñ–æ–Ω –ø–æ—á—Ç–∏ —á—ë—Ä–Ω—ã–π)
      cropThreshold: 18,

      // –∑–∞–ø–∞—Å —Å–≤–µ—Ä—Ö—É/—Å–Ω–∏–∑—É, —á—Ç–æ–±—ã –Ω–µ –æ–±—Ä–µ–∑–∞—Ç—å –∫—Ä–∞—è
      cropPadding: 6
    };

    const {
      Engine, Render, Runner, World, Bodies, Body,
      Constraint, Events, Composite, Vector
    } = Matter;

    let engine, world, render, runner, ground;

    let bird = null;
    let birdLaunched = false;
    let birdRespawnTimer = null;

    let slingshot = null;
    let slingAnchor = null;

    let draggingBird = false;
    let canLaunch = true;
    let dragView = null;

    let DEBUG = false;

    let chairDecal = null;

    let superActive = false;
    let superPulseT = 0;
    let superBannerFrames = 0;
    let superDim = 0;
    let superAuraPulse = 0;
    let birdSwingBaseAngle = 0;

    let shakeTime = 0;
    let shakeMag = 0;

    const debris = [];
    const structure = { pillars: [], beams: [], managers: [], activated: false };
    const stats = { score:0, broken:0, hits:0, wins:0 };

    const AUTO_RESPAWN_MS = 12000;

    const SUPER_VISUAL = { dimTarget: 0.60, vignette: 0.38 };

    const FLIGHT = {
      airFrictionFlying: 0.0032,
      maxSpeed: 52,
      maxAngular: 0.18,
      settleFrictionAir: 0.012
    };

    const DMG = {
      dmgK: 0.08,
      minHitEnergy: 1.8,
      hpStage0: 1.25,
      hpStage1: 1.10,
      hpStage2: 0.90,
      shakeEnergyThreshold: 9.0,
      shakeMax: 22,
      superMultiplier: 2.8,
      superAuraRadius: 240,
      superAuraEnergyPerTick: 12.0,
      superAuraTickEvery: 6
    };

    const DEBRIS = {
      ttlMs: 6500,
      minSpeedToCountStill: 0.18,
      stillFramesToVanish: 55,
      airFriction: 0.020,
    };

    const SPR = {
      pillarH: 330,
      beamW: 440,
      beamH: 84,
      managerW: 94,
      managerH: 106,
      chairW: 118,
      chairH: 86,
      birdW: 76,
      birdH: 76
    };

    const SLING = {
      anchor: { x: 920, y: 560 },
      restLen: 0.0001,
      stiffness: 0.012,
      damping: 0.06,
      pullMax: 220,
      launchK: 0.18
    };

    const AIM = { enabled:true, steps: 34, stepTicks: 1.0 };

    const ZOOM = { min: 0.55, max: 1.60, step: 1.12 };
    const camera = { userZoom: 1.0, target: null, pan: {x:0,y:0}, panTarget:{x:0,y:0}, panVel:{x:0,y:0} };

    let GAME_STARTED = false;

    // ======== UI helpers ========
    let toastTimer=null;
    function toast(msg, ms=1300){
      const t = $("toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>t.classList.remove("show"), ms);
    }
    function updateHUD(){
      $("score").textContent = stats.score|0;
      $("broken").textContent = stats.broken|0;
      $("hits").textContent = stats.hits|0;
      $("wins").textContent = stats.wins|0;
      $("superState").textContent = superActive ? "ON" : "OFF";
      $("zoomLabel").textContent = Math.round(camera.userZoom*100) + "%";
    }

    // ======== MENU ========
    function showMenu(){
      $("startMenu").classList.add("show");
      GAME_STARTED = false;
      if (runner) runner.enabled = false;
      $("status").textContent = "–ü–∞—É–∑–∞";
    }
    function hideMenu(){
      $("startMenu").classList.remove("show");
      GAME_STARTED = true;
      if (runner) runner.enabled = true;
      $("status").textContent = "–ò–≥—Ä–∞–µ–º";
    }
    $("startBtn").addEventListener("click", hideMenu);

    // ======== Load images ========
    function loadImage(src){
      return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = ()=>reject(new Error("Failed to load: " + src));
        img.src = src;
      });
    }

    // ======== Init ========
    $("status").textContent = "–ó–∞–≥—Ä—É–∑–∫–∞ –∞—Å—Å–µ—Ç–æ–≤‚Ä¶";

    Promise.all([
      loadImage(ASSETS.bg),
      loadImage(ASSETS.ground),   // ‚úÖ –≥—Ä—É–∑–∏–º –ø–æ–ª

      loadImage(ASSETS.beam),
      loadImage(ASSETS.pillar),
      loadImage(ASSETS.manager),
      loadImage(ASSETS.humanIdle),
      loadImage(ASSETS.humanFly),
      loadImage(ASSETS.chair),
      loadImage(ASSETS.superSkin)
    ]).then(([imgBg, imgGround, imgBeam, imgPillar, imgManager, imgIdle, imgFly, imgChair, imgSuper])=>{
      start({imgBg, imgGround, imgBeam, imgPillar, imgManager, imgIdle, imgFly, imgChair, imgSuper});
    }).catch((e)=>{
      console.error(e);
      $("status").textContent = "–û—à–∏–±–∫–∞ PNG";
      toast("PNG –æ—à–∏–±–∫–∞ ‚Äî –ø—Ä–æ–≤–µ—Ä—å assets/‚Ä¶", 2500);
    });

    // ======== BROWSER ADAPT HELPERS ========
    function dpr(){
      return Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    }
    function resizeCanvasToDisplaySize(canvas){
      const ratio = dpr();
      const w = Math.floor(window.innerWidth * ratio);
      const h = Math.floor(window.innerHeight * ratio);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
      }
    }

    // ‚úÖ –∞–≤—Ç–æ-–æ–±—Ä–µ–∑–∫–∞ ‚Äú–ø—É—Å—Ç—ã—Ö‚Äù –∑–æ–Ω —É ground.png
    function prepareGroundCrop(img){
      img.__cropY = 0;
      img.__cropH = img.height;

      if (!GROUND_VIS.autoCrop) return;

      const c = document.createElement("canvas");
      c.width = img.width;
      c.height = img.height;
      const ctx = c.getContext("2d", { willReadFrequently:true });
      ctx.drawImage(img, 0, 0);

      const data = ctx.getImageData(0, 0, img.width, img.height).data;
      const thr = GROUND_VIS.cropThreshold;
      const rowMean = new Float32Array(img.height);

      for (let y=0; y<img.height; y++){
        let sum = 0;
        let count = 0;
        const rowStart = y * img.width * 4;
        for (let x=0; x<img.width; x++){
          const i = rowStart + x*4;
          const r = data[i], g = data[i+1], b = data[i+2];
          const m = (r + g + b) / 3;
          sum += m;
          count++;
        }
        rowMean[y] = sum / Math.max(1, count);
      }

      let top = -1, bottom = -1;
      for (let y=0; y<img.height; y++){
        if (rowMean[y] > thr){ top = y; break; }
      }
      for (let y=img.height-1; y>=0; y--){
        if (rowMean[y] > thr){ bottom = y; break; }
      }

      // –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
      if (top === -1 || bottom === -1 || bottom - top < 20) return;

      const pad = GROUND_VIS.cropPadding;
      top = Math.max(0, top - pad);
      bottom = Math.min(img.height-1, bottom + pad);

      img.__cropY = top;
      img.__cropH = (bottom - top + 1);
    }

    function start(IMGS){
      $("status").textContent = "–ó–∞–ø—É—Å–∫‚Ä¶";

      // ‚úÖ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫—Ä–æ–ø–∞ –¥–ª—è –ø–æ–ª–∞
      prepareGroundCrop(IMGS.imgGround);

      const canvas = $("c");
      const wrap = $("wrap");

      engine = Engine.create();
      world = engine.world;
      world.gravity.y = 0.98;

      engine.positionIterations = 8;
      engine.velocityIterations = 7;
      engine.constraintIterations = 3;

      resizeCanvasToDisplaySize(canvas);

      render = Render.create({
        element: wrap,
        canvas,
        engine,
        options: {
          width: window.innerWidth,
          height: window.innerHeight,
          wireframes: false,

          // ‚úÖ –í–ê–ñ–ù–û: –¥–µ–ª–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º, —á—Ç–æ–±—ã Matter –Ω–µ ‚Äú–∑–∞—Ç–∏—Ä–∞–ª‚Äù –Ω–∞—à –ø–æ–ª
          background: "transparent",

          pixelRatio: dpr(),
          hasBounds: true
        }
      });

      runner = Runner.create();

      ground = Bodies.rectangle(
        2600,
        window.innerHeight - LEVEL.floorHeight/2,
        9000,
        LEVEL.floorHeight,
        { isStatic:true, friction:1.0, restitution:0.0,
          render: DEBUG ? { fillStyle:"rgba(255,255,255,0.10)" } : { fillStyle:"rgba(0,0,0,0)" } }
      );
      World.add(world, ground);

      buildLevel(IMGS);
      spawnBird(IMGS);
      setupSlingshot();
      setupCameraInitial();
      bindInput(IMGS);
      bindPhysics(IMGS);

      Events.on(render, "afterRender", ()=>{
        const ctx = render.context;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // ‚úÖ –†–∏—Å—É–µ–º –§–û–ù + –ü–û–õ ‚Äú–°–ù–ò–ó–£‚Äù, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å –æ—Å—Ç–∞–ª—å–Ω–æ–π —Ä–µ–Ω–¥–µ—Ä
        // destination-over = —Ä–∏—Å—É–µ—Ç –ø–æ–∑–∞–¥–∏ —É–∂–µ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã—Ö —Ç–µ–ª
        ctx.globalCompositeOperation = "destination-over";
        // ‚úÖ –°–Ω–∞—á–∞–ª–∞ —Ä–∏—Å—É–µ–º –ü–û–õ, –ø–æ—Ç–æ–º –§–û–ù.
        // –¢–∞–∫ –ø–æ–ª –æ–∫–∞–∂–µ—Ç—Å—è –ù–ê–î —Ñ–æ–Ω–æ–º, –Ω–æ –ü–û–î —Ñ–∏–∑–∏—á–µ—Å–∫–∏–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏.
        drawGround(IMGS);
        ctx.drawImage(IMGS.imgBg, 0, 0, render.canvas.width, render.canvas.height);
        ctx.globalCompositeOperation = "source-over";

        // ---- –¥–∞–ª—å—à–µ –≤—Å—ë –∫–∞–∫ –±—ã–ª–æ (–ù–ò–ß–ï–ì–û –ù–ï –í–´–ö–ò–ù–£–¢–û) ----
        if (AIM.enabled) drawAimTrajectory();
        if (chairDecal) drawChairDecal(IMGS);
        drawSuperOverlay();

        ctx.restore();
      });

      Render.run(render);
      Runner.run(runner, engine);

      // ‚úÖ Start paused (menu shown)
      runner.enabled = false;

      $("resetBtn").addEventListener("click", ()=>{ resetAll(IMGS); showMenu(); });
      $("debugBtn").addEventListener("click", ()=>{
        DEBUG = !DEBUG;
        toast(DEBUG ? "DEBUG: ON" : "DEBUG: OFF", 900);
        resetAll(IMGS);
        if (!GAME_STARTED) showMenu();
      });

      // ‚úÖ wheel zoom (desktop)
      canvas.addEventListener("wheel", (e)=>{
        e.preventDefault();
        const dir = Math.sign(e.deltaY);
        if (dir > 0) setUserZoom(camera.userZoom / ZOOM.step, false);
        else setUserZoom(camera.userZoom * ZOOM.step, false);
      }, { passive:false });

      // ‚úÖ keyboard shortcuts
      window.addEventListener("keydown", (e)=>{
        if (e.key === "r" || e.key === "R"){ resetAll(IMGS); showMenu(); }
        if (e.key === "d" || e.key === "D"){ DEBUG = !DEBUG; toast(DEBUG ? "DEBUG: ON" : "DEBUG: OFF", 900); resetAll(IMGS); if (!GAME_STARTED) showMenu(); }
        if (e.key === "+" || e.key === "="){ setUserZoom(camera.userZoom * ZOOM.step); }
        if (e.key === "-" || e.key === "_"){ setUserZoom(camera.userZoom / ZOOM.step); }
        if ((e.key === "Enter" || e.key === " ") && !GAME_STARTED){ hideMenu(); }
      });

      window.addEventListener("resize", ()=>onResize(IMGS));

      $("status").textContent = "–ì–æ—Ç–æ–≤–æ";
      setUserZoom(1.0, false);
      updateHUD();

      showMenu();
    }

    function onResize(IMGS){
      resizeCanvasToDisplaySize(render.canvas);
      render.options.pixelRatio = dpr();
      render.options.width = window.innerWidth;
      render.options.height = window.innerHeight;

      // ‚úÖ –ø–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å –∫—Ä–æ–ø –ø–æ–ª–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ —Ä–∞–∑–º–µ—Ä–æ–≤ (–±–µ–∑ –≤–ª–∏—è–Ω–∏—è –Ω–∞ –º–µ—Ö–∞–Ω–∏–∫—É)
      prepareGroundCrop(IMGS.imgGround);

      resetAll(IMGS);
      if (!GAME_STARTED) showMenu();
    }

    function resetAll(IMGS){
      if (birdRespawnTimer){ clearTimeout(birdRespawnTimer); birdRespawnTimer = null; }

      Composite.clear(world, false);
      World.add(world, ground);

      debris.length = 0;
      structure.pillars.length = 0;
      structure.beams.length = 0;
      structure.managers.length = 0;
      structure.activated = false;

      chairDecal = null;

      superActive = false;
      superPulseT = 0;
      superBannerFrames = 0;
      superDim = 0;
      superAuraPulse = 0;
      birdSwingBaseAngle = 0;

      shakeTime = 0;
      shakeMag = 0;

      bird = null;
      birdLaunched = false;

      buildLevel(IMGS);
      spawnBird(IMGS);
      setupSlingshot();
      setupCameraInitial();
      updateHUD();
      toast("Reset", 850);
    }

    // ======== CAMERA ========
    function applyCamera(){
      if (!render) return;

      if (camera.target && bird){
        camera.target.x = bird.position.x;
        camera.target.y = bird.position.y;
      }

      // smooth pan (2-finger)
      camera.panVel.x += (camera.panTarget.x - camera.pan.x) * 0.18;
      camera.panVel.y += (camera.panTarget.y - camera.pan.y) * 0.18;
      camera.panVel.x *= 0.78;
      camera.panVel.y *= 0.78;
      camera.pan.x += camera.panVel.x;
      camera.pan.y += camera.panVel.y;

      const focus = camera.target || {x:1400,y:600};
      const cx = focus.x + camera.pan.x;
      const cy = focus.y + camera.pan.y;

      const zoom = camera.userZoom;

      const vw = window.innerWidth / zoom;
      const vh = window.innerHeight / zoom;

      // Shake offsets
      let sx = 0, sy = 0;
      if (shakeTime > 0){
        const t = shakeTime;
        sx = (Math.random()*2 - 1) * shakeMag;
        sy = (Math.random()*2 - 1) * shakeMag;
        shakeTime = Math.max(0, shakeTime - 1);
        shakeMag *= 0.92;
      }

      render.bounds.min.x = cx - vw/2 + sx;
      render.bounds.max.x = cx + vw/2 + sx;
      render.bounds.min.y = cy - vh/2 + sy;
      render.bounds.max.y = cy + vh/2 + sy;

      Render.lookAt(render, {
        min: render.bounds.min,
        max: render.bounds.max
      });
    }

    function setupCameraInitial(){
      camera.target = null;
      camera.pan.x = 0; camera.pan.y = 0;
      camera.panTarget.x = 0; camera.panTarget.y = 0;
      camera.panVel.x = 0; camera.panVel.y = 0;

      const focus = { x: 1700, y: 520 };
      camera.target = focus;
      applyCamera();
    }

    function setUserZoom(val, toastMsg=true){
      camera.userZoom = Math.max(ZOOM.min, Math.min(ZOOM.max, val));
      updateHUD();
      if (toastMsg) toast("ZOOM: " + Math.round(camera.userZoom*100) + "%", 650);
    }

    // ‚úÖ Zoom buttons
    $("zoomInBtn").addEventListener("click", ()=> setUserZoom(camera.userZoom * ZOOM.step));
    $("zoomOutBtn").addEventListener("click", ()=> setUserZoom(camera.userZoom / ZOOM.step));
    $("zoomResetBtn").addEventListener("click", ()=> setUserZoom(1.0));

    // ======== BUILD LEVEL ========
    function buildLevel(IMGS){
      // place several beams and pillars as one big structure
      const baseX = LEVEL.structureX;
      const baseY = LEVEL.structureY;

      // helper to create a beam/pillar with breakable hp
      function makePart(type, x, y, w, h, angle=0){
        const body = Bodies.rectangle(x, y, w, h, {
          friction: 0.92,
          restitution: 0.02,
          density: 0.0025,
          render: {
            sprite: {
              texture: type === "beam" ? ASSETS.beam : ASSETS.pillar,
              xScale: type === "beam" ? (w / SPR.beamW) : (w / 120),
              yScale: type === "beam" ? (h / SPR.beamH) : (h / SPR.pillarH)
            }
          }
        });
        Body.setAngle(body, angle);
        body.__type = type;
        body.__hp = DMG.hpStage0; // start stage
        body.__stage = 0;         // 0 = intact, 1 = cracked, 2 = broken
        body.__lastHit = 0;
        return body;
      }

      function makeManager(x,y){
        const b = Bodies.rectangle(x, y, SPR.managerW, SPR.managerH, {
          friction: 0.8,
          restitution: 0.05,
          density: 0.0016,
          render: {
            sprite: {
              texture: ASSETS.manager,
              xScale: 1,
              yScale: 1
            }
          }
        });
        b.__type = "manager";
        b.__alive = true;
        b.__hitFrames = 0;
        return b;
      }

      const bodies = [];

      // base platform
      bodies.push(makePart("beam", baseX+360, baseY+260, 1100, 84, 0));
      bodies.push(makePart("beam", baseX+1080, baseY+260, 1100, 84, 0));

      // pillars
      bodies.push(makePart("pillar", baseX+200, baseY+100, 120, 330, 0));
      bodies.push(makePart("pillar", baseX+520, baseY+100, 120, 330, 0));
      bodies.push(makePart("pillar", baseX+880, baseY+100, 120, 330, 0));
      bodies.push(makePart("pillar", baseX+1220, baseY+100, 120, 330, 0));

      // mid beams
      bodies.push(makePart("beam", baseX+360, baseY-20, 820, 84, 0));
      bodies.push(makePart("beam", baseX+1080, baseY-20, 820, 84, 0));

      // top beams
      bodies.push(makePart("beam", baseX+660, baseY-260, 920, 84, -0.18));
      bodies.push(makePart("beam", baseX+1220, baseY-290, 820, 84, 0.12));

      // some extra slanted
      bodies.push(makePart("beam", baseX+1440, baseY-180, 760, 84, -0.42));
      bodies.push(makePart("beam", baseX+300, baseY-220, 760, 84, 0.38));

      // managers placed on top surfaces
      const managers = [
        makeManager(baseX+260, baseY-80),
        makeManager(baseX+420, baseY-80),
        makeManager(baseX+780, baseY-80),
        makeManager(baseX+980, baseY-80),
        makeManager(baseX+1280, baseY-80),
        makeManager(baseX+1500, baseY-80),

        makeManager(baseX+520, baseY-320),
        makeManager(baseX+860, baseY-340),
        makeManager(baseX+1180, baseY-360),
        makeManager(baseX+1420, baseY-300),
      ];

      managers.forEach(m=>bodies.push(m));

      // register in structure arrays
      bodies.forEach(b=>{
        if (b.__type === "pillar") structure.pillars.push(b);
        if (b.__type === "beam") structure.beams.push(b);
        if (b.__type === "manager") structure.managers.push(b);
      });

      World.add(world, bodies);
      structure.activated = true;
    }

    // ======== SPAWN BIRD ========
    function spawnBird(IMGS){
      birdLaunched = false;
      draggingBird = false;
      canLaunch = true;

      // composite: chair + human (idle)
      bird = Bodies.circle(SLING.anchor.x, SLING.anchor.y, 28, {
        friction: 0.15,
        restitution: 0.25,
        density: 0.0016,
        frictionAir: FLIGHT.settleFrictionAir,
        render: { fillStyle: "rgba(0,0,0,0)" }
      });

      bird.__start = { x: SLING.anchor.x, y: SLING.anchor.y };
      bird.__state = "idle"; // idle/fly
      bird.__imgIdle = IMGS.imgIdle;
      bird.__imgFly = IMGS.imgFly;
      bird.__imgChair = IMGS.imgChair;
      bird.__angle = 0;
      bird.__lastPos = { x: bird.position.x, y: bird.position.y };

      World.add(world, bird);
      camera.target = bird.position;

      updateSuperButton();
    }

    // ======== SLINGSHOT ========
    function setupSlingshot(){
      slingAnchor = Bodies.circle(SLING.anchor.x, SLING.anchor.y, 6, { isStatic:true, render:{ visible:false } });
      World.add(world, slingAnchor);

      slingshot = Constraint.create({
        bodyA: bird,
        pointB: { x: SLING.anchor.x, y: SLING.anchor.y },
        length: SLING.restLen,
        stiffness: SLING.stiffness,
        damping: SLING.damping
      });
      World.add(world, slingshot);
    }

    function releaseBird(){
      if (!bird || !canLaunch) return;

      const pull = Vector.sub(bird.__start, bird.position);
      const dist = Math.min(Vector.magnitude(pull), SLING.pullMax);
      if (dist < 10){
        // no launch, just snap back
        Body.setPosition(bird, bird.__start);
        Body.setVelocity(bird, {x:0,y:0});
        return;
      }

      const dir = Vector.normalise(pull);
      const vel = Vector.mult(dir, dist * SLING.launchK);

      // reverse launch: bird goes opposite of pull
      Body.setVelocity(bird, { x: -vel.x, y: -vel.y });
      bird.frictionAir = FLIGHT.airFrictionFlying;
      birdLaunched = true;
      bird.__state = "fly";
      superBannerFrames = 0;
      updateSuperButton();

      // remove constraint so it doesn't yank back
      World.remove(world, slingshot);
      slingshot = null;

      // auto respawn in case it flies away
      if (birdRespawnTimer) clearTimeout(birdRespawnTimer);
      birdRespawnTimer = setTimeout(()=>{
        if (birdLaunched) {
          toast("–í–æ–∑–≤—Ä–∞—Ç‚Ä¶", 900);
          respawnBird();
        }
      }, AUTO_RESPAWN_MS);
    }

    function respawnBird(){
      if (!bird) return;

      // remove old
      try { World.remove(world, bird); } catch(e){}
      bird = null;

      // restore constraint anchor too
      if (slingshot) { try { World.remove(world, slingshot); } catch(e){} }
      slingshot = null;
      if (slingAnchor) { try { World.remove(world, slingAnchor); } catch(e){} }
      slingAnchor = null;

      spawnBird({
        imgIdle: bird ? bird.__imgIdle : null,
        imgFly: bird ? bird.__imgFly : null,
        imgChair: bird ? bird.__imgChair : null
      });

      // reattach
      setupSlingshot();
      setupCameraInitial();

      superActive = false;
      updateSuperButton();
    }

    // ======== INPUT (mouse/touch/pointer) ========
    function bindInput(IMGS){
      const canvas = render.canvas;

      // Pointer events: supports mouse + touch, plus multi-touch
      const pointers = new Map();
      let pinchStart = null;

      function clientToWorld(cx, cy){
        // convert screen (css px) to world by using render.bounds
        const b = render.bounds;
        const x = b.min.x + (cx / window.innerWidth) * (b.max.x - b.min.x);
        const y = b.min.y + (cy / window.innerHeight) * (b.max.y - b.min.y);
        return {x,y};
      }

      function startPinchIfPossible(){
        if (pointers.size !== 2) return;
        const pts = Array.from(pointers.values());
        const dx = pts[1].x - pts[0].x;
        const dy = pts[1].y - pts[0].y;
        const dist = Math.hypot(dx,dy);
        const mid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
        pinchStart = {
          dist,
          zoom: camera.userZoom,
          mid,
          panStart: { x: camera.panTarget.x, y: camera.panTarget.y }
        };
      }

      function updatePinchAndPan(){
        if (!pinchStart || pointers.size !== 2) return;
        const pts = Array.from(pointers.values());
        const dx = pts[1].x - pts[0].x;
        const dy = pts[1].y - pts[0].y;
        const dist = Math.hypot(dx,dy);
        const mid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };

        const ratio = dist / Math.max(1, pinchStart.dist);
        setUserZoom(pinchStart.zoom * ratio, false);

        // two-finger pan
        const mdx = (mid.x - pinchStart.mid.x);
        const mdy = (mid.y - pinchStart.mid.y);
        // map screen px movement to world units (approx)
        const b = render.bounds;
        const worldPerPxX = (b.max.x - b.min.x) / window.innerWidth;
        const worldPerPxY = (b.max.y - b.min.y) / window.innerHeight;
        camera.panTarget.x = pinchStart.panStart.x - mdx * worldPerPxX;
        camera.panTarget.y = pinchStart.panStart.y - mdy * worldPerPxY;
      }

      function endPinchIfNeeded(){
        pinchStart = null;
      }

      function onDown(cx, cy, capture){
        if (!bird || birdLaunched) return;

        const p = clientToWorld(cx, cy);
        const d = Vector.magnitude(Vector.sub(p, bird.position));
        if (d < 80){
          draggingBird = true;
          dragView = {x:cx, y:cy};
          if (capture) capture();
        }
      }

      function onMove(cx, cy){
        if (!draggingBird || !bird || birdLaunched) return;

        const p = clientToWorld(cx, cy);

        const pull = Vector.sub(p, bird.__start);
        const dist = Math.min(Vector.magnitude(pull), SLING.pullMax);
        const dir = Vector.normalise(pull);
        const clamped = Vector.add(bird.__start, Vector.mult(dir, dist));

        Body.setPosition(bird, clamped);
        Body.setVelocity(bird, {x:0,y:0});
      }

      function onUp(IMGS){
        if (!draggingBird) return;
        draggingBird = false;
        releaseBird();
      }

      // pointer listeners
      canvas.addEventListener("pointerdown", (e)=>{
        pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        if (pointers.size === 2){
          startPinchIfPossible();
        } else {
          onDown(e.clientX, e.clientY, ()=>canvas.setPointerCapture(e.pointerId));
        }
      });

      canvas.addEventListener("pointermove", (e)=>{
        if (pointers.has(e.pointerId)) pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
        if (pointers.size === 2){
          updatePinchAndPan();
        } else {
          onMove(e.clientX, e.clientY);
        }
      });

      canvas.addEventListener("pointerup", (e)=>{
        pointers.delete(e.pointerId);
        endPinchIfNeeded();
        onUp(IMGS);
      });

      canvas.addEventListener("pointercancel", (e)=>{
        pointers.delete(e.pointerId);
        endPinchIfNeeded();
        onUp(IMGS);
      });

      return;
    }

    // ======== PHYSICS EVENTS ========
    function bindPhysics(IMGS){
      Events.on(engine, "beforeUpdate", ()=>{
        if (!render) return;
        applyCamera();
        tickSuper();
        tickDebris();
        updateSuperButton();
      });

      Events.on(engine, "collisionStart", (ev)=>{
        if (!ev.pairs) return;
        ev.pairs.forEach(pair=>{
          const a = pair.bodyA;
          const b = pair.bodyB;
          processHit(a, b);
          processHit(b, a);
        });
      });
    }

    // ======== COLLISION / DAMAGE ========
    function processHit(victim, other){
      if (!victim || !other) return;
      if (!victim.__type) return;

      // approximate impact energy
      const rv = Vector.sub(victim.velocity, other.velocity || {x:0,y:0});
      const speed = Vector.magnitude(rv);
      const energy = speed * (victim.mass || 1) * 0.5;

      if (energy < DMG.minHitEnergy) return;

      // camera shake on heavy energy
      if (energy > DMG.shakeEnergyThreshold){
        const m = Math.min(DMG.shakeMax, (energy - DMG.shakeEnergyThreshold) * 1.2);
        shakeTime = Math.max(shakeTime, 10);
        shakeMag = Math.max(shakeMag, m);
      }

      if (victim.__type === "manager"){
        if (!victim.__alive) return;
        stats.hits += 1;
        stats.score += Math.min(250, Math.round(energy * 18));
        victim.__hitFrames = 20;

        // kill if strong enough
        if (energy > 6.5){
          victim.__alive = false;
          stats.score += 600;
          toast("–ú–µ–Ω–µ–¥–∂–µ—Ä –≤—ã–±–∏—Ç! üí•", 900);
          World.remove(world, victim);
          checkWin();
        }
        updateHUD();
        return;
      }

      // beams/pillars
      if (victim.__type === "beam" || victim.__type === "pillar"){
        const now = engine.timing.timestamp || performance.now();
        if (now - (victim.__lastHit||0) < 90) return;
        victim.__lastHit = now;

        const mult = superActive ? DMG.superMultiplier : 1.0;
        const dmg = energy * DMG.dmgK * mult;

        victim.__hp -= dmg;

        if (victim.__stage === 0 && victim.__hp <= DMG.hpStage1){
          victim.__stage = 1;
          // change sprite slightly (use superSkin texture as cracked overlay trick)
          victim.render.sprite.texture = ASSETS.superSkin;
          toast("–¢—Ä–µ—Å–∫! ‚ö°", 550);
          stats.broken += 1;
          updateHUD();
        }

        if (victim.__stage <= 1 && victim.__hp <= DMG.hpStage2){
          victim.__stage = 2;
          // break into two debris pieces
          breakBody(victim);
          stats.broken += 2;
          stats.score += 120;
          updateHUD();
        }
      }
    }

    function breakBody(body){
      if (!body) return;
      const { x, y } = body.position;
      const angle = body.angle;
      const w = body.bounds.max.x - body.bounds.min.x;
      const h = body.bounds.max.y - body.bounds.min.y;

      World.remove(world, body);

      const isBeam = body.__type === "beam";
      const tex = isBeam ? ASSETS.beam : ASSETS.pillar;

      // two chunks
      const a = Bodies.rectangle(x - Math.cos(angle)*w*0.15, y - Math.sin(angle)*w*0.15, w*0.55, h*0.92, {
        friction: 0.9, restitution: 0.02, density: 0.0023, frictionAir: DEBRIS.airFriction,
        render: { sprite: { texture: tex, xScale: isBeam ? ((w*0.55)/SPR.beamW) : ((w*0.55)/120),
                             yScale: isBeam ? ((h*0.92)/SPR.beamH) : ((h*0.92)/SPR.pillarH) } }
      });
      const c = Bodies.rectangle(x + Math.cos(angle)*w*0.15, y + Math.sin(angle)*w*0.15, w*0.55, h*0.92, {
        friction: 0.9, restitution: 0.02, density: 0.0023, frictionAir: DEBRIS.airFriction,
        render: { sprite: { texture: tex, xScale: isBeam ? ((w*0.55)/SPR.beamW) : ((w*0.55)/120),
                             yScale: isBeam ? ((h*0.92)/SPR.beamH) : ((h*0.92)/SPR.pillarH) } }
      });
      Body.setAngle(a, angle);
      Body.setAngle(c, angle);

      // inherit velocity a bit
      Body.setVelocity(a, body.velocity);
      Body.setVelocity(c, body.velocity);
      Body.setAngularVelocity(a, body.angularVelocity);
      Body.setAngularVelocity(c, body.angularVelocity);

      a.__type = "debris";
      c.__type = "debris";
      a.__born = performance.now();
      c.__born = performance.now();
      a.__still = 0;
      c.__still = 0;

      debris.push(a, c);
      World.add(world, [a,c]);
    }

    function checkWin(){
      const alive = structure.managers.filter(m=>m.__alive);
      if (alive.length === 0){
        stats.wins += 1;
        toast("–ü–û–ë–ï–î–ê! üèÜ", 1300);
        $("status").textContent = "–ü–æ–±–µ–¥–∞";
        updateHUD();
      }
    }

    // ======== DEBRIS cleanup ========
    function tickDebris(){
      const now = performance.now();
      for (let i=debris.length-1; i>=0; i--){
        const d = debris[i];
        if (!d || !d.position){ debris.splice(i,1); continue; }

        const speed = Vector.magnitude(d.velocity);
        if (speed < DEBRIS.minSpeedToCountStill){
          d.__still = (d.__still||0) + 1;
        } else {
          d.__still = 0;
        }

        const age = now - (d.__born||now);

        if (age > DEBRIS.ttlMs || d.__still > DEBRIS.stillFramesToVanish){
          try { World.remove(world, d); } catch(e){}
          debris.splice(i,1);
        }
      }
    }

    // ======== SUPER MODE ========
    function updateSuperButton(){
      const fly = $("superFly");
      const btn = $("superBtn");

      const show = birdLaunched && bird && (bird.__state === "fly");
      fly.classList.toggle("show", show);

      btn.classList.toggle("super-on", superActive);
      $("superState").textContent = superActive ? "ON" : "OFF";
    }

    $("superBtn").addEventListener("click", ()=>{
      if (!birdLaunched) return;
      toggleSuper();
    });

    function toggleSuper(){
      superActive = !superActive;
      superBannerFrames = superActive ? 60 : 0;
      toast(superActive ? "SUPER: –†–∞—Å–∫–∞—á–∞–µ–º—Å—è!!!" : "SUPER: OFF", 900);
      updateHUD();

      if (bird && superActive){
        birdSwingBaseAngle = bird.angle;
      }
    }

    function tickSuper(){
      // dim smooth
      const target = superActive ? SUPER_VISUAL.dimTarget : 0;
      superDim += (target - superDim) * 0.12;

      if (superActive){
        superPulseT += 0.11;
        superAuraPulse = (Math.sin(superPulseT) * 0.5 + 0.5);
        // swing bird a bit visually
        if (bird){
          const swing = Math.sin(superPulseT*2.0) * 0.35;
          Body.setAngle(bird, birdSwingBaseAngle + swing);
        }

        // aura damage tick
        if (engine.timing.timestamp % DMG.superAuraTickEvery < 1){
          doAuraDamage();
        }
      } else {
        superPulseT *= 0.95;
        superAuraPulse *= 0.90;
      }

      if (superBannerFrames > 0) superBannerFrames--;
    }

    function doAuraDamage(){
      if (!bird) return;
      const center = bird.position;
      const r = DMG.superAuraRadius;

      const parts = structure.beams.concat(structure.pillars);
      for (const p of parts){
        if (!p || p.__stage >= 2) continue;
        const d = Vector.magnitude(Vector.sub(p.position, center));
        if (d > r) continue;

        // energy based on distance and pulse
        const k = (1 - d/r);
        const energy = DMG.superAuraEnergyPerTick * k * (0.65 + 0.35*superAuraPulse);
        p.__hp -= energy * DMG.dmgK;

        // stage changes reuse same logic thresholds
        if (p.__stage === 0 && p.__hp <= DMG.hpStage1){
          p.__stage = 1;
          p.render.sprite.texture = ASSETS.superSkin;
          stats.broken += 1;
          updateHUD();
        }
        if (p.__stage <= 1 && p.__hp <= DMG.hpStage2){
          p.__stage = 2;
          breakBody(p);
          stats.broken += 2;
          stats.score += 120;
          updateHUD();
        }
      }
    }

    // ======== EXTRA VISUALS ========
    function drawSuperOverlay(){
      const ctx = render.context;
      if (!ctx) return;

      // dim overlay
      if (superDim > 0.01){
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.globalAlpha = superDim;
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.fillRect(0,0, render.canvas.width, render.canvas.height);

        // vignette
        const v = SUPER_VISUAL.vignette;
        const grad = ctx.createRadialGradient(
          render.canvas.width/2, render.canvas.height/2,
          Math.min(render.canvas.width, render.canvas.height)*0.10,
          render.canvas.width/2, render.canvas.height/2,
          Math.max(render.canvas.width, render.canvas.height)*0.70
        );
        grad.addColorStop(0, "rgba(0,0,0,0)");
        grad.addColorStop(1, "rgba(0,0,0,"+v+")");
        ctx.globalAlpha = superDim;
        ctx.fillStyle = grad;
        ctx.fillRect(0,0, render.canvas.width, render.canvas.height);
        ctx.restore();
      }

      // banner text
      if (superBannerFrames > 0){
        const a = Math.min(1, superBannerFrames / 30);
        ctx.save();
        ctx.setTransform(1,0,0,1,0,0);
        ctx.globalAlpha = a;
        ctx.font = "900 46px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillStyle = "rgba(255,210,70,0.95)";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.shadowColor = "rgba(0,0,0,0.55)";
        ctx.shadowBlur = 18;
        ctx.fillText("–†–ê–°–ö–ê–ß–ê–ï–ú–°–Ø!!!", render.canvas.width/2, 18);
        ctx.restore();
      }

      // aura ring
      if (superActive && bird){
        const s = worldToScreen(bird.position.x, bird.position.y);
        const r = worldSizeToScreen(DMG.superAuraRadius, 0).w;
        ctx.save();
        ctx.beginPath();
        ctx.arc(s.x, s.y, r, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,210,70,0.18)";
        ctx.lineWidth = 10;
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawChairDecal(IMGS){
      // optional: you can add ground chair mark later
    }

    // ======== TRAJECTORY (aim) ========
    function worldToScreen(x, y){
      const b = render.bounds;
      return {
        x: (x - b.min.x) / (b.max.x - b.min.x) * render.canvas.width,
        y: (y - b.min.y) / (b.max.y - b.min.y) * render.canvas.height
      };
    }

    // ‚úÖ –Ω—É–∂–Ω–æ –¥–ª—è –ø–æ–ª–∞ (—Ä–∞–∑–º–µ—Ä—ã world -> screen)
    function worldSizeToScreen(w, h){
      const b = render.bounds;
      const vw = (b.max.x - b.min.x);
      const vh = (b.max.y - b.min.y);
      return {
        w: (w / vw) * render.canvas.width,
        h: (h / vh) * render.canvas.height
      };
    }

    // ‚úÖ –†–ï–ù–î–ï–† –ü–û–õ–ê (–±–µ–∑ –≤–ª–∏—è–Ω–∏—è –Ω–∞ —Ñ–∏–∑–∏–∫—É)
    function drawGround(IMGS){
      if (!IMGS || !IMGS.imgGround) return;

      const img = IMGS.imgGround;
      const b = render.bounds;

      const baseY = window.innerHeight - LEVEL.floorHeight;
      const topY = baseY - GROUND_VIS.overlap;
      const hWorld = GROUND_VIS.hWorld + GROUND_VIS.overlap;

      const srcY = (typeof img.__cropY === "number") ? img.__cropY : 0;
      const srcH = (typeof img.__cropH === "number") ? img.__cropH : img.height;

      // –≤—ã—Å–æ—Ç—É –∑–∞–¥–∞—ë–º –≤ world, —á—Ç–æ–±—ã –ø—Ä–∏ –∑—É–º–µ –≤—ã–≥–ª—è–¥–µ–ª–æ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ
      const scale = hWorld / srcH;
      const tileWWorld = img.width * scale;

      const xStart = Math.floor((b.min.x - tileWWorld) / tileWWorld) * tileWWorld;
      const xEnd = b.max.x + tileWWorld;

      const tileSizePx = worldSizeToScreen(tileWWorld, hWorld);
      const tileWpx = tileSizePx.w;
      const tileHpx = tileSizePx.h;

      const sY = worldToScreen(0, topY).y;

      const ctx = render.context;
      ctx.save();

      for (let x = xStart; x <= xEnd; x += tileWWorld){
        const sX = worldToScreen(x, topY).x;
        ctx.drawImage(
          img,
          0, srcY, img.width, srcH,
          sX, sY, tileWpx, tileHpx
        );
      }

      // –ª—ë–≥–∫–∞—è —Ç–µ–Ω—å –¥–ª—è ‚Äú–º–∞—Å—Å—ã‚Äù
      if (GROUND_VIS.shadeAlpha > 0){
        ctx.globalAlpha = GROUND_VIS.shadeAlpha;
        ctx.fillStyle = "rgba(0,0,0,1)";
        const left = worldToScreen(b.min.x, topY).x;
        const right = worldToScreen(b.max.x, topY).x;
        const width = (right - left);
        const height = worldSizeToScreen(0, hWorld).h;
        ctx.fillRect(left, sY, width, height);
        ctx.globalAlpha = 1;
      }

      // ‚úÖ —á—ë—Ç–∫–∏–π "–∫—Ä–∞–π –ø–æ–ª–∞", —á—Ç–æ–±—ã –æ–Ω –Ω–µ —Å–ª–∏–≤–∞–ª—Å—è —Å —Ñ–æ–Ω–æ–º
      // (–ª–∏–Ω–∏—è + –º—è–≥–∫–∏–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Å–≤–µ—Ä—Ö—É)
      const edgeH = Math.max(2, Math.round(tileHpx * 0.06));
      const leftEdge = worldToScreen(b.min.x, topY).x;
      const rightEdge = worldToScreen(b.max.x, topY).x;
      const edgeW = (rightEdge - leftEdge);

      // –ª–∏–Ω–∏—è
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(leftEdge, sY, edgeW, Math.max(2, Math.round(edgeH * 0.35)));

      // –≥—Ä–∞–¥–∏–µ–Ω—Ç "—Ç–µ–Ω—å –≤–Ω–∏–∑"
      const grad = ctx.createLinearGradient(0, sY, 0, sY + edgeH);
      grad.addColorStop(0, "rgba(0,0,0,0.38)");
      grad.addColorStop(1, "rgba(0,0,0,0.00)");
      ctx.fillStyle = grad;
      ctx.fillRect(leftEdge, sY, edgeW, edgeH);
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }

    function drawAimTrajectory(){
      if (!bird || birdLaunched || !draggingBird || !canLaunch) return;

      const ctx = render.context;
      const start = bird.__start;

      const pull = Vector.sub(start, bird.position);
      const dist = Math.min(Vector.magnitude(pull), SLING.pullMax);
      if (dist < 6) return;

      const dir = Vector.normalise(pull);
      const v0 = Vector.mult(dir, dist * SLING.launchK);

      const gTick = (world.gravity.y || 1) * (world.gravity.scale || 0.001) * 1000 / 60;

      let x = bird.position.x;
      let y = bird.position.y;
      let vx = v0.x;
      let vy = v0.y;

      const sA = worldToScreen(start.x, start.y);
      const sB = worldToScreen(bird.position.x, bird.position.y);

      ctx.save();
      ctx.lineWidth = 2.2;
      ctx.setLineDash([7, 8]);
      ctx.strokeStyle = "rgba(255,255,255,0.35)";
      ctx.beginPath();
      ctx.moveTo(sA.x, sA.y);
      ctx.lineTo(sB.x, sB.y);
      ctx.stroke();
      ctx.setLineDash([]);

      for (let i=0; i<AIM.steps; i++){
        x += vx * AIM.stepTicks;
        y += vy * AIM.stepTicks;
        vy += gTick * AIM.stepTicks;

        const s = worldToScreen(x, y);
        ctx.beginPath();
        ctx.arc(s.x, s.y, 2.2, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.22)";
        ctx.fill();
      }

      ctx.restore();
    }
  </script>
</body>
</html>
